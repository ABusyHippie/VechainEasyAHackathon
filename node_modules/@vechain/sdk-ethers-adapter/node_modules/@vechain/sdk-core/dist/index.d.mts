import { ethers, InterfaceAbi as InterfaceAbi$1 } from 'ethers';
export { ethers as vechain_sdk_core_ethers } from 'ethers';
import { Input, NestedUint8Array } from '@ethereumjs/rlp';
import * as n_bip32 from '@scure/bip32';

/**
 * Represents a wrapped Param Type for ethers.js types.
 */
type ParamType = ethers.ParamType;

/**
 * Represents a wrapped Function Fragment for ethers.js types.
 */
type FunctionFragment = ethers.FunctionFragment;

/**
 * Represents a wrapped Event Fragment for ethers.js types.
 */
type EventFragment = ethers.EventFragment;

/**
 * Represents a wrapped Interface for ethers.js types.
 */
type Interface = ethers.Interface;

/**
 * Represents a wrapped InterfaceAbi for ethers.js types.
 */
type InterfaceAbi = ethers.InterfaceAbi;

/**
 * Represents a wrapped Result for ethers.js types.
 * It represents the decoded data from a transaction (after decoding).
 */
type Result = ethers.Result;

/**
 * Represents a wrapped Log description for ethers.js types.
 * It represents the decoded data from a log (after decoding).
 */
type Log = ethers.LogDescription;

/**
 * Represents a wrapped BytesLike for ethers.js types.
 */
type BytesLike$1 = ethers.BytesLike;

/**
 * Represents a wrapped FormatType for ethers.js types.
 * It is used to represents the format of the signature of a function.
 */
type FormatType = ethers.FormatType;

/**
 * Represents a function call in the Event/Function ABI.
 *
 * @template ABIType - The ABI fragment type.
 */
declare class Function<ABIType> {
    /**
     * The main fragment handled by ethers.js.
     *
     */
    fragment: FunctionFragment;
    /**
     * The main interface handled by ethers.js.
     */
    iface: Interface;
    /**
     * Creates a new Function instance from an ABI fragment.
     *
     * @throws{InvalidAbiFunctionError}
     * @param source - ABI fragment to use.
     */
    constructor(source: ABIType);
    /**
     * Get the signature hash of the function.
     *
     * @returns The signature hash of the function.
     */
    signatureHash(): string;
    /**
     * Get the signature of the function.
     *
     * @param formatType - The format type of the signature: 'sighash', 'minimal', 'full', or 'json'.
     * @returns The signature of the function.
     */
    signature(formatType: FormatType): string;
    /**
     * Decode data using the function's ABI.
     *
     * @throws{InvalidAbiDataToDecodeError} - If the data cannot be decoded.
     * @param data - Data to decode.
     * @returns Decoding results.
     */
    decodeInput(data: BytesLike$1): Result;
    /**
     * Decodes the output data from a transaction based on ABI (Application Binary Interface) specifications.
     * This method attempts to decode the given byte-like data into a readable format using the contract's interface.
     *
     * @param data - The `BytesLike` data to be decoded, typically representing the output of a contract function call.
     * @returns A `Result` object containing the decoded data.
     *
     * @throws{InvalidAbiDataToDecodeError} - If the data cannot be decoded.
     *
     * @example
     * ```typescript
     *   const decoded = contractInstance.decodeOutput(rawTransactionOutput);
     *   console.log('Decoded Output:', decoded);
     * ```
     */
    decodeOutput(data: BytesLike$1): Result;
    /**
     * Encode data using the function's ABI.
     *
     * @throws{InvalidAbiDataToEncodeError}
     * @param dataToEncode - Data to encode.
     * @returns Encoded data.
     */
    encodeInput<TValue>(dataToEncode?: TValue[]): string;
}
/**
 * Represents an event call in the Event/Function ABI.
 *
 * @template ABIType - The ABI fragment type.
 */
declare class Event<ABIType> {
    /**
     * The main fragment handled by ethers.js.
     */
    fragment: EventFragment;
    /**
     * The main interface handled by ethers.js.
     */
    iface: Interface;
    /**
     * Creates a new Event instance from an ABI fragment.
     *
     * @throws{InvalidAbiEventError}
     * @param source - ABI fragment to use.
     */
    constructor(source: ABIType);
    /**
     * Get the signature hash of the event.
     *
     * @returns The signature hash of the event.
     */
    signatureHash(): string;
    /**
     * Get the signature of the event.
     *
     * @param formatType - The format type of the signature: 'sighash', 'minimal', 'full', or 'json'.
     * @returns The signature of the event.
     */
    signature(formatType: FormatType): string;
    /**
     * Decode event log data using the event's ABI.
     *
     * @throws{InvalidAbiDataToDecodeError}
     * @param data - Data to decode.
     * @returns Decoding results.
     */
    decodeEventLog(data: {
        data: string;
        topics: string[];
    }): Result;
    /**
     * Encode event log data using the event's ABI.
     *
     * @throws{InvalidAbiDataToEncodeError}
     * @param dataToEncode - Data to encode.
     * @returns Encoded data along with topics.
     */
    encodeEventLog<TValue>(dataToEncode: TValue[]): {
        data: string;
        topics: string[];
    };
    /**
     * Encode event log topics using the event's ABI.
     *
     * @param valuesToEncode - values to encode as topics. Non-indexed values are ignored.
     *                         Only the values of the indexed parameters are needed.
     *
     * @returns Encoded topics array.
     */
    encodeFilterTopics<TValue>(valuesToEncode: TValue[]): Array<string | undefined>;
}
/**
 * Object containing ABI representations.
 */
declare const fragment: {
    Function: typeof Function;
    Event: typeof Event;
};

/**
 * Encodes a parameter value.
 *
 * @note `ValueType` is used to explicitly specify the type of the value to encode.
 *
 * @throws{InvalidAbiDataToEncodeError}
 * @param type - Type of the parameter.
 * @param value - Value to encode.
 * @returns Encoded parameter as a hexadecimal string.
 */
declare function encode$2<ValueType>(type: string | ParamType, value: ValueType): string;
/**
 * Encodes the given values according to the specified ABI types.
 *
 * @param types - An array of ABI types or an array of ParamType objects representing the types of the values to encode.
 * @param values - An array of values to be encoded according to the specified ABI types.
 * @returns The ABI-encoded string representing the given values.
 * @throws Throws an error if encoding fails. The error message indicates that the data must be a valid ABI type with corresponding valid data.
 *
 * @template ValueType - The type of the values being encoded.
 *
 * @example
 * ```typescript
 * const abiTypes = ['uint256', 'address'];
 * const values = [123, '0x1234567890123456789012345678901234567890'];
 * const encodedParams = encodeParams(abiTypes, values);
 * console.log(encodedParams);
 * ```
 */
declare function encodeParams(types: string[] | ParamType[], values: string[]): string;
/**
 * Decodes a parameter value.
 *
 * @note `ReturnType` is used to explicitly specify the return type (the decoded value) of the function.
 *
 * @throws{InvalidAbiDataToDecodeError}
 * @param types - Types of parameters.
 * @param data - Data to decode.
 * @returns Decoded parameter value.
 */
declare function decode$2<ReturnType>(types: string | ParamType, data: BytesLike$1): ReturnType;
/**
 * Object containing ABI representations.
 */
declare const abi: {
    encode: typeof encode$2;
    encodeParams: typeof encodeParams;
    decode: typeof decode$2;
    Function: {
        new <ABIType>(source: ABIType): {
            fragment: FunctionFragment;
            iface: Interface;
            signatureHash(): string;
            signature(formatType: FormatType): string;
            decodeInput(data: BytesLike$1): Result;
            decodeOutput(data: BytesLike$1): Result;
            encodeInput<TValue>(dataToEncode?: TValue[]): string;
        };
    };
    Event: {
        new <ABIType>(source: ABIType): {
            fragment: EventFragment;
            iface: Interface;
            signatureHash(): string;
            signature(formatType: FormatType): string;
            decodeEventLog(data: {
                data: string;
                topics: string[];
            }): Result;
            encodeEventLog<TValue>(dataToEncode: TValue[]): {
                data: string;
                topics: string[];
            };
            encodeFilterTopics<TValue>(valuesToEncode: TValue[]): Array<string | undefined>;
        };
    };
};

/**
 * Creates a new Interface instance from an ABI fragment.
 * @param abi - ABI in a compatible format
 * @returns The Interface instance.
 */
declare function createInterface(abi: InterfaceAbi$1): Interface;
/**
 * Encode function data that can be used to send a transaction.
 * @param interfaceABI ABI in a compatible format
 * @param functionName The name of the function defined in the ABI.
 * @param functionData The data to pass to the function.
 * @returns The encoded data that can be used to send a transaction.
 * @throws {InvalidAbiDataToDecodeError}
 */
declare function encodeFunctionInput(interfaceABI: InterfaceAbi$1, functionName: string, functionData?: unknown[]): string;
/**
 * Decode the function data of an encoded function
 * @param interfaceABI ABI in a compatible format
 * @param functionName The name of the function defined in the ABI.
 * @param encodedFunctionInput The encoded function data.
 * @returns an array of the decoded function data
 *
 * @throws {InvalidAbiDataToDecodeError}
 */
declare function decodeFunctionInput(interfaceABI: InterfaceAbi$1, functionName: string, encodedFunctionInput: BytesLike$1): Result;
/**
 * Decodes the output from a contract function using the specified ABI and function name.
 * It takes the encoded function output and attempts to decode it according to the ABI definition.
 *
 * @param {InterfaceAbi} interfaceABI - The ABI (Application Binary Interface) of the contract,
 *                                      which defines how data is structured in the blockchain.
 * @param {string} functionName - The name of the function in the contract to decode the output for.
 * @param encodedFunctionOutput - The encoded output data from the contract function.
 * @returns {Result} - The decoded output as a Result object, which provides a user-friendly way
 *                     to interact with the decoded data.
 *
 * @throws Will throw an error if decoding fails, typically due to incorrect encoding or mismatch
 *         with the ABI specifications. The error will provide details on the specific issue encountered.
 *
 * @example
 * // Example of decoding output for a function called "getValue":
 * const decodedOutput = decodeFunctionOutput(contractABI, 'getValue', encodedValue);
 *
 */
declare function decodeFunctionOutput(interfaceABI: InterfaceAbi$1, functionName: string, encodedFunctionOutput: BytesLike$1): Result;
/**
 * Encodes event log data based on the provided contract interface ABI, event name, and data to encode.
 * @param interfaceABI - The ABI (Application Binary Interface) of the contract.
 * @param eventName - The name of the event to be encoded.
 * @param dataToEncode - An array of data to be encoded in the event log.
 * @returns An object containing the encoded data and topics.
 * @throws {InvalidAbiEventError} Throws an error if encoding fails, including relevant details.
 */
declare function encodeEventLog(interfaceABI: InterfaceAbi$1, eventName: string, dataToEncode: unknown[]): {
    data: string;
    topics: string[];
};
/**
 * Decodes event log data based on the provided contract interface ABI, event name, and data/topics to decode.
 * @param interfaceABI - The ABI (Application Binary Interface) of the contract.
 * @param eventName - The name of the event to be decoded.
 * @param dataToDecode - An object containing the data and topics to be decoded.
 * @returns The decoded data of the event log.
 * @throws {InvalidAbiEventError} Throws an error if decoding fails, including relevant details.
 */
declare function decodeEventLog(interfaceABI: InterfaceAbi$1, eventName: string, dataToDecode: {
    data: string;
    topics: string[];
}): Result;
/**
 * Decodes an Ethereum log based on the ABI definition.
 *
 * This method takes raw `data` and `topics` from an Ethereum log and attempts
 * to decode them using the contract's ABI definition. If the decoding is successful,
 * it returns a `Log` object representing the decoded information. If the decoding fails,
 * it throws a custom error with detailed information.
 *
 * @param interfaceABI - The ABI (Application Binary Interface) of the contract.
 * @param {string} data - The hexadecimal string of the data field in the log.
 * @param {string[]} topics - An array of hexadecimal strings representing the topics of the log.
 * @returns {Log | null} - A `Log` object representing the decoded log or null if decoding fails.
 * @throws {InvalidAbiDataToDecodeError} - if decoding fails due to invalid data or topics format.
 */
declare function parseLog(interfaceABI: InterfaceAbi$1, data: string, topics: string[]): Log | null;
declare const coder: {
    createInterface: typeof createInterface;
    encodeFunctionInput: typeof encodeFunctionInput;
    decodeFunctionInput: typeof decodeFunctionInput;
    decodeFunctionOutput: typeof decodeFunctionOutput;
    encodeEventLog: typeof encodeEventLog;
    decodeEventLog: typeof decodeEventLog;
    parseLog: typeof parseLog;
};

/**
 * Computes an VeChainThor address from a given private key.
 *
 * Secure audit function.
 * - {@link fromPublicKey}
 * - {@link secp256k1.derivePublicKey}
 *
 * @param {Uint8Array} privateKey - The private key used to compute the public key
 * from which the address is computed.
 * @returns {string} - The string representation of the address,
 * prefixed with `0x` according the
 * [ERC-55: Mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55).
 *
 * @see {secp256k1.derivePublicKey}
 * @see {fromPublicKey}
 */
declare function fromPrivateKey$1(privateKey: Uint8Array): string;
/**
 * Computes a VeChainThor address from a public key.
 *
 * Secure audit function.
 * - {@link secp256k1.inflatePublicKey}
 * - {@link keccak256}
 *
 * @param {Uint8Array} publicKey - The public key to convert,
 * either in compressed or uncompressed.
 * @returns {string} - The string representation of the address,
 * prefixed with `0x` according the
 * [ERC-55: Mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55).
 *
 * @remarks
 * Following the [Ethereum Address](https://ethereum.org/en/whitepaper/#notes-and-further-reading)
 * specification, the returned address is computed
 * - from the uncompressed public key,
 * - removing the first byte flagging the uncompressed form,
 * - computing the [KECCAK256](https://en.wikipedia.org/wiki/SHA-3) hash
 * - represented in ERC-55 mixed case hexadecimal form,
 * - prefixed with `0x`.
 *
 * @see {secp256k1.inflatePublicKey}
 */
declare function fromPublicKey$1(publicKey: Uint8Array): string;
/**
 * Checks if the given string is a valid VeChainThor address.
 *
 * @param {string} addressToVerify - The string to be checked for validity.
 * @return {boolean} - True if the string is a valid address, otherwise false.
 *
 * @see {HEX_ADDRESS_REGEX}
 */
declare function isAddress(addressToVerify: string): boolean;
/**
 * Converts the given VeChainThor address to its
 * [EIP/ERC-55: Mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55)
 * representation.
 *
 * Secure audit function.
 * - {@link keccak256}
 *
 * @param {string} address - The address to be converted,
 * it must be prefixed with `0x`.
 * @return {string} - The EIP/ERC-55 checksum address.
 *
 * @throws {InvalidAddressError} if `address` is not a valid hexadecimal
 * representation 40 digits long, prefixed with `0x`.
 *
 * @see {isAddress}
 */
declare function toERC55Checksum(address: string): string;
declare const addressUtils: {
    fromPrivateKey: typeof fromPrivateKey$1;
    fromPublicKey: typeof fromPublicKey$1;
    isAddress: typeof isAddress;
    toERC55Checksum: typeof toERC55Checksum;
};

/**
 * Calculates the optimal number of bits per key (`m` in math literature) based
 * on the number of hash functions (`k`) used to generate the Bloom Filter.
 *
 * Mathematically, `bitsPerkey` is approximated as `(k / ln(2))` which is simplified
 * to the higher integer close to `(bitsPerKey / 0.69)` for computational efficiency.
 * It also ensures that `k` is within a practical range [1, 30], hence the function
 * - returns `2` for `k = 1`,
 * - returns `44` for `k >= 30`.
 *
 * @param {number} k - The number of keys.
 * @return {number} - The number of bits per key.
 */
declare function calculateBitsPerKey(k: number): number;
/**
 * Calculates the optimal number of hash functions (`k`) based on bits per key.
 *
 * Mathematically, `k` is approximated as `(bitsPerKey * ln(2))` which is simplified
 * to the lower integer close to `(bitsPerKey * 0.69)` for computational efficiency.
 * It also ensures that `k` stays within a practical range [1, 30].
 *
 * @param bitsPerKey - The number of bits per key.
 * @returns The calculated optimal `k` value.
 */
declare function calculateK(bitsPerKey: number): number;
/**
 * This class represents a Bloom filter with its associated bit array and
 * a specified number (k) of hash functions.
 */
declare class Filter {
    readonly bits: Uint8Array;
    readonly k: number;
    /**
     * Constructs a new Filter instance.
     *
     * @constructor
     * @param {Uint8Array} bits - The input array containing bits.
     * @param {number} k - The value of k.
     */
    constructor(bits: Uint8Array, k: number);
    /**
     * Composes the current filter with another filter by performing a bitwise OR operation on the filter bits.
     * Both filters must have been generated with the same number of hash functions, and they must have the same length.
     *
     * @param {Filter} other - The filter to compose with.
     * @returns {Filter} - A new filter that is the result of the composition.
     *
     * @throws InvalidBloomError If the other filter has a different length.
     * @throws InvalidKError if the other filter was generated with a different `k` number of hash functions.
     */
    compose(other: Filter): Filter;
    /**
     * Checks if the Bloom filter may contain the specified key.
     * Note: false positives are possible, but false negatives are not.
     *
     * @param {Uint8Array} key - The key to check.
     *
     * @return {boolean} - True if the Bloom filter may contain the key, otherwise false.
     */
    contains(key: Uint8Array): boolean;
    /**
     * Checks if the current filter is composable with another filter.
     * Two filters are composable if they have the same 'k' value expressing the number of hash function used for
     * the generation of the filters, and the same number of bits.
     *
     * @param {Filter} other - The filter to compare with.
     *
     * @return {boolean} - True if the filters are composable, false otherwise.
     */
    isComposableWith(other: Filter): boolean;
}
/**
 * Represents a Bloom filter generator.
 *
 * This class aids in the creation and management of Bloom filters.
 * It allows keys to be added, internally hashes them, and provides
 * a method to generate a Bloom filter based on the added keys.
 */
declare class Generator {
    private readonly hashes;
    /**
     * Adds a key to the set of hashes.
     *
     * Secure audit function.
     * * {@link hash}
     *
     * @param {Uint8Array} key - The key to be added to the set of hashes.
     */
    add(key: Uint8Array): void;
    /**
     * Generates a Bloom filter with the specified number of bits per key and number of hash functions.
     * The generator will be reset after generation.
     *
     * @param {number} bitsPerKey - The desired number of bits per key in the Bloom filter (`m` in math literature).
     * @param {number} k - The number of hash functions to use in the Bloom filter.
     * @returns {Filter} - The generated Bloom filter.
     */
    generate(bitsPerKey: number, k: number): Filter;
}
declare const bloom: {
    calculateBitsPerKey: typeof calculateBitsPerKey;
    calculateK: typeof calculateK;
    Filter: typeof Filter;
    Generator: typeof Generator;
};

/**
 * In the VeChainThor blockchain, a certificate is a data structure used for client-side self-signed certificates.
 * It plays a crucial role in providing a mechanism for secure identification and validation of data.
 *
 * Certificates are primarily used for purposes like attestation, validation, and verification of data authenticity.
 * They are used as proofs of authenticity and origin for data exchanged within the VeChain ecosystem.
 */
interface Certificate {
    /**
     * The purpose field indicates the intended use or context of the certificate.
     * For example, it could be used for identification, verification, or attestation.
     */
    purpose: string;

    /**
     * The payload field holds the actual content of the certificate.
     * This content can be of various types, such as text, images, or other data.
     */
    payload: {
        type: string;
        content: string;
    };

    /**
     * The domain field represents the specific context or domain for which the certificate is valid.
     * It helps ensure that the certificate is only applicable within the intended context.
     */
    domain: string;

    /**
     * The timestamp field records the time at which the certificate was created or issued.
     * This provides a temporal reference for the certificate's validity.
     */
    timestamp: number;

    /**
     * The signer field indicates the address of the entity that signs the certificate.
     * It is the public key address of the entity that issues the certificate.
     */
    signer: string;

    /**
     * The signature field contains the cryptographic signature generated by the issuer's private key.
     * This signature ensures the integrity and authenticity of the certificate's content.
     */
    signature?: string;
}

/**
 * Encodes a certificate object to an array of bytes of its JSON representation after the following
 * normalization operations are applied:
 * * only the properties defined in the {@link Certificate} interface are evaluated;
 * * the properties are sorted in ascending alphabetic order;
 * * the key/value properties are delimited with `"`;
 * * any not meaningful blank characters are ignored;
 * * the `signer` property is a hexadecimal address represented lowercase to back compatible with the certificates
 *   not implementing the [EIP/ERC-55: Mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55);
 * * the UTF-8 code is normalized according the
 *   [normalization form for canonical composition](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms)
 *
 * @param {Certificate} cert - The certificate object to encode.
 * @return {Uint8Array} - The byte encoded certificate.
 *
 *
 * @see {NORMALIZATION_FORM_CANONICAL_COMPOSITION}
 * @see {https://www.npmjs.com/package/fast-json-stable-stringify fastJsonStableStringify}
 * @see {sign}
 * @see {verify}
 */
declare function encode$1(cert: Certificate): Uint8Array;
/**
 * Signs a certificate using a private key.
 *
 * The signature is computed encoding the certificate according the following normalization rules:
 * * only the properties defined in the {@link Certificate} interface are evaluated;
 * * the properties are sorted in ascending alphabetic order;
 * * the key/value properties are delimited with `"`;
 * * any not meaningful blank characters are ignored;
 * * the `signer` property is a hexadecimal address represented lowercase to back compatible with the certificates
 *   not implementing the [EIP/ERC-55: Mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55);
 * * the UTF-8 code is normalized according the
 *   [normalization form for canonical composition](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms).
 *
 * The [BLAKE2](https://en.wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2) hash is computed from the encoded
 * certificate, then the hash is signed using the [SECP256K1](https://en.bitcoin.it/wiki/Secp256k1) parameters.
 *
 * [EIP/ERC-55: Mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55).
 * is supported.
 *
 * Secure audit function.
 * - {@link blake2b256};
 * - {@link secp256k1.sign}.
 *
 * @param {Certificate} cert - The certificate to be signed.
 *                             Any instance extending the {@link Certificate} interface is supported.
 * @param {Uint8Array} privateKey - The private key used for signing.
 *
 * @returns {Certificate} - A new instance of the certificate with the signature added.
 *
 * @throws {InvalidSecp256k1PrivateKeyError} - If the private key is invalid.
 *
 */
declare function sign$2(cert: Certificate, privateKey: Uint8Array): Certificate;
/**
 * Verifies the validity of a certificate, throwing an error if the certificate is not valid.
 *
 * The certificate is valid when the signer's address computed from the signature
 * matches with the property {@link Certificate.signer}.
 *
 * This method is insensitive to the case representation of the signer's address.
 *
 * [EIP/ERC-55: Mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55).
 * is supported.
 *
 * Secure audit function.
 * - {@link blake2b256};
 * - {@link secp256k1.recover}.
 *
 * @param {Certificate} cert - The certificate to verify.
 *                             Any instance extending the {@link Certificate} interface is supported.
 *
 * @throws {Error} CERTIFICATE.CERTIFICATE_NOT_SIGNED - If the certificate's signature is missing.
 * @throws {Error} CERTIFICATE.CERTIFICATE_INVALID_SIGNATURE_FORMAT - If the signature format is invalid.
 * @throws {Error} CERTIFICATE.CERTIFICATE_INVALID_SIGNER - If the signature does not correspond to the signer's public key.
 *
 * @see {encode}
 */
declare function verify(cert: Certificate): void;
/**
 * Exposes the certificate sign and verification functions.
 */
declare const certificate: {
    encode: typeof encode$1;
    sign: typeof sign$2;
    verify: typeof verify;
};

/**
 * `ScalarKind` Abstract Class - A base for scalar kinds providing contract for data and buffer manipulations.
 */
declare abstract class ScalarKind {
    /**
     * Abstract method to handle data encoding.
     * @param data - The data to encode.
     * @param context - Contextual information for error messaging.
     * @returns An object providing a mechanism to encode the data into a Buffer.
     */
    abstract data(data: RLPInput | RLPValidObject, context: string): DataOutput;
    /**
     * Abstract method to handle buffer decoding.
     * @param buffer - The buffer to decode.
     * @param context - Contextual information for error messaging.
     * @returns An object providing a mechanism to decode the buffer back into data.
     */
    abstract buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a scalar kind with Buffer functionality.
 * This class extends the {@link ScalarKind} class.
 */
declare class BufferKind extends ScalarKind {
    /**
     * Encodes the input data into buffer format.
     *
     * @throws{InvalidRLPError}
     * @param data - The data to encode, expected to be of buffer type.
     * @param context - Descriptive context for error messages
     * @returns DataOutput object with an encode function.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer.
     *
     * @throws{InvalidRLPError}
     * @param buffer - The buffer to decode, expected to be of buffer type.
     * @param context - Descriptive context for error messages, usually representing the caller's identity.
     * @returns BufferOutput object with a decode function.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a scalar kind with numeric functionality.
 * This class extends the {@link ScalarKind} class.
 */
declare class NumericKind extends ScalarKind {
    readonly maxBytes?: number | undefined;
    /**
     * Constructs a new instance of NumericKind.
     *
     * @param maxBytes - Optional parameter that specifies the maximum number of bytes that numeric data can occupy when encoded.
     */
    constructor(maxBytes?: number | undefined);
    /**
     * Encodes the input data into numeric format and ensures it doesn't exceed the maximum bytes, if specified.
     *
     * @param data - The data to encode, expected to be numeric.
     * @param context - Descriptive context for error messages
     * @returns DataOutput object with an encode function.
     * @throws Will throw an error if data validation fails or encoding issues occur.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a number or hexadecimal string, ensuring it meets numeric data constraints.
     *
     * @param buffer - The buffer to decode, containing numeric data.
     * @param context - Descriptive context for error messages.
     * @returns BufferOutput object with a decode function.
     * @throws Will throw an error if buffer validation fails.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a scalar kind with hex blob functionality.
 * This class extends the {@link ScalarKind} class.
 *
 * @remarks
 * A hex blob is a hex string that is prefixed with '0x' and has even length.
 */
declare class HexBlobKind extends ScalarKind {
    /**
     * Encodes the input data into a Buffer.
     *
     * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Buffer.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a hex string.
     *
     * @param buffer - The buffer to decode.
     * @param context - Context string for error handling.
     * @returns An object containing a decode function which returns the decoded hex string.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a hex blob kind with fixed bytes size functionality.
 * This class extends the {@link HexBlobKind} class.
 */
declare class FixedHexBlobKind extends HexBlobKind {
    readonly bytes: number;
    /**
     * Creates a new instance of the {@link FixedHexBlobKind} class.
     * @param bytes - The number of bytes the blob must have.
     */
    constructor(bytes: number);
    /**
     * Encodes the input data into a Buffer with validation against fixed size.
     *
     * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Buffer.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a hex string with validation against fixed size.
     *
     * @param buffer - The buffer to decode.
     * @param context - Context string for error handling.
     * @returns An object containing a decode function which returns the decoded hex string.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a fixed hex blob kind with optional data functionality.
 * This class extends the {@link FixedHexBlobKind} class.
 */
declare class OptionalFixedHexBlobKind extends FixedHexBlobKind {
    /**
     * Encodes the input data (which can be null or undefined) into a Buffer.
     *
     * @param data - The data to encode, can be null or undefined.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Buffer.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a hex string or null if the buffer is empty.
     *
     * @param buffer - The buffer to decode, can be empty.
     * @param context - Context string for error handling.
     * @returns An object containing a decode function which returns the decoded hex string or null.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * Represents a fixed hex blob kind with zero trimming and padding functionality.
 * This class extends the {@link FixedHexBlobKind} class.
 */
declare class CompactFixedHexBlobKind extends FixedHexBlobKind {
    /**
     * Encodes the input data into a Buffer, trimming leading zeros.
     *
     * @param data - The data to encode, expected to be a '0x' prefixed hex string.
     * @param context - Context string for error handling.
     * @returns An object containing an encode function which returns the encoded Buffer.
     */
    data(data: RLPInput, context: string): DataOutput;
    /**
     * Decodes the input buffer into a number or hexadecimal string, ensuring it meets the fixed size by padding with zeros.
     *
     * @param buffer - The buffer to decode, containing numeric data.
     * @param context - Descriptive context for error messages, usually representing the caller's identity.
     * @returns BufferOutput object with a decode function.
     * @throws Will throw an error if buffer validation fails.
     */
    buffer(buffer: Buffer, context: string): BufferOutput;
}

/**
 * RLP_CODER profile classes.
 */
declare const RLPProfiles: {
    ScalarKind: typeof ScalarKind;
    BufferKind: typeof BufferKind;
    NumericKind: typeof NumericKind;
    HexBlobKind: typeof HexBlobKind;
    FixedHexBlobKind: typeof FixedHexBlobKind;
    OptionalFixedHexBlobKind: typeof OptionalFixedHexBlobKind;
    CompactFixedHexBlobKind: typeof CompactFixedHexBlobKind;
};

/**
 * Represents a valid input for the RLP (Recursive Length Prefix) encoding.
 * The RLP encoding is used to encode arbitrary binary data (nested arrays of bytes).
 *
 * @typeParam Input - Can be a Buffer, Array of Inputs, Buffer array, or nested array of Inputs.
 * @see {@link https://github.com/ethereumjs/ethereumjs-monorepo/blob/master/packages/rlp/src/index.ts}
 */
type RLPInput = Input;

/**
 * Represents an output from RLP decoding.
 * This type can either be a single Uint8Array (byte array) or a nested structure
 * of Uint8Array instances.
 *
 * @typeParam Uint8Array - A typed array of 8-bit unsigned integers.
 * @typeParam NestedUint8Array - A possibly nested array of Uint8Arrays.
 */
type RLPOutput = Uint8Array | NestedUint8Array;

/**
 * Represents a complex RLP object.
 * This type allows for recursive nesting of RLPInput or further RLPComplexObjects,
 * allowing the definition of complex structures.
 *
 * @typeParam RLPInput - A valid RLP input type.
 * @typeParam RLPComplexObject - Recursive type to enable nesting of complex objects.
 */
interface RLPComplexObject {
    [key: string]: RLPInput | RLPComplexObject | RLPComplexObject[];
}

/**
 * Represents a valid RLP object.
 * It is a dictionary-like object where keys are strings and values can be
 * a valid RLP input type or a complex RLP object (which can be further nested).
 *
 * @typeParam RLPValueType - A type that represents all valid RLP values.
 */
type RLPValidObject = Record<string, RLPValueType>;

/**
 * Represents all valid RLP value types.
 * This type union is used to simplify the definition of valid value types within
 * RLP object structures, supporting single inputs, complex objects, and arrays
 * of complex objects.
 *
 * @typeParam RLPInput - A valid RLP input type.
 * @typeParam RLPComplexObject - A valid complex RLP object.
 */
type RLPValueType = RLPInput | RLPComplexObject | RLPComplexObject[];

/* ------- RLP Profile Types ------- */
/**
 * `RLPProfile` Interface - Describes the profile of the RLP encoding.
 */
interface RLPProfile {
    name: string;
    kind: ScalarKind | ArrayKind | StructKind;
}

/**
 * `ArrayKind` Interface - Describes an array-kind in the RLP encoding profile.
 */
interface ArrayKind {
    item: RLPProfile['kind'];
}

/**
 * `StructKind` Type - Describes a structured-kind in the RLP encoding profile using an array of `RLPProfile`.
 */
type StructKind = RLPProfile[];

/**
 * `DataOutput` Interface - Provides an encoding mechanism to convert data into a Buffer.
 */
interface DataOutput {
    encode: () => Buffer;
}

/**
 * `BufferOutput` Interface - Provides a decoding mechanism to convert a Buffer back into data.
 */
interface BufferOutput {
    decode: () => RLPInput;
}

/**
 * Encodes data using the Ethereumjs RLP library.
 * @param data - The data to be encoded.
 * @returns The encoded data as a Buffer.
 */
declare function encode(data: RLPInput): Buffer;
/**
 * Decodes RLP-encoded data using the Ethereumjs RLP library.
 * @param encodedData - The RLP-encoded data as a Buffer.
 * @returns The decoded data or null if decoding fails.
 */
declare function decode$1(encodedData: Buffer): RLPOutput;
/**
 * Class handling the profiling of RLP encoded/decoded objects.
 * Provides methods to encode and decode objects based on a provided RLP profile.
 */
declare class Profiler {
    readonly profile: RLPProfile;
    /**
     * Creates a new Profiler instance.
     * @param profile - RLP_CODER profile for encoding/decoding structures.
     */
    constructor(profile: RLPProfile);
    /**
     * Encodes an object following the provided RLP_CODER profile.
     * @param data - Object to be encoded.
     * @returns - Encoded data as a Buffer.
     */
    encodeObject(data: RLPValidObject): Buffer;
    /**
     * Decodes an object following the provided RLP_CODER profile.
     * @param encodedData - Data to be decoded.
     * @returns - Decoded data as RLPValueType.
     */
    decodeObject(encodedData: Buffer): RLPValueType;
}
declare const RLPBase: {
    encode: typeof encode;
    decode: typeof decode$1;
    Profiler: typeof Profiler;
};

/**
 * Validates and converts the input data to a BigInt.
 *
 * @throws{InvalidRLPError}
 * @param data - Either a number or a string representing a non-negative integer.
 * @param context - A string representing the context in which this function is used,
 *                 to create meaningful error messages.
 * @returns The input data converted to a BigInt.
 */
declare const validateNumericKindData: (data: RLPInput, context: string) => bigint;
/**
 * Validates a buffer to ensure it adheres to constraints and does not contain
 * leading zero bytes which are not canonical representation in integers.
 *
 * @throws{InvalidRLPError}
 * @param buf - The buffer to validate.
 * @param context - A string providing context for error messages.
 * @param maxBytes - [Optional] An integer representing the maximum allowed length
 *                   of the buffer. If provided, an error will be thrown if buf is longer.
 *
 * @private
 */
declare const assertValidNumericKindBuffer: (buf: Buffer, context: string, maxBytes?: number) => void;
/**
 * Encode a BigInt instance into a Buffer, ensuring it adheres to specific constraints.
 *
 * @throws{InvalidRLPError}
 * @param bi - BigInt instance to encode.
 * @param maxBytes - Maximum byte length allowed for the encoding. If undefined, no byte size limit is imposed.
 * @param context - Contextual information for error messages.
 * @returns A Buffer instance containing the encoded data.
 */
declare const encodeBigIntToBuffer: (bi: bigint, maxBytes: number | undefined, context: string) => Buffer;
/**
 * Decode a Buffer into a number or hexadecimal string.
 * @param buffer - Buffer instance to decode.
 * @returns A number if the decoded BigInt is a safe integer, otherwise returns a hexadecimal string.
 */
declare const decodeBufferToNumberOrHex: (buffer: Buffer) => number | string;

/**
 * Validates if the input is a proper hex string for HexBlobKind.
 *
 * @throws{InvalidRLPError}
 * @param data - The input data to validate.
 * @param context - Additional context for error handling.
 */
declare const assertValidHexBlobKindData: (data: RLPInput, context: string) => void;
/**
 * Validates if the input buffer is valid for HexBlobKind.
 *
 * @throws{InvalidRLPError}
 * @param buffer - The buffer to validate.
 * @param context - Additional context for error handling.
 */
declare const assertValidHexBlobKindBuffer: (buffer: Buffer, context: string) => void;

/**
 * Asserts that the data is a hex string of the correct length.
 *
 * @throws{InvalidRLPError} Will throw an error with a message containing the context if the data length is not equal to the specified bytes.
 * @param data - The data to validate.
 * @param context - Descriptive context for error messages.
 * @param bytes - The expected number of bytes that the data can contain.
 */
declare const assertFixedHexBlobKindData: (data: string, context: string, bytes: number) => void;
/**
 * Asserts that the buffer is of a specific length.
 *
 * @throws{InvalidRLPError} - Will throw an error with a message containing the context if the buffer length is not equal to the specified bytes.
 * @param buffer - The buffer to validate.
 * @param context - Descriptive context for error messages.
 * @param bytes - The expected number of bytes that the buffer can contain.
 *
 */
declare const assertFixedHexBlobKindBuffer: (buffer: Buffer, context: string, bytes: number) => void;

/**
 * Asserts that the provided buffer is of a specific length and does not contain leading zeros.
 *
 * @throws{InvalidRLPError} - Will throw an error with a message containing the context if the buffer length is greater than the specified bytes OR if it has leading zero bytes.
 * @param buffer - The buffer to validate.
 * @param context - Descriptive context for error messages, usually representing the caller's identity.
 * @param bytes - The expected maximum number of bytes that the buffer can contain.
 */
declare const assertCompactFixedHexBlobBuffer: (buffer: Buffer, context: string, bytes: number) => void;
/**
 * Encodes a buffer by trimming leading zero bytes.
 * Finds the first non-zero byte and returns a new buffer starting from that byte. Returns an empty buffer if all bytes are zero.
 *
 * @param buffer - The buffer to be Compact.
 * @returns A Buffer instance Compact of leading zero bytes, or an empty Buffer if all bytes are zero.
 */
declare const encodeCompactFixedHexBlob: (buffer: Buffer) => Buffer;
/**
 * Decodes a buffer into a hexadecimal string, ensuring a specific total byte length by prepending zeros if necessary.
 * Calculates the number of missing bytes compared to the expected total and prepends the corresponding number of '0' characters to the hexadecimal string representation of the buffer.
 *
 * @param buffer - The buffer to decode.
 * @param bytes - The expected total number of bytes in the final hexadecimal string (including leading zeros).
 * @returns A hexadecimal string with the necessary leading '0' characters to ensure the specified total byte length.
 */
declare const decodeBufferToHexWithLeadingZeros: (buffer: Buffer, bytes: number) => string;

/**
 * The `RLP_CODER` object, encapsulating all functionalities related to Recursive Length Prefix (RLP_CODER) encoding.
 *
 * RLP_CODER contains the following classes and methods:
 * - `encode` - Encodes data using the Ethereumjs RLP_CODER library.
 * - `decode` - Decodes RLP_CODER-encoded data using the Ethereumjs RLP_CODER library.
 * - `Profiler` - Class handling the profiling of RLP_CODER encoded/decoded objects.
 * - `ScalarKind` - Abstract class for scalar types.
 * - `BufferKind` - Class managing buffers and ensuring type safety with encode/decode methods.
 * - `NumericKind` - Class managing numerical data ensuring it adheres to specific constraints.
 */
declare const RLP_CODER: {
    ScalarKind: typeof ScalarKind;
    BufferKind: typeof BufferKind;
    NumericKind: typeof NumericKind;
    HexBlobKind: typeof HexBlobKind;
    FixedHexBlobKind: typeof FixedHexBlobKind;
    OptionalFixedHexBlobKind: typeof OptionalFixedHexBlobKind;
    CompactFixedHexBlobKind: typeof CompactFixedHexBlobKind;
    encode: (data: RLPInput) => Buffer;
    decode: (encodedData: Buffer) => RLPOutput;
    Profiler: {
        new (profile: RLPProfile): {
            readonly profile: RLPProfile;
            encodeObject(data: RLPValidObject): Buffer;
            decodeObject(encodedData: Buffer): RLPValueType;
        };
    };
};

/**
 * Simple type for transaction clause.
 */
interface TransactionClause {
    /**
     * Destination address where:
     * * transfer token to or
     * * invoke contract method on.
     *
     * @note Set null destination to deploy a contract.
     */
    to: string | null;

    /**
     * Amount of token to transfer to the destination
     */
    value: string | number;

    /**
     * Input data for contract method invocation or deployment
     */
    data: string;
}

/**
 * Extended type for transaction clause that includes wallet related properties.
 */
interface ExtendedTransactionClause extends TransactionClause {
    /**
     * Optional comment for the clause, helpful for displaying what the clause is doing.
     */
    comment?: string;

    /**
     * Optional ABI for the contract method invocation.
     */
    abi?: string;
}

/**
 * Options for creating a clause.
 */
interface ClauseOptions {
    /**
     * Optional comment for the clause, helpful for displaying what the clause is doing.
     */
    comment?: string;

    /**
     * Optional ABI for the contract method invocation.
     */
    includeABI?: boolean;
}

/**
 * Type for transaction body.
 */
interface TransactionBody {
    /**
     * Last byte of genesis block ID
     */
    chainTag: number;

    /**
     * 8 bytes prefix of some block's ID
     */
    blockRef: string;

    /**
     * Constraint of time bucket
     */
    expiration: number;

    /**
     * Array of clauses
     */
    clauses: TransactionClause[];

    /**
     * Coefficient applied to base gas price [0,255]
     */
    gasPriceCoef: number;

    /**
     * Max gas provided for execution
     */
    gas: string | number;

    /**
     * ID of another tx that is depended
     */
    dependsOn: string | null;

    /**
     * Nonce value for various purposes.
     * Basic is to prevent replay attack by make transaction unique.
     * Every transaction with same chainTag, blockRef, ... must have different nonce.
     */
    nonce: string | number;

    /**
     * A reserved field intended for features use.
     *
     * In standard EVM transactions, this reserved field typically is not present.
     * However, it's been designed to cater to VIP-191, which deals with fee delegation.
     *
     * If the `features` within the `reserved` field is set as `1111...111`, it indicates that the transaction has been delegated.
     * The method to check if the transaction is delegated is:
     *
     * ```typescript
     * reserved.features & 1 === 1
     * ```
     *
     * @example
     *
     * 1.
     * ```typescript
     * feature = 111101;
     * isDelegated = (111101 & 111111) === 111101; // false (not delegated)
     * ```
     *
     * 2.
     * ```typescript
     * feature = 111111;
     * isDelegated = (111111 & 111111) === 111111; // true (delegated)
     * ```
     *
     * @remarks
     * For more information on the subject, refer to {@link https://github.com/vechain/VIPs/blob/master/vips/VIP-191.md | VIP-191}.
     */
    reserved?: {
        /**
         * Tx feature bits
         */
        features?: number;
        /**
         * Unused
         */
        unused?: Buffer[];
    };
}

/**
 * Represents an immutable transaction entity.
 *
 * @remarks
 * Properties should be treated as read-only to avoid unintended side effects.
 * Any modifications create a new transaction instance which should be handled by the TransactionHandler component.
 *
 * @see {@link TransactionHandler} for transaction manipulation details.
 */
declare class Transaction {
    /**
     * Transaction body. It represents the body of the transaction.
     *
     * @note It is better to take it as a read-only property in order to avoid any external modification.
     */
    readonly body: TransactionBody;
    /**
     * Transaction signature. It represents the signature of the transaction.
     *
     * @note It is better to take it as a read-only property in order to avoid any external modification.
     */
    readonly signature?: Buffer;
    /**
     * Constructor with parameters.
     * This constructor creates a transaction immutable object.
     *
     * @throws{TransactionBodyError, InvalidSecp256k1SignatureError}
     * @param body - Transaction body
     * @param signature - Optional signature for the transaction
     */
    constructor(body: TransactionBody, signature?: Buffer);
    /**
     * Calculate intrinsic gas required for this transaction
     *
     * @returns Intrinsic gas required for this transaction
     */
    get intrinsicGas(): number;
    /**
     * Determines whether the transaction is delegated.
     *
     * @returns If transaction is delegated or not
     */
    get isDelegated(): boolean;
    /**
     * Get transaction delegator address from signature.
     *
     * @throws{TransactionDelegationError, TransactionNotSignedError}
     * @returns Transaction delegator address
     */
    get delegator(): string;
    /**
     * Determines whether the transaction is signed or not.
     *
     * @returns If transaction is signed or not
     */
    get isSigned(): boolean;
    /**
     * Computes the signature hash for the transaction. The output is based on
     * the presence of the 'delegateFor' parameter.
     *
     * @param delegateFor - Optional address of the delegator.
     * @returns The computed hash.
     *
     * Mainly:
     *  - No 'delegateFor': return txHash
     * - 'delegateFor' return txHash +  hash('delegateFor' address)
     *
     * @remarks
     * delegateFor is used to sign a transaction on behalf of another account.
     * In fact when the delegator sign the transaction, delegator will add the address
     * of who send the transaction to sign (in this case the 'delegateFor' address parameter)
     *
     * @example
     * A is transaction origin
     * B is the delegator
     * TX is the transaction
     *
     * A sends a TX (signed by A) to B to who add his signature to TX using delegateFor parameter (that is A address)
     * on signing hash of TX computation.
     *
     * Mathematically:
     *
     * ```
     * final_signature = concat_buffer(
     *      sign(TX.signingHash(), A.privateKey),
     *      sign(TX.signingHash(A.address), B.privateKey)
     * )
     * ```
     *
     * Where:
     *
     * ```
     * TX.signatureHash() = blake2b256(TX.encoded)
     * TX.signingHash(A.address) = blake2b256(
     *      concat(
     *              blake2b256(TX.encoded),
     *              A.address
     *             )
     * )
     * ```
     *
     * @throws{InvalidAddressError}
     * @param delegateFor - Address of the delegator
     * @returns Signing hash of the transaction
     */
    getSignatureHash(delegateFor?: string): Buffer;
    /**
     * Encode a transaction
     *
     * @returns The transaction encoded
     */
    get encoded(): Buffer;
    /**
     * Get transaction origin address from signature.
     *
     * @throws{TransactionNotSignedError}
     * @returns Transaction origin
     */
    get origin(): string;
    /**
     * Get transaction ID from signature.
     *
     * @throws{TransactionNotSignedError}
     * @returns Transaction ID
     */
    get id(): string;
    /**
     * Internal function to check if transaction is delegated or not.
     * This function is used to check directly the transaction body.
     * @private
     *
     * @param body Transaction body to check
     * @returns Weather the transaction is delegated or not
     */
    private _isDelegated;
    /**
     * Internal function to check if signature is valid or not.
     * This function is used to check directly the signature.
     * @private
     *
     * @param signature Signature to check
     * @returns Weather the signature is valid or not
     */
    private _isSignatureValid;
    /**
     * Encodes the reserved field to ensure it exists in every encoding.
     *
     * Due to the fact that reserved field is optional in TransactionBody,
     * BUT mandatory in RLPProfiler, we need to have it in every encoding.
     * Fot this reason this function is needed.
     * @private
     *
     * @returns Encoding of reserved field
     */
    private _encodeReservedField;
    /**
     * Make the RLP encoding of a transaction body.
     * @private
     *
     * @param body Body to encode
     * @param isSigned If transaction is signed or not
     * @returns RLP encoding of transaction body
     */
    private _lowLevelEncodeTransactionBodyWithRLP;
    /**
     * Private utility function to encode a transaction.
     * @private
     *
     * @param isSigned If transaction is signed or not (needed to determine if encoding with SIGNED_TRANSACTION_RLP or UNSIGNED_TRANSACTION_RLP)
     * @returns Encoding of transaction
     */
    private _encode;
    /**
     * utility function to check transaction body validity.
     *
     * @param body Transaction body to check
     */
    static isValidBody(body: TransactionBody): boolean;
}

/**
 * Sign a transaction with a given private key
 *
 * @throws{InvalidSecp256k1PrivateKeyError, TransactionAlreadySignedError, TransactionDelegationError}
 * @param transactionBody - The body of the transaction to sign
 * @param signerPrivateKey - Private key used to sign the transaction
 * @returns Signed transaction
 */
declare function sign$1(transactionBody: TransactionBody, signerPrivateKey: Buffer): Transaction;
/**
 * Sign a transaction with signer and delegator private keys
 *
 * @throws{InvalidSecp256k1PrivateKeyError, TransactionAlreadySignedError, TransactionDelegationError}
 * @param transactionBody - The body of the transaction to sign
 * @param signerPrivateKey - Signer private key (the origin)
 * @param delegatorPrivateKey - Delegate private key (the delegator)
 * @returns Signed transaction
 */
declare function signWithDelegator(transactionBody: TransactionBody, signerPrivateKey: Buffer, delegatorPrivateKey: Buffer): Transaction;

/**
 * Decode a raw transaction.
 * It can be signed or unsigned.
 *
 * @param rawTransaction - Raw transaction to decode
 * @param isSigned - If the transaction is signed or not
 * @returns Decoded transaction (signed or unsigned)
 */
declare function decode(rawTransaction: Buffer, isSigned: boolean): Transaction;

/**
 * TransactionHandler provides a set of utility functions for signing and decoding
 * transactions.
 */
declare const TransactionHandler: {
    sign: typeof sign$1;
    signWithDelegator: typeof signWithDelegator;
    decode: typeof decode;
};

/**
 * Constant representing the zero address in hexadecimal format
 */
declare const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
/**
 * VTHO token address (energy.sol smart contract address)
 */
declare const VTHO_ADDRESS = "0x0000000000000000000000000000456e65726779";
/**
 * Parameters smart contract address (params.sol smart contract address)
 */
declare const PARAMS_ADDRESS = "0x0000000000000000000000000000506172616d73";
/**
 * Constant defining VeChain mainnet information
 */
declare const MAINNET_NETWORK: {
    genesisBlock: {
        number: number;
        id: string;
        size: number;
        parentID: string;
        timestamp: number;
        gasLimit: number;
        beneficiary: string;
        gasUsed: number;
        totalScore: number;
        txsRoot: string;
        txsFeatures: number;
        stateRoot: string;
        receiptsRoot: string;
        signer: string;
        isTrunk: boolean;
        transactions: never[];
    };
    chainTag: number;
};
/**
 * Constant defining VeChain testnet information
 */
declare const TESTNET_NETWORK: {
    genesisBlock: {
        number: number;
        id: string;
        size: number;
        parentID: string;
        timestamp: number;
        gasLimit: number;
        beneficiary: string;
        gasUsed: number;
        totalScore: number;
        txsRoot: string;
        txsFeatures: number;
        stateRoot: string;
        receiptsRoot: string;
        signer: string;
        isTrunk: boolean;
        transactions: never[];
    };
    chainTag: number;
};
/**
 * Constant defining VeChain solo network information
 */
declare const SOLO_NETWORK: {
    genesisBlock: {
        number: number;
        id: string;
        size: number;
        parentID: string;
        timestamp: number;
        gasLimit: number;
        beneficiary: string;
        gasUsed: number;
        totalScore: number;
        txsRoot: string;
        txsFeatures: number;
        stateRoot: string;
        receiptsRoot: string;
        signer: string;
        isTrunk: boolean;
        transactions: never[];
    };
    chainTag: number;
};
/**
 * Constant defining VeChain mainnet and testnet network information
 */
declare const networkInfo: {
    mainnet: {
        genesisBlock: {
            number: number;
            id: string;
            size: number;
            parentID: string;
            timestamp: number;
            gasLimit: number;
            beneficiary: string;
            gasUsed: number;
            totalScore: number;
            txsRoot: string;
            txsFeatures: number;
            stateRoot: string;
            receiptsRoot: string;
            signer: string;
            isTrunk: boolean;
            transactions: never[];
        };
        chainTag: number;
    };
    testnet: {
        genesisBlock: {
            number: number;
            id: string;
            size: number;
            parentID: string;
            timestamp: number;
            gasLimit: number;
            beneficiary: string;
            gasUsed: number;
            totalScore: number;
            txsRoot: string;
            txsFeatures: number;
            stateRoot: string;
            receiptsRoot: string;
            signer: string;
            isTrunk: boolean;
            transactions: never[];
        };
        chainTag: number;
    };
    solo: {
        genesisBlock: {
            number: number;
            id: string;
            size: number;
            parentID: string;
            timestamp: number;
            gasLimit: number;
            beneficiary: string;
            gasUsed: number;
            totalScore: number;
            txsRoot: string;
            txsFeatures: number;
            stateRoot: string;
            receiptsRoot: string;
            signer: string;
            isTrunk: boolean;
            transactions: never[];
        };
        chainTag: number;
    };
};

/**
 * Represents the parameters required for deployment.
 * @interface DeployParams
 */
interface DeployParams {
    /**
     * An array of types associated with the deployment parameters.
     * @type {string[] | ParamType[]}
     */
    types: string[] | ParamType[];

    /**
     * An array of values corresponding to the deployment parameters.
     * @type {string[]}
     */
    values: string[];
}

/**
 * Builds a clause for deploying a smart contract.
 *
 * @param contractBytecode - The bytecode of the smart contract to be deployed.
 * @param deployParams - The parameters to pass to the smart contract constructor.
 *
 * @param clauseOptions - Optional settings for the clause.
 * @returns A clause for deploying a smart contract.
 */
declare function deployContract(contractBytecode: string, deployParams?: DeployParams, clauseOptions?: ClauseOptions): TransactionClause | ExtendedTransactionClause;
/**
 * Builds a clause for interacting with a smart contract function.
 *
 * @param contractAddress - The address of the smart contract.
 * @param functionFragment - The function fragment to interact with.
 * @param args - The input data for the function.
 *
 * @param value - The amount of VET to send with the transaction.
 * @param clauseOptions - Optional settings for the clause.
 * @returns A clause for interacting with a smart contract function.
 *
 * @throws Will throw an error if an error occurs while encoding the function input.
 */
declare function functionInteraction(contractAddress: string, functionFragment: FunctionFragment, args: unknown[], value?: number, clauseOptions?: ClauseOptions): TransactionClause | ExtendedTransactionClause;
/**
 * Builds a clause for transferring VIP180 tokens.
 *
 * @param tokenAddress - The address of the VIP180 token.
 * @param recipientAddress - The address of the recipient.
 * @param amount - The amount of tokens to transfer in the decimals of the token.
 *                 For instance, a token with 18 decimals, 1 token would be 1000000000000000000 (i.e., 10 ** 18).
 *
 * @param clauseOptions - Optional settings for the clause.
 * @returns A clause for transferring VIP180 tokens.
 *
 * @throws Will throw an error if the amount is not an integer or if the encoding of the function input fails.
 */
declare function transferToken(tokenAddress: string, recipientAddress: string, amount: number | bigint | string, clauseOptions?: ClauseOptions): TransactionClause | ExtendedTransactionClause;
/**
 * Builds a clause for transferring VET.
 *
 * @param recipientAddress - The address of the recipient.
 * @param amount - The amount of VET to transfer in wei.
 * @param clauseOptions - Optional settings for the clause.
 * @returns A clause for transferring VET.
 *
 * @throws Will throw an error if the amount is not an integer.
 */
declare function transferVET(recipientAddress: string, amount: number | bigint | string, clauseOptions?: ClauseOptions): TransactionClause | ExtendedTransactionClause;
/**
 * Transfers a specified NFT (Non-Fungible Token) from one address to another.
 *
 * This function prepares a transaction clause for transferring an NFT, based on the ERC721 standard,
 * by invoking a smart contract's 'transferFrom' method.
 *
 * @param {string} contractAddress - The address of the NFT contract.
 * @param {string} senderAddress - The address of the current owner (sender) of the NFT.
 * @param {string} recipientAddress - The address of the new owner (recipient) of the NFT.
 * @param {string} tokenId - The unique identifier of the NFT to be transferred.
 * @param clauseOptions - Optional settings for the clause.
 * @returns {TransactionClause} - An object representing the transaction clause required for the transfer.
 *
 * @throws {InvalidDataTypeError, InvalidAbiDataToEncodeError}.
 * */
declare function transferNFT(contractAddress: string, senderAddress: string, recipientAddress: string, tokenId: string, clauseOptions?: ClauseOptions): TransactionClause | ExtendedTransactionClause;
/**
 * clauseBuilder provides methods for building clauses for interacting with smart contracts or deploying smart contracts.
 */
declare const clauseBuilder: {
    deployContract: typeof deployContract;
    functionInteraction: typeof functionInteraction;
    transferToken: typeof transferToken;
    transferVET: typeof transferVET;
    transferNFT: typeof transferNFT;
};

/**
 * Input to hash function.
 */
type HashInput = BytesLike;

type ReturnType = 'buffer' | 'hex';

/**
 * Computes the Blake2bB-256 hash of the given data.
 * If `data` is a string this is normalized using the {@link NORMALIZATION_FORM_CANONICAL_COMPOSITION} encoding.
 *
 * @param {string | Uint8Array} data - The data to compute the hash for. It can be either a string or a Uint8Array.
 *
 * @return {Uint8Array} - The computed hash as a Uint8Array.
 *
 * @throws {InvalidDataReturnTypeError} - If the specified return type is invalid.
 *
 * @remark Use {@link blake2b256OfHex} to hash a string representing an array of bytes in hexadecimal form.
 */
declare function blake2b256(data: string | Uint8Array): Uint8Array;
/**
 * Calculates the Blake2b-256 hash of the given data.
 * If `data` is a string this is normalized using the {@link NORMALIZATION_FORM_CANONICAL_COMPOSITION} encoding.
 *
 * @param {string | Uint8Array} data - The input data to be hashed.
 * @param {string} returnType - The return type of the hash. It can be 'buffer'.
 *
 * @return {Uint8Array} - The Blake2b-256 hash of the given data as a Uint8Array.
 *
 * @throws {InvalidDataReturnTypeError} - If the specified return type is invalid.
 *
 * @remark Use {@link blake2b256OfHex} to hash a string representing an array of bytes in hexadecimal form.
 */
declare function blake2b256(data: string | Uint8Array, returnType: 'buffer'): Uint8Array;
/**
 * Computes the blake2b-256 hash of the input data.
 * If `data` is a string this is normalized using the {@link NORMALIZATION_FORM_CANONICAL_COMPOSITION} encoding.
 *
 * @param {string | Uint8Array} data - The input data to be hashed.
 * @param {string} returnType - The return type of the hash. It can be 'hex'.
 *
 * @return {Uint8Array} The blake2b-256 hash of the input data.
 *
 * @throws {InvalidDataReturnTypeError} - If the specified return type is invalid.
 *
 * @remark Use {@link blake2b256OfHex} to hash a string representing an array of bytes in hexadecimal form.
 */
declare function blake2b256(data: string | Uint8Array, returnType: 'hex'): string;
/**
 *
 * Calculate the Blake2b-256 hash of a hexadecimal string.
 *
 * Secure audit function.
 * * {@link blake2b256OfArray}
 *
 * @param {string} hex - The hexadecimal string to calculate the hash for, optionally prefixed with `0x`.
 * @param {string} returnType - The type of the return value. Must be either "buffer" or "hex", it's "buffer" by default.
 * @returns {string|Uint8Array} - The hash as either a hexadecimal string or Uint8Array, depending on the returnType parameter.
 * @throws {InvalidDataTypeError} - Throws an error if the conversion fails or the returnType is invalid.
 * @throws {InvalidDataReturnTypeError} - If the specified return type is invalid.
 */
declare function blake2b256OfHex(hex: string, returnType?: ReturnType): string | Uint8Array;

/**
 * Calculates the SHA-256 hash of the given data.
 *
 * Secure audit function.
 * * {@link sha256}
 *
 * @param {string | Uint8Array} data - The data to calculate the hash for.
 * @return {Uint8Array} - The SHA-256 hash of the given data.
 */
declare function sha256(data: string | Uint8Array): Uint8Array;
/**
 * Calculates the SHA-256 hash of the given data.
 *
 * @param {string | Uint8Array} data - The data to calculate the SHA-256 hash for.
 * @param {'buffer'} returnType - The return type for the hash. Currently only supports 'buffer'.
 *
 * @return {Uint8Array} - The SHA-256 hash as a Uint8Array.
 */
declare function sha256(data: string | Uint8Array, returnType: 'buffer'): Uint8Array;
/**
 * Calculates the SHA-256 hash of the given data.
 *
 * Secure audit function.
 * * {@link sha256}
 *
 * @param {string | Uint8Array} data - The input data to be hashed.
 * @param {'hex'} returnType - The desired return type of the hash.
 * @return {string} The SHA-256 hash of the data in the specified return type.
 */
declare function sha256(data: string | Uint8Array, returnType: 'hex'): string;

/**
 * Calculates the Keccak-256 hash of the given data.
 *
 * Secure audit function
 * * {@link keccak256}
 *
 * @param {string | Uint8Array} data - The data to hash. It can be either a string or a Uint8Array.
 *
 * @return {Uint8Array} - The Keccak-256 hash of the data.
 */
declare function keccak256(data: string | Uint8Array): Uint8Array;
/**
 * Calculates the Keccak-256 hash of the provided data.
 *
 * Secure audit function.
 * * {@link keccak256}
 *
 * @param {string | Uint8Array} data - The data to hash.
 * @param {'buffer'} returnType - The type of return value. Only 'buffer' is currently supported.
 *
 * @returns {Uint8Array} - The calculated Keccak-256 hash as a Uint8Array.
 */
declare function keccak256(data: string | Uint8Array, returnType: 'buffer'): Uint8Array;
/**
 * Returns the Keccak-256 hash of the given data.
 *
 * Secure audit function.
 * * {@link keccak256}
 *
 * @param {string | Uint8Array} data - The data to hash.
 * @param {'hex'} returnType - The type of the return value. Only 'hex' is supported.
 * @return {string} The hash value in hexadecimal format.
 */
declare function keccak256(data: string | Uint8Array, returnType: 'hex'): string;

/**
 * Creates a [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
 * {@link bip32.HDKey} node
 * from [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) and from it
 * derives a child HDKey node based on the given derivation path.
 *
 * Secure audit function.
 * - [n_bip32](https://github.com/paulmillr/scure-bip32).
 * - [n_bip39](https://github.com/paulmillr/scure-bip39)
 *
 * @param {string[]} words - An array of words representing the mnemonic.
 * @param {string} path - The derivation path to derive the child node.
 * Default value is {@link VET_DERIVATION_PATH}.
 *
 * @return {bip32.HDKey} - An instance of n_bip32.HDKey representing the derived child node.
 *
 * @throws {InvalidHDNodeMnemonicsError} If an error occurs generating the master `n_bip32.HDKey` from `words`.
 * @throws {InvalidHDNodeDerivationPathError} If an error occurs deriving the `n_bip32.HDKey` at `path` from the master HDKey
 */
declare function fromMnemonic(words: string[], path?: string): n_bip32.HDKey;
/**
 * Creates a [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
 * {@link bip32.HDKey} node from a private key and chain code.
 *
 * Secure audit function.
 * - [base58](https://github.com/paulmillr/scure-base)
 * - [n_bip32](https://github.com/paulmillr/scure-bip32).
 *
 * @param {Uint8Array} privateKey The private key.
 * @param {Uint8Array} chainCode The chain code.
 *
 * @returns {bip32.HDKey} The `n_bip32.HDKey` object.
 *
 * @throws {InvalidHDNodePrivateKeyError} If `privateKey` length is not exactly 32 bytes.
 * @throws {InvalidHDNodeChaincodeError} if an error occurs deriving the {@link bip32.HDNode}
 * from the combination of `privateKey` and `chainCode`.
 */
declare function fromPrivateKey(privateKey: Uint8Array, chainCode: Uint8Array): n_bip32.HDKey;
/**
 * Creates a [BIP32 Hierarchical Deterministic Key](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
 * {@link bip32.HDKey} node from a public key and chain code.
 *
 * @param {Uint8Array} publicKey - The public key bytes.
 * @param {Uint8Array} chainCode - The chain code bytes.
 *
 * @returns {bip32.HDKey} - The `n_bip32.HDKey` object.
 *
 * @throws {InvalidHDNodeChaincodeError} If `chainCode` length is not exactly 32 bytes.
 */
declare function fromPublicKey(publicKey: Uint8Array, chainCode: Uint8Array): n_bip32.HDKey;
declare const HDNode: {
    fromMnemonic: typeof fromMnemonic;
    fromPrivateKey: typeof fromPrivateKey;
    fromPublicKey: typeof fromPublicKey;
};

/**
 * @interface Keystore
 * Represents a
 * [Web3 Secret Storage](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage)
 * keystore object that holds information about a private cryptographic key.
 * and its associated wallet address.
 *
 * @property {string} address - The wallet address associated with the stored private key.
 * @property {Object} crypto - The encryption information for the key.
 * @property {string} crypto.cipher - The encryption algorithm used.
 * @property {Object} crypto.cipherparams - Additional parameters for the encryption algorithm.
 * @property {string} crypto.cipherparams.iv - The initialization vector (IV) used for encryption.
 * @property {string} crypto.ciphertext - The encrypted private key.
 * @property {string} crypto.kdf - The key derivation function (KDF) used.
 * @property {Object} crypto.kdfparams - Additional parameters for the KDF.
 * @property {number} crypto.kdfparams.dklen - The derived private key length.
 * @property {number} crypto.kdfparams.n - The CPU/memory cost parameter for the key derivation function.
 * @property {number} crypto.kdfparams.p - The parallelization factor.
 * @property {number} crypto.kdfparams.r - The block size factor.
 * @property {string} crypto.kdfparams.salt - The salt value used in the KDF.
 * @property {string} crypto.mac - The MAC (Message Authentication Code)
 * to match the KDF function with the private key derived by the cyphered text stored.
 * @property {string} id - The
 * [unique identifier version 4](https://en.wikipedia.org/wiki/Universally_unique_identifier)
 * for the key store.
 * @property {number} version - The version number of the key store.
 */
interface Keystore {
    address: string;
    crypto: {
        cipher: string;
        cipherparams: {
            iv: string;
        };
        ciphertext: string;
        kdf: string;
        kdfparams: {
            dklen: number;
            n: number;
            p: number;
            r: number;
            salt: string;
        };
        mac: string;
    };
    id: string;
    version: number;
}

/**
 * Interface representing a keystore account.
 *
 * **WARNING:** call
 * ```javascript
 * privateKey.fill(0)
 * ```
 * after use to avoid to invalidate any security audit and certification granted to this code.
 *
 * @property {string} address - The address associated with the account.
 * @property {Uint8Array} privateKey - The private key associated with the account.
 *
 * @remark **Differently from
 * [ethers KeystoreAccount](https://github.com/ethers-io/ethers.js/blob/main/src.ts/wallet/json-keystore.ts),
 * this type represents the private key as a buffer of bytes to avoid
 * [Memory Dumping](https://github.com/paulmillr/noble-hashes?tab=readme-ov-file#memory-dumping)
 * attack.**
 */
interface KeystoreAccount {
    address: string;
    privateKey: string;
    // @NOTE: Added ONLY for compatibility with ethers KeystoreAccount of ethers.
    mnemonic?: {
        path?: string;
        locale?: string;
        entropy: string;
    };
}

/**
 * Sets the keystore cryptography to experimental mode.
 *
 * @param experimentalCryptography - A boolean indicating whether the keystore cryptography is experimental or not.
 */
declare function useExperimentalCryptography(experimentalCryptography: boolean): void;
/**
 * Encrypts a given private key into a keystore format using the specified password.
 *
 * @param privateKey - The private key to be encrypted.
 * @param password - The password used for the encryption.
 * @returns A Promise that resolves to the encrypted keystore.
 */
declare function encrypt(privateKey: Buffer, password: string): Promise<Keystore>;
/**
 * Decrypts a keystore to obtain the private key using the given password.
 *
 * @throws{InvalidKeystoreError, InvalidKeystorePasswordError}
 * @param keystore - The keystore containing the encrypted private key.
 * @param password - The password used to decrypt the keystore.
 * @returns A Promise that resolves to the decrypted KeystoreAccount or rejects if the keystore or password is invalid.
 */
declare function decrypt(keystore: Keystore, password: string): Promise<KeystoreAccount>;
/**
 * Validates if the provided keystore adheres to the expected format and structure.
 *
 * @param keystore - The keystore to be validated.
 * @returns A boolean indicating whether the keystore is valid or not.
 */
declare function isValid$1(keystore: Keystore): boolean;
/**
 * Exports the keystore functions for encryption, decryption, and validation.
 */
declare const keystore: {
    encrypt: typeof encrypt;
    decrypt: typeof decrypt;
    isValid: typeof isValid$1;
    useExperimentalCryptography: typeof useExperimentalCryptography;
};

/**
 * Type of the wordlist size.
 * Every 4 bytes produce 3 words.
 */
type WordlistSizeType = 12 | 15 | 18 | 21 | 24;

/**
 * Size of the mnemonic words in bytes.
 */
type WordListRandomGeneratorSizeInBytes = 16 | 20 | 24 | 28 | 32;

/**
 * Derives the address from a given list of words of
 * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
 * and a [BIP44 Derivation Path](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)
 * as in the examples.
 *
 * Secure audit function.
 * - {@link bip32.HDKey}(https://github.com/paulmillr/scure-bip32)
 * - {@link HDNode}
 *
 * @example `m/0` (default)
 * @example `m/0/2`
 * @example `m/0/2/4/6`
 *
 * @param {string[]} words - The list of words used to generate the HD node.
 * @param {string} [path='m/0'] - The derivation path from the current node.
 *
 * @return {string} - The derived address, prefixed with `0x` according the
 * [ERC-55: Mixed-case checksum address encoding](https://eips.ethereum.org/EIPS/eip-55).
 *
 * @throws {InvalidHDNodeMnemonicsError} If an error occurs generating the master `bip32.HDKey` from `words`.
 * @throws {InvalidHDNodeDerivationPathError} If an error occurs deriving the `bip32.HDKey` at `path` from the master HDKey
 *
 */
declare function deriveAddress(words: string[], path?: string): string;
/**
 * Derives a private key from a given list of
 * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
 * and a derivation path as in the examples.
 *
 * Secure audit function.
 * - {@link bip32.HDKey}(https://github.com/paulmillr/scure-bip32)
 * - {@link HDNode}
 *
 * @example `m/0` (default)
 * @example `m/0/2`
 * @example `m/0/2/4/6`
 *
 *
 * @param {string[]} words - The set of words used for mnemonic generation.
 * @param {string} [path='m/0'] - The derivation path from the current node.
 * @returns {Uint8Array} - The derived private key as a Uint8Array.
 *
 * @throws {InvalidHDNodeMnemonicsError} If an error occurs generating the master `bip32.HDKey` from `words`.
 * @throws {InvalidHDNodeDerivationPathError} If an error occurs deriving the `bip32.HDKey` at `path` from the master HDKey
 */
declare function derivePrivateKey(words: string[], path?: string): Uint8Array;
/**
 * Generates a
 * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
 * phrase using the specified wordlist size.
 *
 * Secure audit function.
 * - {@link generate}
 *
 * @param {WordlistSizeType} [wordlistSize] - The size of the wordlist used to generate the mnemonic phrase.
 * Valid sizes are 12, 15, 18, 21, 24.
 * @param {function} [randomGenerator] - The random generator function used to generate the entropy.
 * @returns {string[]} - An array of words representing the generated mnemonic phrase.
 * Words are chosen among the [valid English word list](https://github.com/paulmillr/scure-bip39/blob/main/src/wordlists/english.ts).
 */
declare function generate(wordlistSize?: WordlistSizeType, randomGenerator?: (numberOfBytes: WordListRandomGeneratorSizeInBytes) => Uint8Array): string[];
/**
 * Generates a
 * [BIP39 Mnemonic Words](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
 * phrase using the specified wordlist size.
 *
 * Secure audit function.
 * - {@link generate}
 * - `randomGenerator` - **Must provide a cryptographic secure source of entropy
 *    else any secure audit certification related with this software is invalid.**
 *    By default `randomGenerator` is based on secure {@link secp256k1.randomBytes}.
 *
 * @param {WordlistSizeType} [wordlistSize] - The size of the wordlist used to generate the mnemonic phrase.
 * Valid sizes are 12, 15, 18, 21, 24.
 * @returns {string[]} - An array of words representing the generated mnemonic phrase.
 * Words are chosen among the [valid English word list](https://github.com/paulmillr/scure-bip39/blob/main/src/wordlists/english.ts).
 */
declare function generate(wordlistSize?: WordlistSizeType): string[];
/**
 * Check if the given mnemonic words have valid checksum
 *
 * Secure audit function.
 * - [bip39](https://github.com/paulmillr/scure-bip39)
 * - [wordlist](https://github.com/paulmillr/scure-bip39?tab=readme-ov-file#usage) is part of `bip39`.
 *
 * @param words Mnemonic words among [valid English word list](https://github.com/paulmillr/scure-bip39/blob/main/src/wordlists/english.ts)
 * @returns If mnemonic words are valid or not.
 */
declare function isValid(words: string[]): boolean;
declare const mnemonic: {
    deriveAddress: typeof deriveAddress;
    derivePrivateKey: typeof derivePrivateKey;
    generate: typeof generate;
    isValid: typeof isValid;
};

/**
 * Compresses a public key.
 *
 * Security audit function.
 * * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 * * [n_utils](https://github.com/paulmillr/noble-curves?tab=readme-ov-file#utils-useful-utilities)
 *
 * @param {Uint8Array} publicKey - The uncompressed public key.
 *
 * @returns {Uint8Array} - The compressed public key.
 *
 * @see inflatePublicKey
 *
 */
declare function compressPublicKey(publicKey: Uint8Array): Uint8Array;
/**
 * Derives a public key from a given private key.
 *
 * Security audit function.
 * * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 *
 * @param {Uint8Array} privateKey - The private key used to derive the public key.
 * @param {boolean} [isCompressed=true] - Boolean indicating whether the derived public key should be compressed or not.
 * @returns {Uint8Array} - The derived public key as a Uint8Array object.
 *
 * @throws{InvalidSecp256k1PrivateKeyError} if `privateKey` is invalid.
 *
 * @see assertIsValidPrivateKey
 */
declare function derivePublicKey(privateKey: Uint8Array, isCompressed?: boolean): Uint8Array;
/**
 * Generates a new private key.
 *
 * Security audit function.
 * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 *
 * @returns {Uint8Array} The newly generated private key as a buffer.
 */
declare function generatePrivateKey(): Uint8Array;
/**
 * Inflates a compressed or uncompressed public key.
 *
 * Security audit function.
 * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 *
 * @param {Uint8Array} publicKey - The compressed or uncompressed public key to inflate.
 *
 * @return {Uint8Array} - The inflated uncompressed public key.
 *
 * @see compressPublicKey
 */
declare function inflatePublicKey(publicKey: Uint8Array): Uint8Array;
/**
 * Check if the given hash is a valid message hash.
 *
 * Security audit function.
 * * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 * * [n_utils](https://github.com/paulmillr/noble-curves?tab=readme-ov-file#utils-useful-utilities)
 *
 * @param {Uint8Array} hash - The hash of the message to validate.
 * @return {boolean} - Returns `true` if the hash is a valid message hash,
 * otherwise returns `false`.
 */
declare function isValidMessageHash(hash: Uint8Array): boolean;
/**
 * Checks if the given private key is valid.
 *
 * Security audit function.
 * * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 *
 * @param {Uint8Array} privateKey - The private key to be checked.
 * @return {boolean} - Returns `true` if the private key is 32 bytes long
 * in the range between 0 and {@link PRIVATE_KEY_MAX_VALUE} excluded,
 * otherwise `false`.
 */
declare function isValidPrivateKey(privateKey: Uint8Array): boolean;
/**
 * Generates random bytes of specified length.
 *
 * The function relays on [noble-hashes](https://github.com/paulmillr/noble-hashes/blob/main/src/utils.ts)
 * functionality to delegate the OS to generate the random sequence according the host hardware.
 *
 * Security audit function.
 * * [_randomBytes](https://github.com/paulmillr/noble-curves?tab=readme-ov-file#utils-useful-utilities)
 *
 * @param {number} bytesLength - The length of the random bytes to generate.
 * @return {Uint8Array} - The generated random bytes as a Uint8Array object.
 * @throws Error with `crypto.getRandomValues must be defined`
 * message if no hardware for random generation is
 * available at runtime.
 */
declare function randomBytes(bytesLength?: number | undefined): Uint8Array;
/**
 * Recovers public key from a given message hash and signature.
 *
 * Security audit function.
 * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 *
 * @param {Uint8Array} messageHash - The message hash to recover the public key from.
 * @param {Uint8Array} sig - The signature of the message.
 * @returns {Uint8Array} - The recovered public key.
 *
 * @throws{InvalidSecp256k1MessageHashError} - If the message hash is invalid.
 * @throws{InvalidSecp256k1SignatureError} - If the signature is invalid.
 * @throws{InvalidSecp256k1SignatureRecoveryError} - If the signature can't be used to recovery the public key.
 *
 * @see assertIsValidSecp256k1MessageHash
 */
declare function recover(messageHash: Uint8Array, sig: Uint8Array): Uint8Array;
/**
 * Signs a message hash using a private key.
 *
 * Security audit function.
 * * [`ec` for elliptic curve](https://github.com/paulmillr/noble-curves)
 * * [n_utils](https://github.com/paulmillr/noble-curves?tab=readme-ov-file#utils-useful-utilities)
 *
 * @param {Uint8Array} messageHash - The message hash to be signed.
 * @param {Uint8Array} privateKey - The private key to use for signing.
 * @returns {Uint8Array} - The signature of the message hash.
 *
 * @throws {InvalidSecp256k1MessageHashError} - If the message hash is invalid.
 * @throws {InvalidSecp256k1PrivateKeyError} - If the private key is invalid.
 *
 * @see assertIsValidSecp256k1MessageHash
 * @see assertIsValidPrivateKey
 */
declare function sign(messageHash: Uint8Array, privateKey: Uint8Array): Uint8Array;
declare const secp256k1: {
    compressPublicKey: typeof compressPublicKey;
    derivePublicKey: typeof derivePublicKey;
    generatePrivateKey: typeof generatePrivateKey;
    inflatePublicKey: typeof inflatePublicKey;
    isValidMessageHash: typeof isValidMessageHash;
    isValidPrivateKey: typeof isValidPrivateKey;
    recover: typeof recover;
    randomBytes: typeof randomBytes;
    sign: typeof sign;
};

/**
 * Create a Uint8Array filled with zero bytes of the specified size.
 *
 * @param {number} size - The size of the Uint8Array to create.
 * @returns {Uint8Array} - A Uint8Array filled with zero bytes.
 */
declare const ZERO_BYTES: (size: number) => Uint8Array;
/**
 * Regular expression pattern for matching integers expressed as base 10 strings.
 *
 * @type {RegExp}
 * @constant
 */
declare const INTEGER_REGEX: RegExp;
/**
 * Regular expression for matching numeric values expressed as base 10 strings.
 *
 * The regular expression matches the following numeric patterns:
 *    - Whole numbers:
 *      - Positive whole numbers: 1, 2, 3, ...
 *      - Negative whole numbers: -1, -2, -3, ...
 *    - Decimal numbers:
 *      - Positive decimal numbers: 1.0, 2.5, 3.14, ...
 *      - Negative decimal numbers: -1.0, -2.5, -3.14, ...
 *      - Decimal numbers without whole part:
 *        - Positive decimal numbers: .1, .5, .75, ...
 *        - Negative decimal numbers: -.1, -.5, -.75, ...
 *
 * @constant {RegExp} NUMERIC_REGEX
 */
declare const NUMERIC_REGEX: RegExp;

/**
 * Default VET derivation path.
 *
 * See https://github.com/satoshilabs/slips/blob/master/slip-0044.md for more info.
 */
declare const VET_DERIVATION_PATH = "m/44'/818'/0'/0";
/**
 * Prefix for extended public key
 */
declare const X_PUB_PREFIX: Buffer;
/**
 * Prefix for extended private key
 */
declare const X_PRIV_PREFIX: Buffer;

/**
 * Mnemonic wordlist size
 */
declare const MNEMONIC_WORDLIST_ALLOWED_SIZES: WordlistSizeType[];

/**
 * Biggest value of private key
 * @internal
 */
declare const PRIVATE_KEY_MAX_VALUE: Buffer;

/**
 * Transaction gas constants
 */
declare const TRANSACTIONS_GAS_CONSTANTS: {
    /**
     * Default gas for a transaction
     * @internal
     */
    TX_GAS: number;
    /**
     * Default gas for a clause
     * @internal
     */
    CLAUSE_GAS: number;
    /**
     * Default gas for a contract creation clause
     * @internal
     */
    CLAUSE_GAS_CONTRACT_CREATION: number;
    /**
     * Zero gas data
     * @internal
     */
    ZERO_GAS_DATA: number;
    /**
     * Non-zero gas data
     * @internal
     */
    NON_ZERO_GAS_DATA: number;
};
/**
 * Kind for transaction features
 * @internal
 */
declare const TRANSACTION_FEATURES_KIND: {
    name: string;
    kind: NumericKind;
};
/**
 * Kind for transaction signature
 * @internal
 */
declare const TRANSACTION_SIGNATURE_KIND: {
    name: string;
    kind: BufferKind;
};
/**
 * RLP_CODER profiler for simple unsigned transactions
 * @internal
 */
declare const UNSIGNED_TRANSACTION_RLP: {
    readonly profile: RLPProfile;
    encodeObject(data: RLPValidObject): Buffer;
    decodeObject(encodedData: Buffer): RLPValueType;
};
/**
 * RLP_CODER profiler for simple signed transactions
 * @internal
 */
declare const SIGNED_TRANSACTION_RLP: {
    readonly profile: RLPProfile;
    encodeObject(data: RLPValidObject): Buffer;
    decodeObject(encodedData: Buffer): RLPValueType;
};
/**
 * Signature length
 * @internal
 */
declare const SIGNATURE_LENGTH = 65;
/**
 * Block ref field length
 * @internal
 */
declare const BLOCK_REF_LENGTH = 8;

/**
 * ABI of the Params built-in contract.
 *
 * @link see [params.sol](https://docs.vechain.org/developer-resources/built-in-contracts#params-sol)
 */
declare const PARAMS_ABI: string;
/**
 * ABI of the VIP180 token standard.
 *
 * @see [VIP 180](https://github.com/vechain/VIPs/blob/master/vips/VIP-180.md)
 */
declare const VIP180_ABI: readonly [{
    readonly constant: true;
    readonly inputs: readonly [];
    readonly name: "name";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "string";
    }];
    readonly payable: false;
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly constant: false;
    readonly inputs: readonly [{
        readonly name: "_spender";
        readonly type: "address";
    }, {
        readonly name: "_value";
        readonly type: "uint256";
    }];
    readonly name: "approve";
    readonly outputs: readonly [{
        readonly name: "success";
        readonly type: "bool";
    }];
    readonly payable: false;
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly constant: true;
    readonly inputs: readonly [];
    readonly name: "totalSupply";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly payable: false;
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly constant: false;
    readonly inputs: readonly [{
        readonly name: "_from";
        readonly type: "address";
    }, {
        readonly name: "_to";
        readonly type: "address";
    }, {
        readonly name: "_amount";
        readonly type: "uint256";
    }];
    readonly name: "transferFrom";
    readonly outputs: readonly [{
        readonly name: "success";
        readonly type: "bool";
    }];
    readonly payable: false;
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly constant: true;
    readonly inputs: readonly [];
    readonly name: "decimals";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint8";
    }];
    readonly payable: false;
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly constant: true;
    readonly inputs: readonly [{
        readonly name: "_owner";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly name: "balance";
        readonly type: "uint256";
    }];
    readonly payable: false;
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly constant: true;
    readonly inputs: readonly [];
    readonly name: "symbol";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "string";
    }];
    readonly payable: false;
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly constant: false;
    readonly inputs: readonly [{
        readonly name: "_to";
        readonly type: "address";
    }, {
        readonly name: "_amount";
        readonly type: "uint256";
    }];
    readonly name: "transfer";
    readonly outputs: readonly [{
        readonly name: "success";
        readonly type: "bool";
    }];
    readonly payable: false;
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly constant: false;
    readonly inputs: readonly [{
        readonly name: "_from";
        readonly type: "address";
    }, {
        readonly name: "_to";
        readonly type: "address";
    }, {
        readonly name: "_amount";
        readonly type: "uint256";
    }];
    readonly name: "move";
    readonly outputs: readonly [{
        readonly name: "success";
        readonly type: "bool";
    }];
    readonly payable: false;
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly constant: true;
    readonly inputs: readonly [];
    readonly name: "totalBurned";
    readonly outputs: readonly [{
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly payable: false;
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly constant: true;
    readonly inputs: readonly [{
        readonly name: "_owner";
        readonly type: "address";
    }, {
        readonly name: "_spender";
        readonly type: "address";
    }];
    readonly name: "allowance";
    readonly outputs: readonly [{
        readonly name: "remaining";
        readonly type: "uint256";
    }];
    readonly payable: false;
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly name: "_from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly name: "_to";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly name: "_value";
        readonly type: "uint256";
    }];
    readonly name: "Transfer";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly name: "_owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly name: "_spender";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly name: "_value";
        readonly type: "uint256";
    }];
    readonly name: "Approval";
    readonly type: "event";
}];
declare const ERC721_ABI: readonly [{
    readonly inputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "constructor";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }, {
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "ERC721IncorrectOwner";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ERC721InsufficientApproval";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "approver";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidApprover";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidOperator";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidOwner";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "receiver";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidReceiver";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "sender";
        readonly type: "address";
    }];
    readonly name: "ERC721InvalidSender";
    readonly type: "error";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ERC721NonexistentToken";
    readonly type: "error";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "approved";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "Approval";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly indexed: false;
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "ApprovalForAll";
    readonly type: "event";
}, {
    readonly anonymous: false;
    readonly inputs: readonly [{
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly indexed: true;
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "Transfer";
    readonly type: "event";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "approve";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }];
    readonly name: "balanceOf";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "getApproved";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "owner";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }];
    readonly name: "isApprovedForAll";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "receiver";
        readonly type: "address";
    }];
    readonly name: "mintItem";
    readonly outputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "";
        readonly type: "uint256";
    }];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "name";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "ownerOf";
    readonly outputs: readonly [{
        readonly internalType: "address";
        readonly name: "";
        readonly type: "address";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }, {
        readonly internalType: "bytes";
        readonly name: "data";
        readonly type: "bytes";
    }];
    readonly name: "safeTransferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "operator";
        readonly type: "address";
    }, {
        readonly internalType: "bool";
        readonly name: "approved";
        readonly type: "bool";
    }];
    readonly name: "setApprovalForAll";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "bytes4";
        readonly name: "interfaceId";
        readonly type: "bytes4";
    }];
    readonly name: "supportsInterface";
    readonly outputs: readonly [{
        readonly internalType: "bool";
        readonly name: "";
        readonly type: "bool";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [];
    readonly name: "symbol";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "tokenURI";
    readonly outputs: readonly [{
        readonly internalType: "string";
        readonly name: "";
        readonly type: "string";
    }];
    readonly stateMutability: "view";
    readonly type: "function";
}, {
    readonly inputs: readonly [{
        readonly internalType: "address";
        readonly name: "from";
        readonly type: "address";
    }, {
        readonly internalType: "address";
        readonly name: "to";
        readonly type: "address";
    }, {
        readonly internalType: "uint256";
        readonly name: "tokenId";
        readonly type: "uint256";
    }];
    readonly name: "transferFrom";
    readonly outputs: readonly [];
    readonly stateMutability: "nonpayable";
    readonly type: "function";
}];

declare const bloomUtils: {
    BLOOM_DEFAULT_K: number;
    filterOf: (addresses: string[], k?: number) => string;
    isBloom: (filter: string) => boolean;
    isInBloom: (filter: string, k: number, data: string) => boolean;
    isAddressInBloom: (filter: string, k: number, address: string) => boolean;
};

declare const dataUtils: {
    decodeBytes32String: (hex: string) => string;
    encodeBytes32String: (value: string, zeroPadding?: "left" | "right") => string;
    isDecimalString: (data: string) => boolean;
    isNumeric: (value: string) => boolean;
};

/**
 * Checks if derivation path is valid
 *
 * @param derivationPath - Derivation path to check
 * @returns True if derivation path is valid, false otherwise
 */
declare function isDerivationPathValid(derivationPath: string): boolean;

/**
 * Represents a value that can be represented in hexadecimal format.
 *
 * @typedef { bigint | Uint8Array | number | string } HexRepresentable
 */
type HexRepresentable = bigint | Uint8Array | number | string;
/**
 * Helper for encoding hexadecimal values prefixed with '0x'.
 */
declare const Hex0x: {
    /**
     * Converts a given string expression to a canonical representation prefixed with `0x`,
     * optionally specifying the number of bytes to include in the canonical form.
     *
     * @param {string} exp - The string expression to convert to canonical form.
     * @param {number} [bytes] - The number of bytes to include in the canonical form.
     * If not specified, all bytes will be included.
     * @returns {string} The canonical representation of the given string expression.
     * @throws {Error} if `exp` is not a valid hexadecimal expression,
     * if `bytes` is not integer and greater or equal to zero.
     */
    canon: (exp: string, bytes?: number) => string;
    /**
     * Checks if the given expression is a valid Thor-based ID.
     * Thor id is a 64 characters long hexadecimal string.
     * It is used to identify a transaction id, a block id, etc.
     *
     * @param {string} exp - The expression to check.
     * @param {boolean} is0xOptional - Do not check if `exp` is `0x` prefixed, `false` by default.
     * @returns {boolean} - Returns true if the expression is a valid Thor ID, otherwise false.
     */
    isThorId: (exp: string, is0xOptional?: boolean) => boolean;
    /**
     * Checks if the given expression is a valid hexadecimal expression
     * - prefixed with `0x` (or optionally if `is0xOptional is `true`),
     * - byte aligned if  `isByteAligned` is `true`.
     *
     * @param {string} exp - The expression to be validated.
     * @param {boolean} is0xOptional - Do not check if `exp` is `0x` prefixed, `false` by default.
     * @param {boolean} isByteAliged - Check `exp` represents a full byte or an array of bytes, `false`, by default.
     * @returns {boolean} - Whether the expression is valid or not.
     */
    isValid: (exp: string, is0xOptional?: boolean, isByteAliged?: boolean) => boolean;
    /**
     * Returns a hexadecimal representation from the given input data prefixed with `0x`.
     *
     * **Note:** this method calls {@link Hex.of} to generate the hexadecimal representation of n,
     * then it prefixes the result with `0x`.
     *
     * @param {HexRepresentable} n - The input data to be represented.
     * @param {number} [bytes=0] - If not `0` by default, the hexadecimal representation encodes at least {number}  bytes.
     * @returns {Uint8Array} - The resulting hexadecimal representation,
     * it is guaranteed to be even characters long.
     * @see Hex
     * @see HexRepresentable
     */
    of: (n: HexRepresentable, bytes?: number) => string;
};
/**
 * Helper for encoding hexadecimal values.
 */
declare const Hex: {
    /**
     * Converts a given string expression to a canonical representation prefixed with `0x`,
     * optionally specifying the number of bytes to include in the canonical form.
     *
     * @param {string} exp - The string expression to convert to canonical form.
     * @param {number} [bytes] - The number of bytes to include in the canonical form.
     * If not specified, all bytes will be included.
     * @returns {string} The canonical representation of the given string expression.
     * @throws {InvalidDataTypeError} if `exp` is not a valid hexadecimal expression,
     * if `bytes` is not integer and greater or equal to zero.
     */
    canon: (exp: string, bytes?: number) => string;
    /**
     * Returns a hexadecimal representation from the given input data.
     * This method calls
     * * {@link ofBigInt} if `n` type is `bigint`;
     * * {@link ofHexString} if `n` type is {@link HexString}`;
     * * {@link ofNumber} if `n` type is `number`;
     * * {@link ofString} if `n` type is `string`;
     * * {@link ofUint8Array} if `n` is an instance of {@link Uint8Array}.
     *
     * **Note:** the returned string is not prefixed with `0x`,
     * see {@link Hex0x.of} to make a hexadecimal representation prefixed with `0x`.
     *
     * **Note:** [HexString](https://docs.ethers.org/v6/api/utils/#HexString)
     * definition overlaps `string` TS completely as an alias.
     * This function tests if the given input starts with `0x`
     * and is positive to {@link Hex0x.isValid}
     * processing it as {@link HexString} type,
     * else it considers the string as an array of bytes and
     * returns its hexadecimal representation.
     * To force a string to be considered an array of bytes despite it is
     * a valid `0x` hexadecimal expression, convert it to {@link Uint8Array}.
     * ```
     * Hex.of(buffer.toString('hex'))
     * ```
     *
     * @param {HexRepresentable} n - The input data to be represented.
     * @param {number} [bytes=0] - If not `0` by default, the hexadecimal representation encodes at least {number}  bytes.
     * @returns {Uint8Array} - The resulting hexadecimal representation,
     * it is guaranteed to be even characters long.
     * @see HexRepresentable
     */
    of: (n: HexRepresentable, bytes?: number) => string;
    /**
     * Generates a random hexadecimal string of the specified number of bytes.
     * The length of the string is twice the `bytes`.
     *
     * @param {number} bytes - The number of bytes for the random string.
     * @return {string} - The generated random string.
     */
    random: (bytes: number) => string;
};
/**
 * Helper for encoding hexadecimal values as used to represent Ethereum quantities.
 */
declare const Quantity: {
    /**
     *  Returns a hexadecimal representation for the given input data
     *  - without any not meaningful `0` digit on the left side,
     *  - prefixed with `0x`,
     *  - hence returns `0x0` if `n` is zero.
     *
     * This function is a more efficient drop-in replacement of the function
     * `toQuantity` in [math.ts](https://github.com/ethers-io/ethers.js/blob/main/src.ts/utils/maths.ts)
     * of [The Ethers Project](https://github.com/ethers-io/ethers.js/tree/main) library.
     *
     * @param {HexRepresentable} n - The input data to be represented.
     * @return The resulting hexadecimal representation, nibble aligned.
     * @see HexRepresentable
     */
    of(n: HexRepresentable): string;
};

type HexString = string;

/**
 * Calculates intrinsic gas that a tx costs with the given set of clauses.
 *
 * @note see the following link for more details: https://docs.vechain.org/core-concepts/transactions/transaction-calculation
 *
 * @throws{InvalidDataTypeError}
 * @param clauses - Transaction clauses
 * @returns Intrinsic gas of a set of clauses
 */
declare function intrinsicGas(clauses: TransactionClause[]): number;
declare const TransactionUtils: {
    intrinsicGas: typeof intrinsicGas;
};

/**
 * The supported units of Ether currency which are supported by VeChainThor too.
 *
 * wei - The smallest unit of currency. 1 wei is equal to 10^-18 VET.
 * kewi - 1 kewi is equal to 10^3 wei.
 * mwei - 1 mwei is equal to 10^6 wei.
 * gwei - 1 gwei is equal to 10^9 wei.
 * szabo - 1 szabo is equal to 10^12 wei.
 * finney - 1 finney is equal to 10^15 wei.
 * ether - 1 ether is equal to 10^18 wei.
 */
type WEI_UNITS =
    | 'wei'
    | 'kwei'
    | 'mwei'
    | 'gwei'
    | 'szabo'
    | 'finney'
    | 'ether';

/**
 * Formats the given `value` into a decimal string,
 * assuming `decimalsOrUnits` decimal places.
 *
 * The method returns **value / 10^decimalsOrUnit**.
 *
 * @param {bigint | number | string} value - The value to be formatted,
 * it can be a hexadecimal expression prefixed with `0x`.
 * @param {bigint | number | WEI_UNITS} decimalsOrUnit - The number of decimals
 * or the name unit of measurement to use for formatting
 * (e.g. `gwei` for 9 decimal places).
 * Default value is {@link VET_DECIMAL_EXPONENT}.
 *
 * @return {string} - The formatted value as a string,
 * as [ethers.formatUnits](https://docs.ethers.org/v6/api/utils/#formatUnits)
 * it returns at least a fractional digit unless the `digitsOrUnits` is `wei`.
 *
 * @throws {Error} - If an error occurs during the formatting process.
 *
 * @remark This function is a drop-in replacement for
 * [ethers.formatUnits](https://docs.ethers.org/v6/api/utils/#formatUnits).
 *
 */
declare function formatUnits(value: bigint | number | string, decimalsOrUnit?: bigint | number | WEI_UNITS): string;
/**
 * Parses the given `value` and converts it to a BigInt value,
 * assuming `decimalsOrUnits` decimal places.
 *
 * The method returns **value * 10^digitsOrUnit**.
 *
 * @param {bigint | number | string} value - The value to parse and convert,
 * it can be a hexadecimal expression prefixed with `0x`.
 * @param {bigint | number | WEI_UNITS} digitsOrUnit - The number of digits
 * or the name of the unit of measurement to use for the conversion
 * (e.g. `gwei` for 9 decimal places),
 * Default value is VET_DECIMAL_EXPONENT.
 *
 * @returns {bigint} - The parsed value converted to units.
 *
 * @throws {Error} - Throws an error if the value cannot be parsed or converted.
 *
 * @remark This function is a drop-in replacement for
 * [ethers.parseUnits](https://docs.ethers.org/v6/api/utils/#parseUnits).
 */
declare function parseUnits(value: bigint | number | string, digitsOrUnit?: bigint | number | WEI_UNITS): bigint;
declare const unitsUtils: {
    formatUnits: typeof formatUnits;
    formatVET: (value: bigint | number | string) => string;
    parseUnits: typeof parseUnits;
    parseVET: (value: string) => bigint;
};

/**
 * A utility object for revision-related utility operations.
 */
declare const revisionUtils: {
    isRevisionBlock: (revision: string | number) => boolean;
    isRevisionAccount: (revision: string | number) => boolean;
};

/**
 * Assert if address is valid
 *
 * @param methodName - The name of the method calling this assertion.
 * @param address - Address to assert
 */
declare function assertIsAddress(methodName: string, address: string): void;

/**
 * Assert if a given revision is valid.
 * A valid revision is a string representing a block number or block id.
 *
 * @param methodName - The name of the method calling this assertion.
 * @param revision - Revision to assert
 */
declare function assertIsRevisionForBlock(methodName: string, revision?: string | number): void;
/**
 * Assert if a given revision is valid.
 * A valid revision is a string representing a block number or block id.
 *
 * @param methodName - The name of the method calling this assertion.
 * @param revision - Revision to assert
 */
declare function assertIsRevisionForAccount(methodName: string, revision?: string | number): void;

/**
 * Asserts that the return type of hash is valid.
 *
 * @param methodName - The name of the method calling this assertion.
 * @param returnType - The return type of the hash function
 */
declare function assertIsValidReturnType(methodName: string, returnType: ReturnType): void;

/**
 * Assert if private key is valid
 *
 * @param methodName - The name of the method calling this assertion.
 * @param methodName - The name of the method calling this assertion.
 * @param privateKey - Private key to assert
 * @param isValidPrivateKeyFunction - Function to assert private key
 */
declare function assertIsValidPrivateKey(methodName: string, privateKey: Uint8Array, isValidPrivateKeyFunction: (privateKey: Uint8Array) => boolean): void;
/**
 * Assert if message hash is valid
 *
 * @param methodName - The name of the method calling this assertion.
 * @param msgHash - Message hash to assert
 * @param isValidMessageHashFunction - Function to assert message hash
 */
declare function assertIsValidSecp256k1MessageHash(methodName: string, msgHash: Uint8Array, isValidMessageHashFunction: (messageHash: Uint8Array) => boolean): void;

/**
 * Assert if transaction ID is valid
 *
 * @param methodName - The name of the method calling this assertion.
 * @param transactionId - Transaction ID to assert
 */
declare function assertValidTransactionID(methodName: string, transactionId: string): void;
/**
 * Assert if transaction head is valid
 *
 * @param methodName - The name of the method calling this assertion.
 * @param head - Transaction head to assert
 */
declare function assertValidTransactionHead(methodName: string, head?: string): void;
/**
 * Asserts that the given transaction is signed.
 *
 * @param methodName - The name of the method calling this assertion.
 * @param tx - The transaction to check.
 */
declare function assertIsSignedTransaction(methodName: string, tx: Transaction): void;
/**
 * Assert if a private key used to sign a transaction is valid
 *
 * @param methodName - The name of the method calling this assertion.
 * @param privateKey - Private key to assert
 * @param isValidPrivateKeyFunction - Function to assert private key
 * @param role - Role of the private key (e.g., delegator, or signer)
 */
declare function assertIsValidTransactionSigningPrivateKey(methodName: string, privateKey: Buffer, isValidPrivateKeyFunction: (privateKey: Buffer) => boolean, role?: string): void;
/**
 * Assert if transaction is not signed and cannot get field (e.g. delegator, origin, or id)
 *
 * @param methodName - The name of the method calling this assertion.
 * @param transaction - Transaction to assert
 * @param fieldToGet - Field to get (e.g. delegator, origin, or id)
 */
declare function assertCantGetFieldOnUnsignedTransaction(methodName: string, transaction: Transaction, fieldToGet: string): void;

/**
 * Asserts that the data is a buffer.
 *
 * @param methodName - The name of the method calling this assertion.
 * @param bufferToCheck - The bufferToCheck to validate.
 * @param context - Descriptive context for error messages.
 *
 * @throws{InvalidRLPError}
 */
declare function assertIsValidBuffer(methodName: string, bufferToCheck: Buffer | RLPInput, context: string): void;
/**
 * Asserts that the data is an array.
 *
 * @param methodName - The name of the method calling this assertion.
 * @param arrayToCheck - The arrayToCheck to validate.
 * @param context - Descriptive context for error messages.
 *
 * @throws{InvalidRLPError}
 */
declare function assertIsArray<ArrayType>(methodName: string, arrayToCheck: ArrayType, context: string): void;

type core_ArrayKind = ArrayKind;
declare const core_BLOCK_REF_LENGTH: typeof BLOCK_REF_LENGTH;
type core_BufferOutput = BufferOutput;
type core_Certificate = Certificate;
type core_ClauseOptions = ClauseOptions;
type core_DataOutput = DataOutput;
type core_DeployParams = DeployParams;
declare const core_ERC721_ABI: typeof ERC721_ABI;
type core_EventFragment = EventFragment;
type core_ExtendedTransactionClause = ExtendedTransactionClause;
type core_FormatType = FormatType;
type core_FunctionFragment = FunctionFragment;
declare const core_HDNode: typeof HDNode;
type core_HashInput = HashInput;
declare const core_Hex: typeof Hex;
declare const core_Hex0x: typeof Hex0x;
type core_HexString = HexString;
declare const core_INTEGER_REGEX: typeof INTEGER_REGEX;
type core_Interface = Interface;
type core_InterfaceAbi = InterfaceAbi;
type core_Keystore = Keystore;
type core_KeystoreAccount = KeystoreAccount;
type core_Log = Log;
declare const core_MAINNET_NETWORK: typeof MAINNET_NETWORK;
declare const core_MNEMONIC_WORDLIST_ALLOWED_SIZES: typeof MNEMONIC_WORDLIST_ALLOWED_SIZES;
declare const core_NUMERIC_REGEX: typeof NUMERIC_REGEX;
declare const core_PARAMS_ABI: typeof PARAMS_ABI;
declare const core_PARAMS_ADDRESS: typeof PARAMS_ADDRESS;
declare const core_PRIVATE_KEY_MAX_VALUE: typeof PRIVATE_KEY_MAX_VALUE;
type core_ParamType = ParamType;
declare const core_Quantity: typeof Quantity;
declare const core_RLPBase: typeof RLPBase;
type core_RLPInput = RLPInput;
type core_RLPOutput = RLPOutput;
type core_RLPProfile = RLPProfile;
declare const core_RLPProfiles: typeof RLPProfiles;
type core_RLPValidObject = RLPValidObject;
type core_RLPValueType = RLPValueType;
declare const core_RLP_CODER: typeof RLP_CODER;
type core_Result = Result;
type core_ReturnType = ReturnType;
declare const core_SIGNATURE_LENGTH: typeof SIGNATURE_LENGTH;
declare const core_SIGNED_TRANSACTION_RLP: typeof SIGNED_TRANSACTION_RLP;
declare const core_SOLO_NETWORK: typeof SOLO_NETWORK;
type core_ScalarKind = ScalarKind;
declare const core_ScalarKind: typeof ScalarKind;
type core_StructKind = StructKind;
declare const core_TESTNET_NETWORK: typeof TESTNET_NETWORK;
declare const core_TRANSACTIONS_GAS_CONSTANTS: typeof TRANSACTIONS_GAS_CONSTANTS;
declare const core_TRANSACTION_FEATURES_KIND: typeof TRANSACTION_FEATURES_KIND;
declare const core_TRANSACTION_SIGNATURE_KIND: typeof TRANSACTION_SIGNATURE_KIND;
type core_Transaction = Transaction;
declare const core_Transaction: typeof Transaction;
type core_TransactionBody = TransactionBody;
type core_TransactionClause = TransactionClause;
declare const core_TransactionHandler: typeof TransactionHandler;
declare const core_TransactionUtils: typeof TransactionUtils;
declare const core_UNSIGNED_TRANSACTION_RLP: typeof UNSIGNED_TRANSACTION_RLP;
declare const core_VET_DERIVATION_PATH: typeof VET_DERIVATION_PATH;
declare const core_VIP180_ABI: typeof VIP180_ABI;
declare const core_VTHO_ADDRESS: typeof VTHO_ADDRESS;
type core_WEI_UNITS = WEI_UNITS;
type core_WordListRandomGeneratorSizeInBytes = WordListRandomGeneratorSizeInBytes;
type core_WordlistSizeType = WordlistSizeType;
declare const core_X_PRIV_PREFIX: typeof X_PRIV_PREFIX;
declare const core_X_PUB_PREFIX: typeof X_PUB_PREFIX;
declare const core_ZERO_ADDRESS: typeof ZERO_ADDRESS;
declare const core_ZERO_BYTES: typeof ZERO_BYTES;
declare const core_abi: typeof abi;
declare const core_addressUtils: typeof addressUtils;
declare const core_assertCantGetFieldOnUnsignedTransaction: typeof assertCantGetFieldOnUnsignedTransaction;
declare const core_assertCompactFixedHexBlobBuffer: typeof assertCompactFixedHexBlobBuffer;
declare const core_assertFixedHexBlobKindBuffer: typeof assertFixedHexBlobKindBuffer;
declare const core_assertFixedHexBlobKindData: typeof assertFixedHexBlobKindData;
declare const core_assertIsAddress: typeof assertIsAddress;
declare const core_assertIsArray: typeof assertIsArray;
declare const core_assertIsRevisionForAccount: typeof assertIsRevisionForAccount;
declare const core_assertIsRevisionForBlock: typeof assertIsRevisionForBlock;
declare const core_assertIsSignedTransaction: typeof assertIsSignedTransaction;
declare const core_assertIsValidBuffer: typeof assertIsValidBuffer;
declare const core_assertIsValidPrivateKey: typeof assertIsValidPrivateKey;
declare const core_assertIsValidReturnType: typeof assertIsValidReturnType;
declare const core_assertIsValidSecp256k1MessageHash: typeof assertIsValidSecp256k1MessageHash;
declare const core_assertIsValidTransactionSigningPrivateKey: typeof assertIsValidTransactionSigningPrivateKey;
declare const core_assertValidHexBlobKindBuffer: typeof assertValidHexBlobKindBuffer;
declare const core_assertValidHexBlobKindData: typeof assertValidHexBlobKindData;
declare const core_assertValidNumericKindBuffer: typeof assertValidNumericKindBuffer;
declare const core_assertValidTransactionHead: typeof assertValidTransactionHead;
declare const core_assertValidTransactionID: typeof assertValidTransactionID;
declare const core_blake2b256: typeof blake2b256;
declare const core_blake2b256OfHex: typeof blake2b256OfHex;
declare const core_bloom: typeof bloom;
declare const core_bloomUtils: typeof bloomUtils;
declare const core_certificate: typeof certificate;
declare const core_clauseBuilder: typeof clauseBuilder;
declare const core_coder: typeof coder;
declare const core_dataUtils: typeof dataUtils;
declare const core_decodeBufferToHexWithLeadingZeros: typeof decodeBufferToHexWithLeadingZeros;
declare const core_decodeBufferToNumberOrHex: typeof decodeBufferToNumberOrHex;
declare const core_encodeBigIntToBuffer: typeof encodeBigIntToBuffer;
declare const core_encodeCompactFixedHexBlob: typeof encodeCompactFixedHexBlob;
declare const core_fragment: typeof fragment;
declare const core_isDerivationPathValid: typeof isDerivationPathValid;
declare const core_keccak256: typeof keccak256;
declare const core_keystore: typeof keystore;
declare const core_mnemonic: typeof mnemonic;
declare const core_networkInfo: typeof networkInfo;
declare const core_revisionUtils: typeof revisionUtils;
declare const core_secp256k1: typeof secp256k1;
declare const core_sha256: typeof sha256;
declare const core_unitsUtils: typeof unitsUtils;
declare const core_validateNumericKindData: typeof validateNumericKindData;
declare namespace core {
  export { type core_ArrayKind as ArrayKind, core_BLOCK_REF_LENGTH as BLOCK_REF_LENGTH, type core_BufferOutput as BufferOutput, type BytesLike$1 as BytesLike, type core_Certificate as Certificate, type core_ClauseOptions as ClauseOptions, type core_DataOutput as DataOutput, type core_DeployParams as DeployParams, core_ERC721_ABI as ERC721_ABI, type core_EventFragment as EventFragment, type core_ExtendedTransactionClause as ExtendedTransactionClause, type core_FormatType as FormatType, type core_FunctionFragment as FunctionFragment, core_HDNode as HDNode, type core_HashInput as HashInput, core_Hex as Hex, core_Hex0x as Hex0x, type core_HexString as HexString, core_INTEGER_REGEX as INTEGER_REGEX, type core_Interface as Interface, type core_InterfaceAbi as InterfaceAbi, type core_Keystore as Keystore, type core_KeystoreAccount as KeystoreAccount, type core_Log as Log, core_MAINNET_NETWORK as MAINNET_NETWORK, core_MNEMONIC_WORDLIST_ALLOWED_SIZES as MNEMONIC_WORDLIST_ALLOWED_SIZES, core_NUMERIC_REGEX as NUMERIC_REGEX, core_PARAMS_ABI as PARAMS_ABI, core_PARAMS_ADDRESS as PARAMS_ADDRESS, core_PRIVATE_KEY_MAX_VALUE as PRIVATE_KEY_MAX_VALUE, type core_ParamType as ParamType, core_Quantity as Quantity, core_RLPBase as RLPBase, type core_RLPInput as RLPInput, type core_RLPOutput as RLPOutput, type core_RLPProfile as RLPProfile, core_RLPProfiles as RLPProfiles, type core_RLPValidObject as RLPValidObject, type core_RLPValueType as RLPValueType, core_RLP_CODER as RLP_CODER, type core_Result as Result, type core_ReturnType as ReturnType, core_SIGNATURE_LENGTH as SIGNATURE_LENGTH, core_SIGNED_TRANSACTION_RLP as SIGNED_TRANSACTION_RLP, core_SOLO_NETWORK as SOLO_NETWORK, core_ScalarKind as ScalarKind, type core_StructKind as StructKind, core_TESTNET_NETWORK as TESTNET_NETWORK, core_TRANSACTIONS_GAS_CONSTANTS as TRANSACTIONS_GAS_CONSTANTS, core_TRANSACTION_FEATURES_KIND as TRANSACTION_FEATURES_KIND, core_TRANSACTION_SIGNATURE_KIND as TRANSACTION_SIGNATURE_KIND, core_Transaction as Transaction, type core_TransactionBody as TransactionBody, type core_TransactionClause as TransactionClause, core_TransactionHandler as TransactionHandler, core_TransactionUtils as TransactionUtils, core_UNSIGNED_TRANSACTION_RLP as UNSIGNED_TRANSACTION_RLP, core_VET_DERIVATION_PATH as VET_DERIVATION_PATH, core_VIP180_ABI as VIP180_ABI, core_VTHO_ADDRESS as VTHO_ADDRESS, type core_WEI_UNITS as WEI_UNITS, type core_WordListRandomGeneratorSizeInBytes as WordListRandomGeneratorSizeInBytes, type core_WordlistSizeType as WordlistSizeType, core_X_PRIV_PREFIX as X_PRIV_PREFIX, core_X_PUB_PREFIX as X_PUB_PREFIX, core_ZERO_ADDRESS as ZERO_ADDRESS, core_ZERO_BYTES as ZERO_BYTES, core_abi as abi, core_addressUtils as addressUtils, core_assertCantGetFieldOnUnsignedTransaction as assertCantGetFieldOnUnsignedTransaction, core_assertCompactFixedHexBlobBuffer as assertCompactFixedHexBlobBuffer, core_assertFixedHexBlobKindBuffer as assertFixedHexBlobKindBuffer, core_assertFixedHexBlobKindData as assertFixedHexBlobKindData, core_assertIsAddress as assertIsAddress, core_assertIsArray as assertIsArray, core_assertIsRevisionForAccount as assertIsRevisionForAccount, core_assertIsRevisionForBlock as assertIsRevisionForBlock, core_assertIsSignedTransaction as assertIsSignedTransaction, core_assertIsValidBuffer as assertIsValidBuffer, core_assertIsValidPrivateKey as assertIsValidPrivateKey, core_assertIsValidReturnType as assertIsValidReturnType, core_assertIsValidSecp256k1MessageHash as assertIsValidSecp256k1MessageHash, core_assertIsValidTransactionSigningPrivateKey as assertIsValidTransactionSigningPrivateKey, core_assertValidHexBlobKindBuffer as assertValidHexBlobKindBuffer, core_assertValidHexBlobKindData as assertValidHexBlobKindData, core_assertValidNumericKindBuffer as assertValidNumericKindBuffer, core_assertValidTransactionHead as assertValidTransactionHead, core_assertValidTransactionID as assertValidTransactionID, core_blake2b256 as blake2b256, core_blake2b256OfHex as blake2b256OfHex, core_bloom as bloom, core_bloomUtils as bloomUtils, core_certificate as certificate, core_clauseBuilder as clauseBuilder, core_coder as coder, core_dataUtils as dataUtils, core_decodeBufferToHexWithLeadingZeros as decodeBufferToHexWithLeadingZeros, core_decodeBufferToNumberOrHex as decodeBufferToNumberOrHex, core_encodeBigIntToBuffer as encodeBigIntToBuffer, core_encodeCompactFixedHexBlob as encodeCompactFixedHexBlob, core_fragment as fragment, core_isDerivationPathValid as isDerivationPathValid, core_keccak256 as keccak256, core_keystore as keystore, core_mnemonic as mnemonic, core_networkInfo as networkInfo, core_revisionUtils as revisionUtils, core_secp256k1 as secp256k1, core_sha256 as sha256, core_unitsUtils as unitsUtils, core_validateNumericKindData as validateNumericKindData, ethers as vechain_sdk_core_ethers };
}

export { type ArrayKind, BLOCK_REF_LENGTH, type BufferOutput, type BytesLike$1 as BytesLike, type Certificate, type ClauseOptions, type DataOutput, type DeployParams, ERC721_ABI, type EventFragment, type ExtendedTransactionClause, type FormatType, type FunctionFragment, HDNode, type HashInput, Hex, Hex0x, type HexString, INTEGER_REGEX, type Interface, type InterfaceAbi, type Keystore, type KeystoreAccount, type Log, MAINNET_NETWORK, MNEMONIC_WORDLIST_ALLOWED_SIZES, NUMERIC_REGEX, PARAMS_ABI, PARAMS_ADDRESS, PRIVATE_KEY_MAX_VALUE, type ParamType, Quantity, RLPBase, type RLPInput, type RLPOutput, type RLPProfile, RLPProfiles, type RLPValidObject, type RLPValueType, RLP_CODER, type Result, type ReturnType, SIGNATURE_LENGTH, SIGNED_TRANSACTION_RLP, SOLO_NETWORK, ScalarKind, type StructKind, TESTNET_NETWORK, TRANSACTIONS_GAS_CONSTANTS, TRANSACTION_FEATURES_KIND, TRANSACTION_SIGNATURE_KIND, Transaction, type TransactionBody, type TransactionClause, TransactionHandler, TransactionUtils, UNSIGNED_TRANSACTION_RLP, VET_DERIVATION_PATH, VIP180_ABI, VTHO_ADDRESS, type WEI_UNITS, type WordListRandomGeneratorSizeInBytes, type WordlistSizeType, X_PRIV_PREFIX, X_PUB_PREFIX, ZERO_ADDRESS, ZERO_BYTES, abi, addressUtils, assertCantGetFieldOnUnsignedTransaction, assertCompactFixedHexBlobBuffer, assertFixedHexBlobKindBuffer, assertFixedHexBlobKindData, assertIsAddress, assertIsArray, assertIsRevisionForAccount, assertIsRevisionForBlock, assertIsSignedTransaction, assertIsValidBuffer, assertIsValidPrivateKey, assertIsValidReturnType, assertIsValidSecp256k1MessageHash, assertIsValidTransactionSigningPrivateKey, assertValidHexBlobKindBuffer, assertValidHexBlobKindData, assertValidNumericKindBuffer, assertValidTransactionHead, assertValidTransactionID, blake2b256, blake2b256OfHex, bloom, bloomUtils, certificate, clauseBuilder, coder, core, dataUtils, decodeBufferToHexWithLeadingZeros, decodeBufferToNumberOrHex, encodeBigIntToBuffer, encodeCompactFixedHexBlob, fragment, isDerivationPathValid, keccak256, keystore, mnemonic, networkInfo, revisionUtils, secp256k1, sha256, unitsUtils, validateNumericKindData };
