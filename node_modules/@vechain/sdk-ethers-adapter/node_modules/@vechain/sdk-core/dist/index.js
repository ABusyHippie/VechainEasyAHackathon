"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BLOCK_REF_LENGTH: () => BLOCK_REF_LENGTH,
  ERC721_ABI: () => ERC721_ABI,
  HDNode: () => HDNode,
  Hex: () => Hex,
  Hex0x: () => Hex0x,
  INTEGER_REGEX: () => INTEGER_REGEX,
  MAINNET_NETWORK: () => MAINNET_NETWORK,
  MNEMONIC_WORDLIST_ALLOWED_SIZES: () => MNEMONIC_WORDLIST_ALLOWED_SIZES,
  NUMERIC_REGEX: () => NUMERIC_REGEX,
  PARAMS_ABI: () => PARAMS_ABI,
  PARAMS_ADDRESS: () => PARAMS_ADDRESS,
  PRIVATE_KEY_MAX_VALUE: () => PRIVATE_KEY_MAX_VALUE,
  Quantity: () => Quantity,
  RLPBase: () => RLPBase,
  RLPProfiles: () => RLPProfiles,
  RLP_CODER: () => RLP_CODER,
  SIGNATURE_LENGTH: () => SIGNATURE_LENGTH,
  SIGNED_TRANSACTION_RLP: () => SIGNED_TRANSACTION_RLP,
  SOLO_NETWORK: () => SOLO_NETWORK,
  TESTNET_NETWORK: () => TESTNET_NETWORK,
  TRANSACTIONS_GAS_CONSTANTS: () => TRANSACTIONS_GAS_CONSTANTS,
  TRANSACTION_FEATURES_KIND: () => TRANSACTION_FEATURES_KIND,
  TRANSACTION_SIGNATURE_KIND: () => TRANSACTION_SIGNATURE_KIND,
  Transaction: () => Transaction,
  TransactionHandler: () => TransactionHandler,
  TransactionUtils: () => TransactionUtils,
  UNSIGNED_TRANSACTION_RLP: () => UNSIGNED_TRANSACTION_RLP,
  VET_DERIVATION_PATH: () => VET_DERIVATION_PATH,
  VIP180_ABI: () => VIP180_ABI,
  VTHO_ADDRESS: () => VTHO_ADDRESS,
  X_PRIV_PREFIX: () => X_PRIV_PREFIX,
  X_PUB_PREFIX: () => X_PUB_PREFIX,
  ZERO_ADDRESS: () => ZERO_ADDRESS,
  ZERO_BYTES: () => ZERO_BYTES,
  abi: () => abi,
  addressUtils: () => addressUtils,
  assertCantGetFieldOnUnsignedTransaction: () => assertCantGetFieldOnUnsignedTransaction,
  assertCompactFixedHexBlobBuffer: () => assertCompactFixedHexBlobBuffer,
  assertFixedHexBlobKindBuffer: () => assertFixedHexBlobKindBuffer,
  assertFixedHexBlobKindData: () => assertFixedHexBlobKindData,
  assertIsAddress: () => assertIsAddress,
  assertIsArray: () => assertIsArray,
  assertIsRevisionForAccount: () => assertIsRevisionForAccount,
  assertIsRevisionForBlock: () => assertIsRevisionForBlock,
  assertIsSignedTransaction: () => assertIsSignedTransaction,
  assertIsValidBuffer: () => assertIsValidBuffer,
  assertIsValidPrivateKey: () => assertIsValidPrivateKey,
  assertIsValidReturnType: () => assertIsValidReturnType,
  assertIsValidSecp256k1MessageHash: () => assertIsValidSecp256k1MessageHash,
  assertIsValidTransactionSigningPrivateKey: () => assertIsValidTransactionSigningPrivateKey,
  assertValidHexBlobKindBuffer: () => assertValidHexBlobKindBuffer,
  assertValidHexBlobKindData: () => assertValidHexBlobKindData,
  assertValidNumericKindBuffer: () => assertValidNumericKindBuffer,
  assertValidTransactionHead: () => assertValidTransactionHead,
  assertValidTransactionID: () => assertValidTransactionID,
  blake2b256: () => blake2b256,
  blake2b256OfHex: () => blake2b256OfHex,
  bloom: () => bloom,
  bloomUtils: () => bloomUtils,
  certificate: () => certificate,
  clauseBuilder: () => clauseBuilder,
  coder: () => coder,
  core: () => core_exports,
  dataUtils: () => dataUtils,
  decodeBufferToHexWithLeadingZeros: () => decodeBufferToHexWithLeadingZeros,
  decodeBufferToNumberOrHex: () => decodeBufferToNumberOrHex,
  encodeBigIntToBuffer: () => encodeBigIntToBuffer,
  encodeCompactFixedHexBlob: () => encodeCompactFixedHexBlob,
  fragment: () => fragment,
  isDerivationPathValid: () => isDerivationPathValid,
  keccak256: () => keccak256,
  keystore: () => keystore3,
  mnemonic: () => mnemonic,
  networkInfo: () => networkInfo,
  revisionUtils: () => revisionUtils,
  secp256k1: () => secp256k12,
  sha256: () => sha2562,
  unitsUtils: () => unitsUtils,
  validateNumericKindData: () => validateNumericKindData,
  vechain_sdk_core_ethers: () => import_ethers6.ethers
});
module.exports = __toCommonJS(src_exports);

// src/core.ts
var core_exports = {};
__export(core_exports, {
  BLOCK_REF_LENGTH: () => BLOCK_REF_LENGTH,
  ERC721_ABI: () => ERC721_ABI,
  HDNode: () => HDNode,
  Hex: () => Hex,
  Hex0x: () => Hex0x,
  INTEGER_REGEX: () => INTEGER_REGEX,
  MAINNET_NETWORK: () => MAINNET_NETWORK,
  MNEMONIC_WORDLIST_ALLOWED_SIZES: () => MNEMONIC_WORDLIST_ALLOWED_SIZES,
  NUMERIC_REGEX: () => NUMERIC_REGEX,
  PARAMS_ABI: () => PARAMS_ABI,
  PARAMS_ADDRESS: () => PARAMS_ADDRESS,
  PRIVATE_KEY_MAX_VALUE: () => PRIVATE_KEY_MAX_VALUE,
  Quantity: () => Quantity,
  RLPBase: () => RLPBase,
  RLPProfiles: () => RLPProfiles,
  RLP_CODER: () => RLP_CODER,
  SIGNATURE_LENGTH: () => SIGNATURE_LENGTH,
  SIGNED_TRANSACTION_RLP: () => SIGNED_TRANSACTION_RLP,
  SOLO_NETWORK: () => SOLO_NETWORK,
  TESTNET_NETWORK: () => TESTNET_NETWORK,
  TRANSACTIONS_GAS_CONSTANTS: () => TRANSACTIONS_GAS_CONSTANTS,
  TRANSACTION_FEATURES_KIND: () => TRANSACTION_FEATURES_KIND,
  TRANSACTION_SIGNATURE_KIND: () => TRANSACTION_SIGNATURE_KIND,
  Transaction: () => Transaction,
  TransactionHandler: () => TransactionHandler,
  TransactionUtils: () => TransactionUtils,
  UNSIGNED_TRANSACTION_RLP: () => UNSIGNED_TRANSACTION_RLP,
  VET_DERIVATION_PATH: () => VET_DERIVATION_PATH,
  VIP180_ABI: () => VIP180_ABI,
  VTHO_ADDRESS: () => VTHO_ADDRESS,
  X_PRIV_PREFIX: () => X_PRIV_PREFIX,
  X_PUB_PREFIX: () => X_PUB_PREFIX,
  ZERO_ADDRESS: () => ZERO_ADDRESS,
  ZERO_BYTES: () => ZERO_BYTES,
  abi: () => abi,
  addressUtils: () => addressUtils,
  assertCantGetFieldOnUnsignedTransaction: () => assertCantGetFieldOnUnsignedTransaction,
  assertCompactFixedHexBlobBuffer: () => assertCompactFixedHexBlobBuffer,
  assertFixedHexBlobKindBuffer: () => assertFixedHexBlobKindBuffer,
  assertFixedHexBlobKindData: () => assertFixedHexBlobKindData,
  assertIsAddress: () => assertIsAddress,
  assertIsArray: () => assertIsArray,
  assertIsRevisionForAccount: () => assertIsRevisionForAccount,
  assertIsRevisionForBlock: () => assertIsRevisionForBlock,
  assertIsSignedTransaction: () => assertIsSignedTransaction,
  assertIsValidBuffer: () => assertIsValidBuffer,
  assertIsValidPrivateKey: () => assertIsValidPrivateKey,
  assertIsValidReturnType: () => assertIsValidReturnType,
  assertIsValidSecp256k1MessageHash: () => assertIsValidSecp256k1MessageHash,
  assertIsValidTransactionSigningPrivateKey: () => assertIsValidTransactionSigningPrivateKey,
  assertValidHexBlobKindBuffer: () => assertValidHexBlobKindBuffer,
  assertValidHexBlobKindData: () => assertValidHexBlobKindData,
  assertValidNumericKindBuffer: () => assertValidNumericKindBuffer,
  assertValidTransactionHead: () => assertValidTransactionHead,
  assertValidTransactionID: () => assertValidTransactionID,
  blake2b256: () => blake2b256,
  blake2b256OfHex: () => blake2b256OfHex,
  bloom: () => bloom,
  bloomUtils: () => bloomUtils,
  certificate: () => certificate,
  clauseBuilder: () => clauseBuilder,
  coder: () => coder,
  dataUtils: () => dataUtils,
  decodeBufferToHexWithLeadingZeros: () => decodeBufferToHexWithLeadingZeros,
  decodeBufferToNumberOrHex: () => decodeBufferToNumberOrHex,
  encodeBigIntToBuffer: () => encodeBigIntToBuffer,
  encodeCompactFixedHexBlob: () => encodeCompactFixedHexBlob,
  fragment: () => fragment,
  isDerivationPathValid: () => isDerivationPathValid,
  keccak256: () => keccak256,
  keystore: () => keystore3,
  mnemonic: () => mnemonic,
  networkInfo: () => networkInfo,
  revisionUtils: () => revisionUtils,
  secp256k1: () => secp256k12,
  sha256: () => sha2562,
  unitsUtils: () => unitsUtils,
  validateNumericKindData: () => validateNumericKindData,
  vechain_sdk_core_ethers: () => import_ethers6.ethers
});
var import_ethers6 = require("ethers");

// src/abi/fragment.ts
var import_ethers = require("ethers");
var import_sdk_errors = require("@vechain/sdk-errors");

// src/abi/helpers/fragment.ts
var sanitizeValuesToEncode = (valuesToEncode, event) => {
  if (valuesToEncode.length === 0) return [];
  if (valuesToEncode.length > event.inputs.length) return valuesToEncode;
  const sanitizedValuesToEncode = [];
  const eventInputs = event.inputs;
  for (const input of eventInputs) {
    input.indexed === true ? sanitizedValuesToEncode.push(valuesToEncode.shift()) : sanitizedValuesToEncode.push(null);
  }
  return sanitizedValuesToEncode;
};

// src/abi/fragment.ts
var allowedSignatureFormats = ["sighash", "minimal", "full", "json"];
function getSignature(fragment2, formatType) {
  (0, import_sdk_errors.assert)(
    "getSignature",
    allowedSignatureFormats.includes(formatType),
    import_sdk_errors.ABI.INVALID_FORMAT_TYPE,
    `Signature format error: '${formatType}' is invalid. Allowed formats: ${allowedSignatureFormats.join(
      ", "
    )}`,
    { formatType }
  );
  return fragment2.format(formatType);
}
var Function = class {
  /**
   * The main fragment handled by ethers.js.
   *
   */
  fragment;
  /**
   * The main interface handled by ethers.js.
   */
  iface;
  /**
   * Creates a new Function instance from an ABI fragment.
   *
   * @throws{InvalidAbiFunctionError}
   * @param source - ABI fragment to use.
   */
  constructor(source) {
    try {
      this.fragment = import_ethers.ethers.FunctionFragment.from(source);
      this.iface = new import_ethers.ethers.Interface([this.fragment]);
    } catch (e) {
      throw (0, import_sdk_errors.buildError)(
        "Function constructor",
        import_sdk_errors.ABI.INVALID_FUNCTION,
        "Initialization failed: Cannot create Function fragment. Function format is invalid.",
        { source },
        e
      );
    }
  }
  /**
   * Get the signature hash of the function.
   *
   * @returns The signature hash of the function.
   */
  signatureHash() {
    return this.fragment.selector;
  }
  /**
   * Get the signature of the function.
   *
   * @param formatType - The format type of the signature: 'sighash', 'minimal', 'full', or 'json'.
   * @returns The signature of the function.
   */
  signature(formatType) {
    return getSignature(this.fragment, formatType);
  }
  /**
   * Decode data using the function's ABI.
   *
   * @throws{InvalidAbiDataToDecodeError} - If the data cannot be decoded.
   * @param data - Data to decode.
   * @returns Decoding results.
   */
  decodeInput(data) {
    try {
      return this.iface.decodeFunctionData(this.fragment, data);
    } catch (e) {
      throw (0, import_sdk_errors.buildError)(
        "decodeInput",
        import_sdk_errors.ABI.INVALID_DATA_TO_DECODE,
        "Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",
        { data },
        e
      );
    }
  }
  /**
   * Decodes the output data from a transaction based on ABI (Application Binary Interface) specifications.
   * This method attempts to decode the given byte-like data into a readable format using the contract's interface.
   *
   * @param data - The `BytesLike` data to be decoded, typically representing the output of a contract function call.
   * @returns A `Result` object containing the decoded data.
   *
   * @throws{InvalidAbiDataToDecodeError} - If the data cannot be decoded.
   *
   * @example
   * ```typescript
   *   const decoded = contractInstance.decodeOutput(rawTransactionOutput);
   *   console.log('Decoded Output:', decoded);
   * ```
   */
  decodeOutput(data) {
    try {
      return this.iface.decodeFunctionResult(this.fragment, data);
    } catch (e) {
      throw (0, import_sdk_errors.buildError)(
        "decodeOutput",
        import_sdk_errors.ABI.INVALID_DATA_TO_DECODE,
        "Decoding failed: Data must be a valid hex string encoding a compliant ABI type.",
        { data },
        e
      );
    }
  }
  /**
   * Encode data using the function's ABI.
   *
   * @throws{InvalidAbiDataToEncodeError}
   * @param dataToEncode - Data to encode.
   * @returns Encoded data.
   */
  encodeInput(dataToEncode) {
    try {
      return this.iface.encodeFunctionData(this.fragment, dataToEncode);
    } catch (e) {
      throw (0, import_sdk_errors.buildError)(
        "encodeInput",
        import_sdk_errors.ABI.INVALID_DATA_TO_ENCODE,
        "Encoding failed: Data format is invalid. Function data does not match the expected format for ABI type encoding.",
        { dataToEncode },
        e
      );
    }
  }
};
var Event = class {
  /**
   * The main fragment handled by ethers.js.
   */
  fragment;
  /**
   * The main interface handled by ethers.js.
   */
  iface;
  /**
   * Creates a new Event instance from an ABI fragment.
   *
   * @throws{InvalidAbiEventError}
   * @param source - ABI fragment to use.
   */
  constructor(source) {
    try {
      this.fragment = import_ethers.ethers.EventFragment.from(source);
      this.iface = new import_ethers.ethers.Interface([this.fragment]);
    } catch (e) {
      throw (0, import_sdk_errors.buildError)(
        "Event constructor",
        import_sdk_errors.ABI.INVALID_EVENT,
        "Initialization failed: Event fragment creation is not possible due to invalid ABI data format.",
        { source },
        e
      );
    }
  }
  /**
   * Get the signature hash of the event.
   *
   * @returns The signature hash of the event.
   */
  signatureHash() {
    return this.fragment.topicHash;
  }
  /**
   * Get the signature of the event.
   *
   * @param formatType - The format type of the signature: 'sighash', 'minimal', 'full', or 'json'.
   * @returns The signature of the event.
   */
  signature(formatType) {
    return getSignature(this.fragment, formatType);
  }
  /**
   * Decode event log data using the event's ABI.
   *
   * @throws{InvalidAbiDataToDecodeError}
   * @param data - Data to decode.
   * @returns Decoding results.
   */
  decodeEventLog(data) {
    try {
      return this.iface.decodeEventLog(
        this.fragment,
        data.data,
        data.topics
      );
    } catch (e) {
      throw (0, import_sdk_errors.buildError)(
        "decodeEventLog",
        import_sdk_errors.ABI.INVALID_DATA_TO_DECODE,
        "Decoding failed: Data and topics must be correctly formatted for ABI-compliant decoding.",
        { data },
        e
      );
    }
  }
  /**
   * Encode event log data using the event's ABI.
   *
   * @throws{InvalidAbiDataToEncodeError}
   * @param dataToEncode - Data to encode.
   * @returns Encoded data along with topics.
   */
  encodeEventLog(dataToEncode) {
    try {
      return this.iface.encodeEventLog(this.fragment, dataToEncode);
    } catch (e) {
      throw (0, import_sdk_errors.buildError)(
        "encodeEventLog",
        import_sdk_errors.ABI.INVALID_DATA_TO_ENCODE,
        "Encoding failed: Event data must be correctly formatted for ABI-compliant encoding.",
        { dataToEncode },
        e
      );
    }
  }
  /**
   * Encode event log topics using the event's ABI.
   *
   * @param valuesToEncode - values to encode as topics. Non-indexed values are ignored.
   *                         Only the values of the indexed parameters are needed.
   *
   * @returns Encoded topics array.
   */
  encodeFilterTopics(valuesToEncode) {
    try {
      const sanitizedValuesToEncode = sanitizeValuesToEncode(
        valuesToEncode,
        this.fragment
      );
      return this.iface.encodeFilterTopics(this.fragment, sanitizedValuesToEncode).map((topic) => topic ?? void 0);
    } catch (e) {
      throw (0, import_sdk_errors.buildError)(
        "encodeFilterTopics",
        import_sdk_errors.ABI.INVALID_DATA_TO_ENCODE,
        "Encoding topics failed: Event topics values must be correctly formatted for ABI-compliant encoding.",
        { valuesToEncode },
        e
      );
    }
  }
};
var fragment = {
  Function,
  Event
};

// src/abi/coder.ts
var import_ethers2 = require("ethers");
var import_sdk_errors2 = require("@vechain/sdk-errors");
var ethersCoder = new import_ethers2.ethers.AbiCoder();
function encode(type, value) {
  try {
    return ethersCoder.encode([type], [value]);
  } catch {
    throw (0, import_sdk_errors2.buildError)(
      "encode",
      import_sdk_errors2.ABI.INVALID_DATA_TO_ENCODE,
      "Encoding failed: Data must be a valid ABI type with corresponding valid data."
    );
  }
}
function encodeParams(types, values) {
  try {
    return ethersCoder.encode(types, values);
  } catch {
    throw (0, import_sdk_errors2.buildError)(
      "encodeParams",
      import_sdk_errors2.ABI.INVALID_DATA_TO_ENCODE,
      "Encoding failed: Data must be a valid ABI type with corresponding valid data."
    );
  }
}
function decode(types, data) {
  try {
    const decoded = ethersCoder.decode([types], data).toArray();
    return decoded[0];
  } catch {
    throw (0, import_sdk_errors2.buildError)(
      "decode",
      import_sdk_errors2.ABI.INVALID_DATA_TO_DECODE,
      "Decoding failed: Data must be a valid hex string that encodes a valid ABI type."
    );
  }
}
var abi = {
  ...fragment,
  encode,
  encodeParams,
  decode
};

// src/contract/coder.ts
var import_ethers3 = require("ethers");
var import_sdk_errors3 = require("@vechain/sdk-errors");
function createInterface(abi2) {
  return new import_ethers3.Interface(abi2);
}
function encodeFunctionInput(interfaceABI, functionName, functionData) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Function(
      contractInterface.getFunction(functionName)
    ).encodeInput(functionData);
  } catch (e) {
    throw (0, import_sdk_errors3.buildError)(
      "coder.encodeFunctionInput",
      import_sdk_errors3.ERROR_CODES.ABI.INVALID_DATA_TO_ENCODE,
      `Method 'encodeFunctionInput' failed while encoding input for function '${functionName}'. Input must match ABI specifications and be correctly formatted.
Parameters: ${(0, import_sdk_errors3.stringifyData)(functionData)}.
Ethers' error message: ${e.message}.`,
      { functionName, functionData },
      e
    );
  }
}
function decodeFunctionInput(interfaceABI, functionName, encodedFunctionInput) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Function(
      contractInterface.getFunction(functionName)
    ).decodeInput(encodedFunctionInput);
  } catch (e) {
    throw (0, import_sdk_errors3.buildError)(
      "coder.decodeFunctionInput",
      import_sdk_errors3.ERROR_CODES.ABI.INVALID_DATA_TO_DECODE,
      "Decoding failed: Function input must be properly encoded per ABI specifications.",
      { functionName },
      e
    );
  }
}
function decodeFunctionOutput(interfaceABI, functionName, encodedFunctionOutput) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Function(
      contractInterface.getFunction(functionName)
    ).decodeOutput(encodedFunctionOutput);
  } catch (e) {
    throw (0, import_sdk_errors3.buildError)(
      "coder.decodeFunctionOutput",
      import_sdk_errors3.ERROR_CODES.ABI.INVALID_DATA_TO_DECODE,
      "Decoding failed: Function output must be properly encoded per ABI specifications.",
      { functionName },
      e
    );
  }
}
function encodeEventLog(interfaceABI, eventName, dataToEncode) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Event(
      contractInterface.getEvent(eventName)
    ).encodeEventLog(dataToEncode);
  } catch (e) {
    throw (0, import_sdk_errors3.buildError)(
      "coder.encodeEventLog",
      import_sdk_errors3.ERROR_CODES.ABI.INVALID_EVENT,
      "Encoding failed: Event log data must align with ABI specifications for encoding.",
      { eventName },
      e
    );
  }
}
function decodeEventLog(interfaceABI, eventName, dataToDecode) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return new abi.Event(
      contractInterface.getEvent(eventName)
    ).decodeEventLog(dataToDecode);
  } catch (e) {
    throw (0, import_sdk_errors3.buildError)(
      "coder.decodeEventLog",
      import_sdk_errors3.ERROR_CODES.ABI.INVALID_EVENT,
      "Decoding failed: Event log data must be correctly encoded per ABI specifications.",
      { eventName },
      e
    );
  }
}
function parseLog(interfaceABI, data, topics) {
  try {
    const contractInterface = createInterface(interfaceABI);
    return contractInterface.parseLog({ topics, data });
  } catch (e) {
    throw (0, import_sdk_errors3.buildError)(
      "coder.parseLog",
      import_sdk_errors3.ABI.INVALID_DATA_TO_DECODE,
      "Decoding failed: Data and topics must be correctly formatted for ABI-compliant decoding.",
      { data },
      e
    );
  }
}
var coder = {
  createInterface,
  encodeFunctionInput,
  decodeFunctionInput,
  decodeFunctionOutput,
  encodeEventLog,
  decodeEventLog,
  parseLog
};

// src/address/address.ts
var import_sdk_errors24 = require("@vechain/sdk-errors");

// src/utils/const/data.ts
var ZERO_BYTES = (size) => new Uint8Array(size);
var INTEGER_REGEX = /^\d+$/;
var NUMERIC_REGEX = /(^-?\d+(\.\d+)?)$|(^-?\.\d+)$/;

// src/utils/const/hdnode.ts
var VET_DERIVATION_PATH = "m/44'/818'/0'/0";
var X_PUB_PREFIX = Buffer.from("0488b21e000000000000000000", "hex");
var X_PRIV_PREFIX = Buffer.from("0488ade4000000000000000000", "hex");

// src/utils/const/mnemonic.ts
var MNEMONIC_WORDLIST_ALLOWED_SIZES = [
  12,
  15,
  18,
  21,
  24
];

// src/utils/const/secp256k1.ts
var PRIVATE_KEY_MAX_VALUE = Buffer.from(
  "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141",
  "hex"
);

// src/encoding/rlp/rlp.ts
var import_rlp = require("@ethereumjs/rlp");
var import_sdk_errors10 = require("@vechain/sdk-errors");

// src/assertions/account/account.ts
var import_sdk_errors4 = require("@vechain/sdk-errors");
function assertIsAddress(methodName, address) {
  (0, import_sdk_errors4.assert)(
    `assertIsAddress - ${methodName}`,
    addressUtils.isAddress(address),
    import_sdk_errors4.DATA.INVALID_DATA_TYPE,
    "Invalid address. The address must be 20 bytes (a 42 characters hex string with a `0x` prefix.)",
    { address }
  );
}

// src/assertions/block/block.ts
var import_sdk_errors5 = require("@vechain/sdk-errors");
function assertIsRevisionForBlock(methodName, revision) {
  (0, import_sdk_errors5.assert)(
    `assertIsRevisionForBlock - ${methodName}`,
    revision === void 0 || revision === null || revisionUtils.isRevisionBlock(revision),
    import_sdk_errors5.DATA.INVALID_DATA_TYPE,
    'Invalid revision. The revision must be a string representing a block number or block id (also "best" is accepted which represents the best block & "finalized" for the finalized block).',
    { revision }
  );
}
function assertIsRevisionForAccount(methodName, revision) {
  (0, import_sdk_errors5.assert)(
    `assertIsRevisionForAccount - ${methodName}`,
    revision === void 0 || revision === null || revisionUtils.isRevisionAccount(revision),
    import_sdk_errors5.DATA.INVALID_DATA_TYPE,
    'Invalid revision. The revision must be a string representing a block number or block id (also "best" is accepted which represents the best block).',
    { revision }
  );
}

// src/assertions/hash/hash.ts
var import_sdk_errors6 = require("@vechain/sdk-errors");
var isValidReturnType = (value) => {
  return !(value !== "buffer" && value !== "hex");
};
function assertIsValidReturnType(methodName, returnType) {
  (0, import_sdk_errors6.assert)(
    `assertIsValidReturnType - ${methodName}`,
    isValidReturnType(returnType),
    import_sdk_errors6.DATA.INVALID_DATA_RETURN_TYPE,
    "Validation error: Invalid return type. Return type in hash function must be 'buffer' or 'hex'.",
    { returnType }
  );
}

// src/assertions/keystore/keystore.ts
var import_sdk_errors7 = require("@vechain/sdk-errors");
function assertIsValidPrivateKey(methodName, privateKey, isValidPrivateKeyFunction) {
  (0, import_sdk_errors7.assert)(
    `assertIsValidPrivateKey - ${methodName}`,
    isValidPrivateKeyFunction(privateKey),
    import_sdk_errors7.SECP256K1.INVALID_SECP256k1_PRIVATE_KEY,
    "Invalid private key given as input. Ensure it is a valid 32-byte secp256k1 private key."
  );
}
function assertIsValidSecp256k1MessageHash(methodName, msgHash, isValidMessageHashFunction) {
  (0, import_sdk_errors7.assert)(
    `assertIsValidSecp256k1MessageHash - ${methodName}`,
    isValidMessageHashFunction(msgHash),
    import_sdk_errors7.SECP256K1.INVALID_SECP256k1_MESSAGE_HASH,
    "Invalid private key given as input. Ensure it is a valid 32-byte secp256k1 private key.",
    { msgHash }
  );
}

// src/assertions/transaction/transaction.ts
var import_sdk_errors8 = require("@vechain/sdk-errors");
function assertValidTransactionID(methodName, transactionId) {
  (0, import_sdk_errors8.assert)(
    `assertValidTransactionID - ${methodName}`,
    Hex0x.isThorId(transactionId),
    import_sdk_errors8.DATA.INVALID_DATA_TYPE,
    "Invalid transaction ID given as input. Input must be an hex string of length 64.",
    { transactionId }
  );
}
function assertValidTransactionHead(methodName, head) {
  (0, import_sdk_errors8.assert)(
    `assertValidTransactionHead - ${methodName}`,
    head === void 0 || Hex0x.isThorId(head),
    import_sdk_errors8.DATA.INVALID_DATA_TYPE,
    "Invalid head given as input. Input must be an hex string of length 64.",
    { head }
  );
}
function assertIsSignedTransaction(methodName, tx) {
  (0, import_sdk_errors8.assert)(
    `assertIsSignedTransaction - ${methodName}`,
    tx.isSigned,
    import_sdk_errors8.TRANSACTION.NOT_SIGNED,
    "Transaction must be signed.",
    {
      tx
    }
  );
}
function assertIsValidTransactionSigningPrivateKey(methodName, privateKey, isValidPrivateKeyFunction, role) {
  (0, import_sdk_errors8.assert)(
    `assertIsValidTransactionSigningPrivateKey - ${methodName}`,
    isValidPrivateKeyFunction(privateKey),
    import_sdk_errors8.SECP256K1.INVALID_SECP256k1_PRIVATE_KEY,
    `Invalid ${role} private key used to sign the transaction. Ensure it's a valid secp256k1 private key.`
  );
}
function assertCantGetFieldOnUnsignedTransaction(methodName, transaction, fieldToGet) {
  (0, import_sdk_errors8.assert)(
    `assertCantGetFieldOnUnsignedTransaction - ${methodName}`,
    transaction.isSigned,
    import_sdk_errors8.TRANSACTION.NOT_SIGNED,
    `Cannot get ${fieldToGet} from unsigned transaction. Sign the transaction first.`
  );
}

// src/assertions/rlp/rlp.ts
var import_sdk_errors9 = require("@vechain/sdk-errors");
function assertIsValidBuffer(methodName, bufferToCheck, context) {
  (0, import_sdk_errors9.assert)(
    `assertIsValidBuffer - ${methodName}`,
    Buffer.isBuffer(bufferToCheck),
    import_sdk_errors9.RLP_ERRORS.INVALID_RLP,
    `Validation error: Expected a Buffer type in ${context}.`,
    {
      bufferToCheck,
      context
    }
  );
}
function assertIsArray(methodName, arrayToCheck, context) {
  (0, import_sdk_errors9.assert)(
    `assertIsArray - ${methodName}`,
    Array.isArray(arrayToCheck),
    import_sdk_errors9.RLP_ERRORS.INVALID_RLP,
    `Validation error: Expected an array in ${context}.`,
    {
      context
    }
  );
}

// src/encoding/rlp/rlp.ts
function encode2(data) {
  const encodedData = import_rlp.RLP.encode(data);
  return Buffer.from(encodedData);
}
function decode2(encodedData) {
  return import_rlp.RLP.decode(encodedData);
}
var Profiler = class {
  /**
   * Creates a new Profiler instance.
   * @param profile - RLP_CODER profile for encoding/decoding structures.
   */
  constructor(profile) {
    this.profile = profile;
  }
  /**
   * Encodes an object following the provided RLP_CODER profile.
   * @param data - Object to be encoded.
   * @returns - Encoded data as a Buffer.
   */
  encodeObject(data) {
    const packedData = _packData(data, this.profile, "");
    return Buffer.from(import_rlp.RLP.encode(packedData));
  }
  /**
   * Decodes an object following the provided RLP_CODER profile.
   * @param encodedData - Data to be decoded.
   * @returns - Decoded data as RLPValueType.
   */
  decodeObject(encodedData) {
    const packedData = import_rlp.RLP.decode(encodedData);
    return _unpackData(packedData, this.profile, "");
  }
};
var _packData = (obj, profile, context) => {
  context = context !== "" ? context + "." + profile.name : profile.name;
  const kind = profile.kind;
  if (kind instanceof RLPProfiles.ScalarKind) {
    return kind.data(obj, context).encode();
  }
  if (Array.isArray(kind)) {
    return kind.map(
      (k) => _packData(obj[k.name], k, context)
    );
  }
  assertIsArray("packData", obj, context);
  if ("item" in kind && Array.isArray(obj)) {
    const item = kind.item;
    return obj.map(
      (part, i) => _packData(
        part,
        { name: "#" + i, kind: item },
        context
      )
    );
  }
};
var _unpackData = (packed, profile, context) => {
  context = context !== "" ? context + "." + profile.name : profile.name;
  const kind = profile.kind;
  if (kind instanceof RLPProfiles.ScalarKind) {
    (0, import_sdk_errors10.assert)(
      "_unpackData",
      Buffer.isBuffer(packed) || packed instanceof Uint8Array,
      import_sdk_errors10.RLP_ERRORS.INVALID_RLP,
      "Unpacking error: Expected data type is Buffer.",
      { context }
    );
    if (packed instanceof Uint8Array) packed = Buffer.from(packed);
    return kind.buffer(packed, context).decode();
  }
  if (Array.isArray(kind) && Array.isArray(packed)) {
    const parts = packed;
    (0, import_sdk_errors10.assert)(
      "_unpackData",
      parts.length === kind.length,
      import_sdk_errors10.RLP_ERRORS.INVALID_RLP,
      `Unpacking error: Expected ${kind.length} items, but got ${parts.length}.`,
      { context }
    );
    return kind.reduce(
      (obj, profile2, index) => {
        obj[profile2.name] = _unpackData(parts[index], profile2, context);
        return obj;
      },
      {}
    );
  }
  assertIsArray("_unpackData", packed, context);
  if ("item" in kind && Array.isArray(packed)) {
    const item = kind.item;
    return packed.map(
      (part, index) => _unpackData(part, { name: "#" + index, kind: item }, context)
    );
  }
};
var RLPBase = { encode: encode2, decode: decode2, Profiler };

// src/encoding/rlp/kind/scalarkind.abstract.ts
var ScalarKind = class {
};

// src/encoding/rlp/kind/bufferkind.ts
var BufferKind = class extends ScalarKind {
  /**
   * Encodes the input data into buffer format.
   *
   * @throws{InvalidRLPError}
   * @param data - The data to encode, expected to be of buffer type.
   * @param context - Descriptive context for error messages
   * @returns DataOutput object with an encode function.
   */
  data(data, context) {
    assertIsValidBuffer("data", data, context);
    return {
      encode: () => data
      // Data is already a Buffer, so return as-is.
    };
  }
  /**
   * Decodes the input buffer.
   *
   * @throws{InvalidRLPError}
   * @param buffer - The buffer to decode, expected to be of buffer type.
   * @param context - Descriptive context for error messages, usually representing the caller's identity.
   * @returns BufferOutput object with a decode function.
   */
  buffer(buffer, context) {
    assertIsValidBuffer("buffer", buffer, context);
    return {
      decode: () => buffer
      // Buffer is already in the correct format, so return as-is.
    };
  }
};

// src/encoding/rlp/helpers/numerickind.ts
var import_sdk_errors11 = require("@vechain/sdk-errors");
var validateNumericKindData = (data, context) => {
  (0, import_sdk_errors11.assert)(
    "validateNumericKindData",
    typeof data === "number" || typeof data === "string",
    import_sdk_errors11.RLP_ERRORS.INVALID_RLP,
    `Validation error: Input in ${context} must be a string or number.`,
    { data, context }
  );
  if (typeof data === "number") {
    _validateNumericKindNumber(data, context);
  } else if (typeof data === "string") {
    _validateNumericKindString(data, context);
  }
  return BigInt(data);
};
var _validateNumericKindNumber = (num, context) => {
  (0, import_sdk_errors11.assert)(
    "validateNumericKindNumber",
    Number.isSafeInteger(num) && num >= 0,
    import_sdk_errors11.RLP_ERRORS.INVALID_RLP,
    `Validation error: Number in ${context} must be a safe and non-negative integer.`,
    {
      num,
      context
    }
  );
};
var _validateNumericKindString = (str, context) => {
  const isHex = Hex0x.isValid(str);
  const isDecimal = dataUtils.isDecimalString(str);
  (0, import_sdk_errors11.assert)(
    "_validateNumericKindString",
    isHex || isDecimal,
    import_sdk_errors11.RLP_ERRORS.INVALID_RLP,
    `Validation error: String in ${context} must represent a non-negative integer in hex or decimal format.`,
    { str, context }
  );
  (0, import_sdk_errors11.assert)(
    "_validateNumericKindString",
    !isHex || str.length > 2,
    import_sdk_errors11.RLP_ERRORS.INVALID_RLP,
    `Validation error: Hex string number in ${context} must be of valid length.`,
    { str, context }
  );
};
var assertValidNumericKindBuffer = (buf, context, maxBytes) => {
  (0, import_sdk_errors11.assert)(
    "assertValidNumericKindBuffer",
    maxBytes === void 0 || buf.length <= maxBytes,
    import_sdk_errors11.RLP_ERRORS.INVALID_RLP,
    `Validation error: Buffer in ${context} must be less than ${maxBytes} bytes.`,
    { maxBytes, context }
  );
  (0, import_sdk_errors11.assert)(
    "assertValidNumericKindBuffer",
    buf[0] !== 0,
    import_sdk_errors11.RLP_ERRORS.INVALID_RLP,
    `Validation error: Buffer in ${context} must represent a canonical integer (no leading zeros).`,
    { buf, context }
  );
};
var encodeBigIntToBuffer = (bi, maxBytes, context) => {
  if (bi === 0n) return Buffer.alloc(0);
  const hex = Hex.of(bi);
  (0, import_sdk_errors11.assert)(
    "encodeBigIntToBuffer",
    maxBytes === void 0 || hex.length <= maxBytes * 2,
    import_sdk_errors11.RLP_ERRORS.INVALID_RLP,
    `Validation error: Encoded number in ${context} must fit within ${maxBytes} bytes.`,
    { maxBytes, hex, context }
  );
  return Buffer.from(hex, "hex");
};
var decodeBufferToNumberOrHex = (buffer) => {
  if (buffer.length === 0) return 0;
  const bi = BigInt(Hex0x.of(buffer));
  const num = Number(bi);
  return Number.isSafeInteger(num) ? num : "0x" + bi.toString(16);
};

// src/encoding/rlp/helpers/hexblobkind.ts
var import_sdk_errors12 = require("@vechain/sdk-errors");
var assertValidHexBlobKindData = (data, context) => {
  (0, import_sdk_errors12.assert)(
    "assertValidHexBlobKindData",
    typeof data === "string",
    import_sdk_errors12.RLP_ERRORS.INVALID_RLP,
    "Validation error: Input must be a string.",
    {
      data,
      context
    }
  );
  (0, import_sdk_errors12.assert)(
    "assertValidHexBlobKindData",
    Hex0x.isValid(data),
    import_sdk_errors12.RLP_ERRORS.INVALID_RLP,
    "Validation error: Input must be a valid hex string with a '0x' prefix.",
    { data, context }
  );
  (0, import_sdk_errors12.assert)(
    "assertValidHexBlobKindData",
    data.length % 2 === 0,
    import_sdk_errors12.RLP_ERRORS.INVALID_RLP,
    "Validation error: Hex string must have an even length.",
    { data, context }
  );
};
var assertValidHexBlobKindBuffer = (buffer, context) => {
  (0, import_sdk_errors12.assert)(
    "assertValidHexBlobKindBuffer",
    Buffer.isBuffer(buffer),
    import_sdk_errors12.RLP_ERRORS.INVALID_RLP,
    "Validation error: Input must be a valid buffer.",
    {
      buffer,
      context
    }
  );
};

// src/encoding/rlp/helpers/fixedhexblobkind.ts
var import_sdk_errors13 = require("@vechain/sdk-errors");
var assertFixedHexBlobKindData = (data, context, bytes3) => {
  (0, import_sdk_errors13.assert)(
    "assertFixedHexBlobKindData",
    data.length === bytes3 * 2 + 2,
    import_sdk_errors13.RLP_ERRORS.INVALID_RLP,
    `Validation error: Hex string in ${context} must be exactly ${bytes3} bytes in length.`,
    { data, context }
  );
};
var assertFixedHexBlobKindBuffer = (buffer, context, bytes3) => {
  (0, import_sdk_errors13.assert)(
    "assertFixedHexBlobKindBuffer",
    buffer.length === bytes3,
    import_sdk_errors13.RLP_ERRORS.INVALID_RLP,
    `Validation error: Buffer in ${context} must be exactly ${bytes3} bytes in length.`,
    { buffer, context }
  );
};

// src/encoding/rlp/helpers/compactfixedhexblobkind.ts
var import_sdk_errors14 = require("@vechain/sdk-errors");
var assertCompactFixedHexBlobBuffer = (buffer, context, bytes3) => {
  (0, import_sdk_errors14.assert)(
    "assertCompactFixedHexBlobBuffer",
    buffer.length <= bytes3,
    import_sdk_errors14.RLP_ERRORS.INVALID_RLP,
    `Validation error: Buffer in ${context} must be at most ${bytes3} bytes.`,
    { buffer, context }
  );
  (0, import_sdk_errors14.assert)(
    "assertCompactFixedHexBlobBuffer",
    buffer.length === 0 || buffer[0] !== 0,
    import_sdk_errors14.RLP_ERRORS.INVALID_RLP,
    `Validation error: Buffer in ${context} should not have leading zero bytes.`,
    {
      buffer,
      context
    }
  );
};
var encodeCompactFixedHexBlob = (buffer) => {
  const zeroIndex = buffer.findIndex((byte) => byte !== 0);
  return zeroIndex !== -1 ? buffer.subarray(zeroIndex) : Buffer.alloc(0);
};
var decodeBufferToHexWithLeadingZeros = (buffer, bytes3) => {
  return Hex0x.of(buffer, bytes3);
};

// src/encoding/rlp/kind/numerickind.ts
var NumericKind = class extends ScalarKind {
  /**
   * Constructs a new instance of NumericKind.
   *
   * @param maxBytes - Optional parameter that specifies the maximum number of bytes that numeric data can occupy when encoded.
   */
  constructor(maxBytes) {
    super();
    this.maxBytes = maxBytes;
  }
  /**
   * Encodes the input data into numeric format and ensures it doesn't exceed the maximum bytes, if specified.
   *
   * @param data - The data to encode, expected to be numeric.
   * @param context - Descriptive context for error messages
   * @returns DataOutput object with an encode function.
   * @throws Will throw an error if data validation fails or encoding issues occur.
   */
  data(data, context) {
    const dataBI = validateNumericKindData(data, context);
    return {
      encode: () => encodeBigIntToBuffer(dataBI, this.maxBytes, context)
      // Encodes BigInt to Buffer, respecting maxBytes.
    };
  }
  /**
   * Decodes the input buffer into a number or hexadecimal string, ensuring it meets numeric data constraints.
   *
   * @param buffer - The buffer to decode, containing numeric data.
   * @param context - Descriptive context for error messages.
   * @returns BufferOutput object with a decode function.
   * @throws Will throw an error if buffer validation fails.
   */
  buffer(buffer, context) {
    assertValidNumericKindBuffer(buffer, context, this.maxBytes);
    return {
      decode: () => decodeBufferToNumberOrHex(buffer)
      // Decodes buffer to either a number or a hexadecimal string.
    };
  }
};

// src/encoding/rlp/kind/hexblobkinds/hexblob.ts
var HexBlobKind = class extends ScalarKind {
  /**
   * Encodes the input data into a Buffer.
   *
   * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    assertValidHexBlobKindData(data, context);
    return {
      encode: () => Buffer.from(data.slice(2), "hex")
    };
  }
  /**
   * Decodes the input buffer into a hex string.
   *
   * @param buffer - The buffer to decode.
   * @param context - Context string for error handling.
   * @returns An object containing a decode function which returns the decoded hex string.
   */
  buffer(buffer, context) {
    assertValidHexBlobKindBuffer(buffer, context);
    return {
      decode: () => Hex0x.of(buffer)
    };
  }
};

// src/encoding/rlp/kind/hexblobkinds/fixedhexblob.ts
var FixedHexBlobKind = class extends HexBlobKind {
  /**
   * Creates a new instance of the {@link FixedHexBlobKind} class.
   * @param bytes - The number of bytes the blob must have.
   */
  constructor(bytes3) {
    super();
    this.bytes = bytes3;
  }
  /**
   * Encodes the input data into a Buffer with validation against fixed size.
   *
   * @param data - The data to encode, expected to be a '0x' prefixed even sized hex string.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    const encoder = super.data(data, context);
    assertFixedHexBlobKindData(data, context, this.bytes);
    return encoder;
  }
  /**
   * Decodes the input buffer into a hex string with validation against fixed size.
   *
   * @param buffer - The buffer to decode.
   * @param context - Context string for error handling.
   * @returns An object containing a decode function which returns the decoded hex string.
   */
  buffer(buffer, context) {
    const decoder = super.buffer(buffer, context);
    assertFixedHexBlobKindBuffer(buffer, context, this.bytes);
    return decoder;
  }
};

// src/encoding/rlp/kind/hexblobkinds/optionalfixedhexblob.ts
var OptionalFixedHexBlobKind = class extends FixedHexBlobKind {
  /**
   * Encodes the input data (which can be null or undefined) into a Buffer.
   *
   * @param data - The data to encode, can be null or undefined.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    return data == null ? {
      encode: () => Buffer.alloc(0)
    } : super.data(data, context);
  }
  /**
   * Decodes the input buffer into a hex string or null if the buffer is empty.
   *
   * @param buffer - The buffer to decode, can be empty.
   * @param context - Context string for error handling.
   * @returns An object containing a decode function which returns the decoded hex string or null.
   */
  buffer(buffer, context) {
    return buffer.length === 0 ? {
      decode: () => null
    } : super.buffer(buffer, context);
  }
};

// src/encoding/rlp/kind/hexblobkinds/compactfixedhexblob.ts
var CompactFixedHexBlobKind = class extends FixedHexBlobKind {
  /**
   * Encodes the input data into a Buffer, trimming leading zeros.
   *
   * @param data - The data to encode, expected to be a '0x' prefixed hex string.
   * @param context - Context string for error handling.
   * @returns An object containing an encode function which returns the encoded Buffer.
   */
  data(data, context) {
    const buffer = super.data(data, context).encode();
    return {
      encode: () => encodeCompactFixedHexBlob(buffer)
      // Encode the buffer, trimming leading zeros.
    };
  }
  /**
   * Decodes the input buffer into a number or hexadecimal string, ensuring it meets the fixed size by padding with zeros.
   *
   * @param buffer - The buffer to decode, containing numeric data.
   * @param context - Descriptive context for error messages, usually representing the caller's identity.
   * @returns BufferOutput object with a decode function.
   * @throws Will throw an error if buffer validation fails.
   */
  buffer(buffer, context) {
    assertCompactFixedHexBlobBuffer(buffer, context, this.bytes);
    return {
      decode: () => Hex0x.of(buffer, this.bytes)
      // Decode the buffer, returning a hex string with leading zeros.
    };
  }
};

// src/encoding/rlp/kind/index.ts
var RLPProfiles = {
  ScalarKind,
  BufferKind,
  NumericKind,
  HexBlobKind,
  FixedHexBlobKind,
  OptionalFixedHexBlobKind,
  CompactFixedHexBlobKind
};

// src/encoding/rlp/index.ts
var RLP_CODER = {
  ...RLPBase,
  ...RLPProfiles
};

// src/utils/const/transaction.ts
var TRANSACTIONS_GAS_CONSTANTS = {
  /**
   * Default gas for a transaction
   * @internal
   */
  TX_GAS: 5e3,
  /**
   * Default gas for a clause
   * @internal
   */
  CLAUSE_GAS: 16e3,
  /**
   * Default gas for a contract creation clause
   * @internal
   */
  CLAUSE_GAS_CONTRACT_CREATION: 48e3,
  /**
   * Zero gas data
   * @internal
   */
  ZERO_GAS_DATA: 4,
  /**
   * Non-zero gas data
   * @internal
   */
  NON_ZERO_GAS_DATA: 68
};
var TRANSACTION_FIELDS = [
  /**
   * Chain tag. It represents the id of the chain the transaction is sent to.
   */
  { name: "chainTag", kind: new RLP_CODER.NumericKind(1) },
  /**
   * Block reference. It represents the last block of the chain the transaction is sent to.
   */
  {
    name: "blockRef",
    kind: new RLP_CODER.CompactFixedHexBlobKind(8)
  },
  /**
   * Expiration. It represents the expiration date of the transaction.
   */
  { name: "expiration", kind: new RLP_CODER.NumericKind(4) },
  /**
   * Clauses of the transaction. They represent the actions to be executed by the transaction.
   */
  {
    name: "clauses",
    kind: {
      item: [
        {
          name: "to",
          kind: new RLP_CODER.OptionalFixedHexBlobKind(20)
        },
        { name: "value", kind: new RLP_CODER.NumericKind(32) },
        { name: "data", kind: new RLP_CODER.HexBlobKind() }
      ]
    }
  },
  /**
   * Gas price coef. It represents the gas price coefficient of the transaction.
   */
  { name: "gasPriceCoef", kind: new RLP_CODER.NumericKind(1) },
  /**
   * Gas. It represents the gas limit of the transaction.
   */
  { name: "gas", kind: new RLP_CODER.NumericKind(8) },
  /**
   * Depends on. It represents the hash of the transaction the current transaction depends on.
   */
  { name: "dependsOn", kind: new RLP_CODER.OptionalFixedHexBlobKind(32) },
  /**
   * Nonce. It represents the nonce of the transaction.
   */
  { name: "nonce", kind: new RLP_CODER.NumericKind(8) },
  /**
   * Reserved. It represents the reserved field of the transaction.
   */
  { name: "reserved", kind: { item: new RLP_CODER.BufferKind() } }
];
var TRANSACTION_FEATURES_KIND = {
  name: "reserved.features",
  kind: new RLP_CODER.NumericKind(4)
};
var TRANSACTION_SIGNATURE_KIND = {
  name: "signature",
  kind: new RLP_CODER.BufferKind()
};
var UNSIGNED_TRANSACTION_RLP = new RLP_CODER.Profiler({
  name: "tx",
  kind: TRANSACTION_FIELDS
});
var SIGNED_TRANSACTION_RLP = new RLP_CODER.Profiler({
  name: "tx",
  // Add signature to the transaction fields
  kind: TRANSACTION_FIELDS.concat([TRANSACTION_SIGNATURE_KIND])
});
var SIGNATURE_LENGTH = 65;
var BLOCK_REF_LENGTH = 8;

// src/utils/const/abi.ts
var import_sdk_errors15 = require("@vechain/sdk-errors");
var PARAMS_ABI = (0, import_sdk_errors15.stringifyData)([
  {
    constant: false,
    inputs: [
      {
        name: "_key",
        type: "bytes32"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "set",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_key",
        type: "bytes32"
      }
    ],
    name: "get",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "executor",
    outputs: [
      {
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "key",
        type: "bytes32"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Set",
    type: "event"
  }
]);
var VIP180_ABI = [
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_spender",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        name: "success",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        name: "success",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "balance",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        name: "success",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_amount",
        type: "uint256"
      }
    ],
    name: "move",
    outputs: [
      {
        name: "success",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalBurned",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      },
      {
        name: "_spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        name: "remaining",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "_from",
        type: "address"
      },
      {
        indexed: true,
        name: "_to",
        type: "address"
      },
      {
        indexed: false,
        name: "_value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "_owner",
        type: "address"
      },
      {
        indexed: true,
        name: "_spender",
        type: "address"
      },
      {
        indexed: false,
        name: "_value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  }
];
var ERC721_ABI = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "ERC721IncorrectOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ERC721InsufficientApproval",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "approver",
        type: "address"
      }
    ],
    name: "ERC721InvalidApprover",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "ERC721InvalidOperator",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "ERC721InvalidOwner",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "ERC721InvalidReceiver",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "ERC721InvalidSender",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ERC721NonexistentToken",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "approved",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "receiver",
        type: "address"
      }
    ],
    name: "mintItem",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "tokenURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// ../../node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes,
  validateObject: () => validateObject
});
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var u8a = (a) => a instanceof Uint8Array;
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(bytes3) {
  if (!u8a(bytes3))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < bytes3.length; i++) {
    hex += hexes[bytes3[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const len = hex.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes3) {
  return hexToNumber(bytesToHex(bytes3));
}
function bytesToNumberLE(bytes3) {
  if (!u8a(bytes3))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes3).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (u8a(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad2 = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad2);
    pad2 += a.length;
  });
  return r;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i = 0; i < b1.length; i++)
    if (b1[i] !== b2[i])
      return false;
  return true;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n;
}
var bitSet = (n, pos, value) => {
  return n | (value ? _1n : _0n) << BigInt(pos);
};
var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}

// src/utils/bloom/bloom.ts
var import_sdk_errors19 = require("@vechain/sdk-errors");

// src/utils/hex/hex.ts
var import_sdk_errors16 = require("@vechain/sdk-errors");

// ../../node_modules/@noble/hashes/esm/crypto.js
var nodeCrypto = __toESM(require("crypto"), 1);
var crypto = {
  node: nodeCrypto,
  web: void 0
};

// ../../node_modules/@noble/hashes/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function hexToBytes2(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i] = byte;
  }
  return array;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string") {
    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
  }
  return new TextEncoder().encode(str);
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  if (!(data instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
  return data;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
function checkOpts(defaults, opts) {
  if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
    throw new TypeError("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashConstructor) {
  const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashConstructor();
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto.web) {
    return crypto.web.getRandomValues(new Uint8Array(bytesLength));
  } else if (crypto.node) {
    return new Uint8Array(crypto.node.randomBytes(bytesLength).buffer);
  } else {
    throw new Error("The environment doesn't have randomBytes function");
  }
}

// src/utils/hex/hex.ts
var PREFIX = "0x";
var RADIX = 16;
var REGEX_FOR_0X_PREFIX_HEX = /^0x[0-9a-f]*$/i;
var REGEX_FOR_OPTIONAL_0X_PREFIX_HEX = /^(0x)?[0-9a-f]*$/i;
var THOR_ID_LENGTH = 64;
function ofBigInt(bi, bytes3) {
  (0, import_sdk_errors16.assert)(
    "hex.ts.ofBigInt",
    bi >= 0,
    import_sdk_errors16.DATA.INVALID_DATA_TYPE,
    "Arg 'n' not negative." /* NOT_POSITIVE */,
    {
      bi: bi.toString()
    }
  );
  return pad(bi.toString(RADIX), bytes3);
}
function ofHexString(n, bytes3) {
  (0, import_sdk_errors16.assert)(
    "hex.ts.ofHexString",
    Hex0x.isValid(n),
    import_sdk_errors16.DATA.INVALID_DATA_TYPE,
    "Arg 'n' not an hexadecimal expression." /* NOT_HEX */,
    { n }
  );
  return pad(n.slice(2).toLowerCase(), bytes3);
}
function ofNumber(n, bytes3) {
  (0, import_sdk_errors16.assert)(
    "hex.ts.ofNumber",
    Number.isInteger(n),
    import_sdk_errors16.DATA.INVALID_DATA_TYPE,
    "Arg 'n' not an integer." /* NOT_INTEGER */,
    {
      n
    }
  );
  (0, import_sdk_errors16.assert)(
    "hex.ts.ofNumber",
    n >= 0,
    import_sdk_errors16.DATA.INVALID_DATA_TYPE,
    "Arg 'n' not negative." /* NOT_POSITIVE */,
    {
      n
    }
  );
  return pad(n.toString(RADIX), bytes3);
}
function ofString(txt2, bytes3) {
  return ofUint8Array(utf8ToBytes(txt2), bytes3);
}
function ofUint8Array(uint8Array, bytes3) {
  return pad(bytesToHex(uint8Array), bytes3);
}
function pad(exp, bytes3) {
  let result = exp;
  if (result.length % 2 !== 0) {
    result = "0" + result;
  }
  if (bytes3 > 0) {
    const gap = bytes3 - result.length / 2;
    if (gap > 0) {
      return `${"00".repeat(gap)}${result}`;
    }
  }
  return result;
}
function trim(exp) {
  let i = 0;
  while (i < exp.length && exp.at(i) === "0") {
    i++;
  }
  return i === exp.length ? "0" : exp.slice(i);
}
var Hex0x = {
  /**
   * Converts a given string expression to a canonical representation prefixed with `0x`,
   * optionally specifying the number of bytes to include in the canonical form.
   *
   * @param {string} exp - The string expression to convert to canonical form.
   * @param {number} [bytes] - The number of bytes to include in the canonical form.
   * If not specified, all bytes will be included.
   * @returns {string} The canonical representation of the given string expression.
   * @throws {Error} if `exp` is not a valid hexadecimal expression,
   * if `bytes` is not integer and greater or equal to zero.
   */
  canon: function(exp, bytes3) {
    return `${PREFIX}${Hex.canon(exp, bytes3)}`;
  },
  /**
   * Checks if the given expression is a valid Thor-based ID.
   * Thor id is a 64 characters long hexadecimal string.
   * It is used to identify a transaction id, a block id, etc.
   *
   * @param {string} exp - The expression to check.
   * @param {boolean} is0xOptional - Do not check if `exp` is `0x` prefixed, `false` by default.
   * @returns {boolean} - Returns true if the expression is a valid Thor ID, otherwise false.
   */
  isThorId: function(exp, is0xOptional = false) {
    return this.isValid(exp, is0xOptional) && (is0xOptional ? exp.length === THOR_ID_LENGTH : exp.length === THOR_ID_LENGTH + 2);
  },
  /**
   * Checks if the given expression is a valid hexadecimal expression
   * - prefixed with `0x` (or optionally if `is0xOptional is `true`),
   * - byte aligned if  `isByteAligned` is `true`.
   *
   * @param {string} exp - The expression to be validated.
   * @param {boolean} is0xOptional - Do not check if `exp` is `0x` prefixed, `false` by default.
   * @param {boolean} isByteAliged - Check `exp` represents a full byte or an array of bytes, `false`, by default.
   * @returns {boolean} - Whether the expression is valid or not.
   */
  isValid: function(exp, is0xOptional = false, isByteAliged = false) {
    let predicate = is0xOptional ? REGEX_FOR_OPTIONAL_0X_PREFIX_HEX.test(exp) : REGEX_FOR_0X_PREFIX_HEX.test(exp);
    if (isByteAliged && predicate) {
      predicate = exp.length % 2 === 0;
    }
    return predicate;
  },
  /**
   * Returns a hexadecimal representation from the given input data prefixed with `0x`.
   *
   * **Note:** this method calls {@link Hex.of} to generate the hexadecimal representation of n,
   * then it prefixes the result with `0x`.
   *
   * @param {HexRepresentable} n - The input data to be represented.
   * @param {number} [bytes=0] - If not `0` by default, the hexadecimal representation encodes at least {number}  bytes.
   * @returns {Uint8Array} - The resulting hexadecimal representation,
   * it is guaranteed to be even characters long.
   * @see Hex
   * @see HexRepresentable
   */
  of: function(n, bytes3 = 0) {
    return `${PREFIX}${Hex.of(n, bytes3)}`;
  }
};
var Hex = {
  /**
   * Converts a given string expression to a canonical representation prefixed with `0x`,
   * optionally specifying the number of bytes to include in the canonical form.
   *
   * @param {string} exp - The string expression to convert to canonical form.
   * @param {number} [bytes] - The number of bytes to include in the canonical form.
   * If not specified, all bytes will be included.
   * @returns {string} The canonical representation of the given string expression.
   * @throws {InvalidDataTypeError} if `exp` is not a valid hexadecimal expression,
   * if `bytes` is not integer and greater or equal to zero.
   */
  canon: function(exp, bytes3) {
    let result = "";
    if (REGEX_FOR_0X_PREFIX_HEX.test(exp)) {
      result = exp.slice(2).toLowerCase();
    } else if (REGEX_FOR_OPTIONAL_0X_PREFIX_HEX.test(exp)) {
      result = exp.toLowerCase();
    } else {
      throw (0, import_sdk_errors16.buildError)(
        `Hex.canon`,
        import_sdk_errors16.DATA.INVALID_DATA_TYPE,
        "Arg 'n' not an hexadecimal expression." /* NOT_HEX */,
        { exp }
      );
    }
    if (typeof bytes3 !== "undefined") {
      (0, import_sdk_errors16.assert)(
        "Hex.canon",
        Number.isInteger(bytes3) && bytes3 >= 0,
        import_sdk_errors16.DATA.INVALID_DATA_TYPE,
        "Arg 'bytes' not a length." /* NOT_LENGTH */,
        { bytes: bytes3 }
      );
      result = pad(result, bytes3);
      (0, import_sdk_errors16.assert)(
        "Hex.canon",
        result.length <= bytes3 * 2,
        import_sdk_errors16.DATA.INVALID_DATA_TYPE,
        "Arg 'bytes' not enough to fit 'exp'." /* NOT_FIT */,
        { bytes: bytes3 }
      );
    }
    return result;
  },
  /**
   * Returns a hexadecimal representation from the given input data.
   * This method calls
   * * {@link ofBigInt} if `n` type is `bigint`;
   * * {@link ofHexString} if `n` type is {@link HexString}`;
   * * {@link ofNumber} if `n` type is `number`;
   * * {@link ofString} if `n` type is `string`;
   * * {@link ofUint8Array} if `n` is an instance of {@link Uint8Array}.
   *
   * **Note:** the returned string is not prefixed with `0x`,
   * see {@link Hex0x.of} to make a hexadecimal representation prefixed with `0x`.
   *
   * **Note:** [HexString](https://docs.ethers.org/v6/api/utils/#HexString)
   * definition overlaps `string` TS completely as an alias.
   * This function tests if the given input starts with `0x`
   * and is positive to {@link Hex0x.isValid}
   * processing it as {@link HexString} type,
   * else it considers the string as an array of bytes and
   * returns its hexadecimal representation.
   * To force a string to be considered an array of bytes despite it is
   * a valid `0x` hexadecimal expression, convert it to {@link Uint8Array}.
   * ```
   * Hex.of(buffer.toString('hex'))
   * ```
   *
   * @param {HexRepresentable} n - The input data to be represented.
   * @param {number} [bytes=0] - If not `0` by default, the hexadecimal representation encodes at least {number}  bytes.
   * @returns {Uint8Array} - The resulting hexadecimal representation,
   * it is guaranteed to be even characters long.
   * @see HexRepresentable
   */
  of: function(n, bytes3 = 0) {
    if (n instanceof Uint8Array) return ofUint8Array(n, bytes3);
    if (typeof n === "bigint") return ofBigInt(n, bytes3);
    if (typeof n === `number`) return ofNumber(n, bytes3);
    if (Hex0x.isValid(n)) return ofHexString(n, bytes3);
    return ofString(n, bytes3);
  },
  /**
   * Generates a random hexadecimal string of the specified number of bytes.
   * The length of the string is twice the `bytes`.
   *
   * @param {number} bytes - The number of bytes for the random string.
   * @return {string} - The generated random string.
   */
  random: function(bytes3) {
    return ofUint8Array(randomBytes(bytes3), bytes3);
  }
};
var Quantity = {
  /**
   *  Returns a hexadecimal representation for the given input data
   *  - without any not meaningful `0` digit on the left side,
   *  - prefixed with `0x`,
   *  - hence returns `0x0` if `n` is zero.
   *
   * This function is a more efficient drop-in replacement of the function
   * `toQuantity` in [math.ts](https://github.com/ethers-io/ethers.js/blob/main/src.ts/utils/maths.ts)
   * of [The Ethers Project](https://github.com/ethers-io/ethers.js/tree/main) library.
   *
   * @param {HexRepresentable} n - The input data to be represented.
   * @return The resulting hexadecimal representation, nibble aligned.
   * @see HexRepresentable
   */
  of(n) {
    return `${PREFIX}${trim(Hex.of(n))}`;
  }
};

// src/bloom/bloom.ts
var import_sdk_errors18 = require("@vechain/sdk-errors");

// ../../node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash4) {
  if (typeof hash4 !== "function" || typeof hash4.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash4.outputLen);
  number(hash4.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert14 = {
  number,
  bool,
  bytes,
  hash,
  exists,
  output
};
var assert_default = assert14;

// ../../node_modules/@noble/hashes/esm/_blake2.js
var SIGMA = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  // For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
]);
var BLAKE2 = class extends Hash {
  constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.length = 0;
    this.pos = 0;
    this.finished = false;
    this.destroyed = false;
    assert_default.number(blockLen);
    assert_default.number(outputLen);
    assert_default.number(keyLen);
    if (outputLen < 0 || outputLen > keyLen)
      throw new Error("Blake2: outputLen bigger than keyLen");
    if (opts.key !== void 0 && (opts.key.length < 1 || opts.key.length > keyLen))
      throw new Error(`Key should be up 1..${keyLen} byte long or undefined`);
    if (opts.salt !== void 0 && opts.salt.length !== saltLen)
      throw new Error(`Salt should be ${saltLen} byte long or undefined`);
    if (opts.personalization !== void 0 && opts.personalization.length !== persLen)
      throw new Error(`Personalization should be ${persLen} byte long or undefined`);
    this.buffer32 = u32(this.buffer = new Uint8Array(blockLen));
  }
  update(data) {
    assert_default.exists(this);
    const { blockLen, buffer, buffer32 } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        this.compress(buffer32, 0, false);
        this.pos = 0;
      }
      const take = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = data.byteOffset + pos;
      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
        const data32 = new Uint32Array(data.buffer, dataOffset, Math.floor((len - pos) / 4));
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      this.length += take;
      pos += take;
    }
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    this.buffer.subarray(pos).fill(0);
    this.compress(buffer32, 0, true);
    const out32 = u32(out);
    this.get().forEach((v, i) => out32[i] = v);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    const { buffer, length, finished, destroyed, outputLen, pos } = this;
    to || (to = new this.constructor({ dkLen: outputLen }));
    to.set(...this.get());
    to.length = length;
    to.finished = finished;
    to.destroyed = destroyed;
    to.outputLen = outputLen;
    to.buffer.set(buffer);
    to.pos = pos;
    return to;
  }
};

// ../../node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
var shrSH = (h, l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (h, l) => l;
var rotr32L = (h, l) => h;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// ../../node_modules/@noble/hashes/esm/blake2b.js
var IV = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var BUF = new Uint32Array(32);
function G1(a, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BUF[2 * a], Ah = BUF[2 * a + 1];
  let Bl = BUF[2 * b], Bh = BUF[2 * b + 1];
  let Cl = BUF[2 * c], Ch = BUF[2 * c + 1];
  let Dl = BUF[2 * d], Dh = BUF[2 * d + 1];
  let ll = u64_default.add3L(Al, Bl, Xl);
  Ah = u64_default.add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: u64_default.rotr32H(Dh, Dl), Dl: u64_default.rotr32L(Dh, Dl) });
  ({ h: Ch, l: Cl } = u64_default.add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: u64_default.rotrSH(Bh, Bl, 24), Bl: u64_default.rotrSL(Bh, Bl, 24) });
  BUF[2 * a] = Al, BUF[2 * a + 1] = Ah;
  BUF[2 * b] = Bl, BUF[2 * b + 1] = Bh;
  BUF[2 * c] = Cl, BUF[2 * c + 1] = Ch;
  BUF[2 * d] = Dl, BUF[2 * d + 1] = Dh;
}
function G2(a, b, c, d, msg, x) {
  const Xl = msg[x], Xh = msg[x + 1];
  let Al = BUF[2 * a], Ah = BUF[2 * a + 1];
  let Bl = BUF[2 * b], Bh = BUF[2 * b + 1];
  let Cl = BUF[2 * c], Ch = BUF[2 * c + 1];
  let Dl = BUF[2 * d], Dh = BUF[2 * d + 1];
  let ll = u64_default.add3L(Al, Bl, Xl);
  Ah = u64_default.add3H(ll, Ah, Bh, Xh);
  Al = ll | 0;
  ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
  ({ Dh, Dl } = { Dh: u64_default.rotrSH(Dh, Dl, 16), Dl: u64_default.rotrSL(Dh, Dl, 16) });
  ({ h: Ch, l: Cl } = u64_default.add(Ch, Cl, Dh, Dl));
  ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
  ({ Bh, Bl } = { Bh: u64_default.rotrBH(Bh, Bl, 63), Bl: u64_default.rotrBL(Bh, Bl, 63) });
  BUF[2 * a] = Al, BUF[2 * a + 1] = Ah;
  BUF[2 * b] = Bl, BUF[2 * b + 1] = Bh;
  BUF[2 * c] = Cl, BUF[2 * c + 1] = Ch;
  BUF[2 * d] = Dl, BUF[2 * d + 1] = Dh;
}
var BLAKE2b = class extends BLAKE2 {
  constructor(opts = {}) {
    super(128, opts.dkLen === void 0 ? 64 : opts.dkLen, opts, 64, 16, 16);
    this.v0l = IV[0] | 0;
    this.v0h = IV[1] | 0;
    this.v1l = IV[2] | 0;
    this.v1h = IV[3] | 0;
    this.v2l = IV[4] | 0;
    this.v2h = IV[5] | 0;
    this.v3l = IV[6] | 0;
    this.v3h = IV[7] | 0;
    this.v4l = IV[8] | 0;
    this.v4h = IV[9] | 0;
    this.v5l = IV[10] | 0;
    this.v5h = IV[11] | 0;
    this.v6l = IV[12] | 0;
    this.v6h = IV[13] | 0;
    this.v7l = IV[14] | 0;
    this.v7h = IV[15] | 0;
    const keyLength = opts.key ? opts.key.length : 0;
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (opts.salt) {
      const salt = u32(toBytes(opts.salt));
      this.v4l ^= salt[0];
      this.v4h ^= salt[1];
      this.v5l ^= salt[2];
      this.v5h ^= salt[3];
    }
    if (opts.personalization) {
      const pers = u32(toBytes(opts.personalization));
      this.v6l ^= pers[0];
      this.v6h ^= pers[1];
      this.v7l ^= pers[2];
      this.v7h ^= pers[3];
    }
    if (opts.key) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(toBytes(opts.key));
      this.update(tmp);
    }
  }
  // prettier-ignore
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  // prettier-ignore
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset, isLast) {
    this.get().forEach((v, i) => BUF[i] = v);
    BUF.set(IV, 16);
    let { h, l } = u64_default.fromBig(BigInt(this.length));
    BUF[24] = IV[8] ^ l;
    BUF[25] = IV[9] ^ h;
    if (isLast) {
      BUF[28] = ~BUF[28];
      BUF[29] = ~BUF[29];
    }
    let j = 0;
    const s = SIGMA;
    for (let i = 0; i < 12; i++) {
      G1(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G2(0, 4, 8, 12, msg, offset + 2 * s[j++]);
      G1(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G2(1, 5, 9, 13, msg, offset + 2 * s[j++]);
      G1(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G2(2, 6, 10, 14, msg, offset + 2 * s[j++]);
      G1(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G2(3, 7, 11, 15, msg, offset + 2 * s[j++]);
      G1(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G2(0, 5, 10, 15, msg, offset + 2 * s[j++]);
      G1(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G2(1, 6, 11, 12, msg, offset + 2 * s[j++]);
      G1(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G2(2, 7, 8, 13, msg, offset + 2 * s[j++]);
      G1(3, 4, 9, 14, msg, offset + 2 * s[j++]);
      G2(3, 4, 9, 14, msg, offset + 2 * s[j++]);
    }
    this.v0l ^= BUF[0] ^ BUF[16];
    this.v0h ^= BUF[1] ^ BUF[17];
    this.v1l ^= BUF[2] ^ BUF[18];
    this.v1h ^= BUF[3] ^ BUF[19];
    this.v2l ^= BUF[4] ^ BUF[20];
    this.v2h ^= BUF[5] ^ BUF[21];
    this.v3l ^= BUF[6] ^ BUF[22];
    this.v3h ^= BUF[7] ^ BUF[23];
    this.v4l ^= BUF[8] ^ BUF[24];
    this.v4h ^= BUF[9] ^ BUF[25];
    this.v5l ^= BUF[10] ^ BUF[26];
    this.v5h ^= BUF[11] ^ BUF[27];
    this.v6l ^= BUF[12] ^ BUF[28];
    this.v6h ^= BUF[13] ^ BUF[29];
    this.v7l ^= BUF[14] ^ BUF[30];
    this.v7h ^= BUF[15] ^ BUF[31];
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer32.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2b = wrapConstructorWithOpts((opts) => new BLAKE2b(opts));

// src/hash/blake2b256.ts
var import_sdk_errors17 = require("@vechain/sdk-errors");

// src/utils/txt/txt.ts
var TEXT_DECODER = new TextDecoder();
var TEXT_ENCODER = new TextEncoder();
var txt = {
  /**
   * Decodes a Uint8Array content into a string, using the consistent
   * [normalization form for canonical composition](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms).
   *
   * @param {Uint8Array} content - The Uint8Array content to decode.
   * @returns {string} - The decoded string.
   */
  decode: function(content) {
    return TEXT_DECODER.decode(content).normalize(
      NORMALIZATION_FORM_CANONICAL_COMPOSITION
    );
  },
  /**
   * Encodes the given text into a Uint8Array, using the consistent
   * [normalization form for canonical composition](https://en.wikipedia.org/wiki/Unicode_equivalence#Normal_forms).
   *
   * @param {string} text - The text to encode.
   * @returns {Uint8Array} - The encoded text as a Uint8Array.
   */
  encode: function(text) {
    return TEXT_ENCODER.encode(
      text.normalize(NORMALIZATION_FORM_CANONICAL_COMPOSITION)
    );
  }
};
var NORMALIZATION_FORM_CANONICAL_COMPOSITION = "NFC";

// src/hash/blake2b256.ts
function blake2b256(data, returnType = "buffer") {
  assertIsValidReturnType("blake2b256", returnType);
  if (data instanceof Uint8Array) {
    const hash4 = blake2b256OfArray(data);
    return returnType === "hex" ? Hex0x.of(hash4) : hash4;
  } else {
    const hash4 = blake2b256OfString(data);
    return returnType === "hex" ? Hex0x.of(hash4) : hash4;
  }
}
function blake2b256OfArray(array) {
  return blake2b.create({ dkLen: 32 }).update(array).digest();
}
function blake2b256OfHex(hex, returnType = "buffer") {
  assertIsValidReturnType("blake2b256", returnType);
  try {
    const hash4 = blake2b256OfArray(hexToBytes2(Hex.canon(hex)));
    return returnType === "hex" ? Hex0x.of(hash4) : hash4;
  } catch (e) {
    throw (0, import_sdk_errors17.buildError)(
      "blake2b256OfHex",
      import_sdk_errors17.DATA.INVALID_DATA_TYPE,
      e.message,
      { hex },
      e
    );
  }
}
function blake2b256OfString(text) {
  return blake2b256OfArray(txt.encode(text));
}

// ../../node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    assert_default.exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE3);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// ../../node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV2 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV2[0] | 0;
    this.B = IV2[1] | 0;
    this.C = IV2[2] | 0;
    this.D = IV2[3] | 0;
    this.E = IV2[4] | 0;
    this.F = IV2[5] | 0;
    this.G = IV2[6] | 0;
    this.H = IV2[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// src/hash/sha256.ts
function sha2562(data, returnType = "buffer") {
  assertIsValidReturnType("sha256", returnType);
  const hash4 = sha256(data);
  return returnType === "buffer" ? hash4 : Hex0x.of(hash4);
}

// ../../node_modules/@noble/hashes/esm/sha3.js
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R = _1n2, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n2;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n2 ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n2)
      t ^= _1n2 << (_1n2 << BigInt(j)) - _1n2;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = u64_default.split(_SHA3_IOTA, true);
var rotlH = (h, l, s) => s > 32 ? u64_default.rotlBH(h, l, s) : u64_default.rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? u64_default.rotlBL(h, l, s) : u64_default.rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    assert_default.number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    assert_default.exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    assert_default.exists(this, false);
    assert_default.bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes3) {
    assert_default.number(bytes3);
    return this.xofInto(new Uint8Array(bytes3));
  }
  digestInto(out) {
    assert_default.output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// src/hash/keccak256.ts
function keccak256(data, returnType = "buffer") {
  assertIsValidReturnType("keccak256", returnType);
  const hash4 = keccak_256(data);
  return returnType === "buffer" ? hash4 : Hex0x.of(hash4);
}

// src/bloom/bloom.ts
function addWithUInt32Wrap(a, b) {
  return (a + b) % 2 ** 32;
}
function calculateBitsPerKey(k) {
  if (k <= 1) return 2;
  return k >= 30 ? 44 : Math.ceil(k / 0.69);
}
function calculateK(bitsPerKey) {
  const k = Math.floor(bitsPerKey * 0.69);
  if (k < 1) return 1;
  return k > 30 ? 30 : k;
}
function distribute(hash4, k, nBits, cb) {
  const delta = (hash4 >>> 17 | hash4 << 15) >>> 0;
  for (let i = 0; i < k; i++) {
    const bitPos = hash4 % nBits;
    if (!cb(Math.floor(bitPos / 8), 1 << bitPos % 8)) {
      return false;
    }
    hash4 = addWithUInt32Wrap(hash4, delta);
  }
  return true;
}
function hash2(key) {
  return Number(bytesToNumberBE(blake2b256(key).slice(0, 4)));
}
var Filter = class _Filter {
  bits;
  k;
  /**
   * Constructs a new Filter instance.
   *
   * @constructor
   * @param {Uint8Array} bits - The input array containing bits.
   * @param {number} k - The value of k.
   */
  constructor(bits, k) {
    this.bits = bits;
    this.k = k;
  }
  /**
   * Composes the current filter with another filter by performing a bitwise OR operation on the filter bits.
   * Both filters must have been generated with the same number of hash functions, and they must have the same length.
   *
   * @param {Filter} other - The filter to compose with.
   * @returns {Filter} - A new filter that is the result of the composition.
   *
   * @throws InvalidBloomError If the other filter has a different length.
   * @throws InvalidKError if the other filter was generated with a different `k` number of hash functions.
   */
  compose(other) {
    (0, import_sdk_errors18.assert)(
      "Filter.compose",
      this.bits.length === other.bits.length,
      import_sdk_errors18.BLOOM.INVALID_BLOOM,
      "Filters have different lengths",
      {
        this: this,
        other
      }
    );
    (0, import_sdk_errors18.assert)(
      "Filter.compose",
      this.k === other.k,
      import_sdk_errors18.BLOOM.INVALID_K,
      "Filters generated with different k number of hash functions",
      {
        this: this,
        other
      }
    );
    return new _Filter(
      new Uint8Array(
        this.bits.map((bit, index) => bit | other.bits[index])
      ),
      this.k
    );
  }
  /**
   * Checks if the Bloom filter may contain the specified key.
   * Note: false positives are possible, but false negatives are not.
   *
   * @param {Uint8Array} key - The key to check.
   *
   * @return {boolean} - True if the Bloom filter may contain the key, otherwise false.
   */
  contains(key) {
    return distribute(
      hash2(key),
      this.k,
      this.bits.byteLength * 8,
      (index, bit) => {
        return (this.bits[index] & bit) === bit;
      }
    );
  }
  /**
   * Checks if the current filter is composable with another filter.
   * Two filters are composable if they have the same 'k' value expressing the number of hash function used for
   * the generation of the filters, and the same number of bits.
   *
   * @param {Filter} other - The filter to compare with.
   *
   * @return {boolean} - True if the filters are composable, false otherwise.
   */
  isComposableWith(other) {
    return this.k === other.k && this.bits.length === other.bits.length;
  }
};
var Generator = class {
  hashes = /* @__PURE__ */ new Map();
  /**
   * Adds a key to the set of hashes.
   *
   * Secure audit function.
   * * {@link hash}
   *
   * @param {Uint8Array} key - The key to be added to the set of hashes.
   */
  add(key) {
    this.hashes.set(hash2(key), true);
  }
  /**
   * Generates a Bloom filter with the specified number of bits per key and number of hash functions.
   * The generator will be reset after generation.
   *
   * @param {number} bitsPerKey - The desired number of bits per key in the Bloom filter (`m` in math literature).
   * @param {number} k - The number of hash functions to use in the Bloom filter.
   * @returns {Filter} - The generated Bloom filter.
   */
  generate(bitsPerKey, k) {
    let nBytes = Math.floor((this.hashes.size * bitsPerKey + 7) / 8);
    nBytes = nBytes < 8 ? 8 : nBytes;
    const bits = new Uint8Array(nBytes);
    const nBits = nBytes * 8;
    for (const hash4 of this.hashes.keys()) {
      distribute(hash4, k, nBits, (index, bit) => {
        bits[index] |= bit;
        return true;
      });
    }
    this.hashes.clear();
    return new Filter(bits, k);
  }
};
var bloom = {
  calculateBitsPerKey,
  calculateK,
  Filter,
  Generator
};

// src/utils/bloom/bloom.ts
var BLOOM_REGEX = /^(0x)?[0-9a-f]{16,}$/i;
var BLOOM_DEFAULT_K = 5;
var filterOf = (addresses, k = 5) => {
  const keys = /* @__PURE__ */ new Set();
  addresses.forEach((address) => {
    if (addressUtils.isAddress(Hex0x.canon(address))) {
      keys.add(hexToBytes(Hex.canon(address)));
    }
  });
  const generator = new bloom.Generator();
  keys.forEach((key) => {
    generator.add(key);
  });
  return bytesToHex(
    generator.generate(bloom.calculateBitsPerKey(k), k).bits
  );
};
var isBloom = (filter) => {
  return BLOOM_REGEX.test(filter);
};
var isInBloom = (filter, k, data) => {
  (0, import_sdk_errors19.assert)(
    "bloomUtils.isInBloom",
    isBloom(filter),
    import_sdk_errors19.BLOOM.INVALID_BLOOM,
    "Invalid bloom filter format. Bloom filters must adhere to the format 0x[0-9a-fA-F]{16,}.",
    { bloom: filter }
  );
  (0, import_sdk_errors19.assert)(
    "bloomUtils.isInBloom",
    typeof data === "string" && Hex0x.isValid(data, true),
    import_sdk_errors19.DATA.INVALID_DATA_TYPE,
    "Invalid data type. Data should be an hexadecimal string",
    { data }
  );
  (0, import_sdk_errors19.assert)(
    "bloomUtils.isInBloom",
    Number.isInteger(k) && k > 0,
    import_sdk_errors19.BLOOM.INVALID_K,
    "Invalid k. It should be a positive integer.",
    { k }
  );
  const bloomFilter = new bloom.Filter(
    hexToBytes(Hex.canon(filter)),
    k
  );
  return bloomFilter.contains(hexToBytes(Hex.canon(data)));
};
var isAddressInBloom = (filter, k, address) => {
  (0, import_sdk_errors19.assert)(
    "bloomUtils.isAddressInBloom",
    addressUtils.isAddress(address),
    import_sdk_errors19.ADDRESS.INVALID_ADDRESS,
    "Invalid address given as input in Bloom filter. Ensure it is a valid VeChain thor address.",
    { addressToCheck: address }
  );
  return isInBloom(filter, k, address);
};
var bloomUtils = {
  BLOOM_DEFAULT_K,
  filterOf,
  isBloom,
  isInBloom,
  isAddressInBloom
};

// src/utils/data/data.ts
var import_sdk_errors20 = require("@vechain/sdk-errors");
var decodeBytes32String = (hex) => {
  (0, import_sdk_errors20.assert)(
    "decodeBytes32String",
    Hex0x.isValid(hex) && Hex.canon(hex).length === 64,
    import_sdk_errors20.DATA.INVALID_DATA_TYPE,
    `Failed to decode value ${hex} to string. Value is not a valid hex string or it is not 64 characters long`,
    { value: hex }
  );
  const valueInBytes = hexToBytes(Hex.canon(hex));
  const firstZeroIndex = valueInBytes.findIndex((byte) => byte === 0);
  if (firstZeroIndex === 0) {
    const firstNotZeroIndex = valueInBytes.findIndex((byte) => byte !== 0);
    return txt.decode(valueInBytes.subarray(firstNotZeroIndex));
  } else if (firstZeroIndex !== -1) {
    return txt.decode(valueInBytes.subarray(0, firstZeroIndex));
  } else {
    return txt.decode(valueInBytes);
  }
};
var encodeBytes32String = (value, zeroPadding = "right") => {
  try {
    const valueInBytes = txt.encode(value);
    (0, import_sdk_errors20.assert)(
      "dataUtils.encodeBytes32String",
      valueInBytes.length <= 32,
      import_sdk_errors20.DATA.INVALID_DATA_TYPE,
      `Value '${value}' exceeds 32 bytes.`,
      { value }
    );
    const pad2 = ZERO_BYTES(32 - valueInBytes.length);
    return zeroPadding === "left" ? Hex0x.of(concatBytes(pad2, valueInBytes)) : Hex0x.of(concatBytes(valueInBytes, pad2));
  } catch (e) {
    throw (0, import_sdk_errors20.buildError)(
      "dataUtils.encodeBytes32String",
      import_sdk_errors20.DATA.INVALID_DATA_TYPE,
      `Failed to encode value ${value} to bytes32 string.`,
      { value },
      e
    );
  }
};
var isDecimalString = (data) => {
  return INTEGER_REGEX.test(data);
};
var isNumeric = (value) => {
  return NUMERIC_REGEX.test(value);
};
var dataUtils = {
  decodeBytes32String,
  encodeBytes32String,
  isDecimalString,
  isNumeric
};

// src/utils/hdnode/hdnode.ts
function _checkDerivationPathSingleComponentValid(component, index) {
  return (
    // m
    (index === 0 ? component === "m" : false) || // "number"
    INTEGER_REGEX.test(component) || // "number'"
    INTEGER_REGEX.test(component.slice(0, -1)) && component.endsWith("'")
  );
}
function isDerivationPathValid(derivationPath) {
  const pathComponents = derivationPath.split("/");
  for (let i = 0; i < pathComponents.length; i++) {
    if (!_checkDerivationPathSingleComponentValid(pathComponents[i], i))
      return false;
  }
  return true;
}

// src/utils/transaction/transaction.ts
var import_sdk_errors21 = require("@vechain/sdk-errors");
function intrinsicGas(clauses) {
  if (clauses.length === 0) {
    return TRANSACTIONS_GAS_CONSTANTS.TX_GAS + TRANSACTIONS_GAS_CONSTANTS.CLAUSE_GAS;
  }
  return clauses.reduce((sum, clause) => {
    if (clause.to !== null) {
      (0, import_sdk_errors21.assert)(
        "intrinsicGas",
        addressUtils.isAddress(clause.to) || clause.to.includes("."),
        import_sdk_errors21.DATA.INVALID_DATA_TYPE,
        `Invalid data type in clause. Each 'to' field must be a valid address.`,
        { clause }
      );
      sum += TRANSACTIONS_GAS_CONSTANTS.CLAUSE_GAS;
    } else {
      sum += TRANSACTIONS_GAS_CONSTANTS.CLAUSE_GAS_CONTRACT_CREATION;
    }
    sum += _calculateDataUsedGas(clause.data);
    return sum;
  }, TRANSACTIONS_GAS_CONSTANTS.TX_GAS);
}
function _calculateDataUsedGas(data) {
  (0, import_sdk_errors21.assert)(
    "_calculateDataUsedGas",
    data === "" || Hex0x.isValid(data),
    import_sdk_errors21.DATA.INVALID_DATA_TYPE,
    "Invalid data type for gas calculation. Data should be a hexadecimal string.",
    { data }
  );
  let sum = 0;
  for (let i = 2; i < data.length; i += 2) {
    if (data.substring(i, i + 2) === "00") {
      sum += TRANSACTIONS_GAS_CONSTANTS.ZERO_GAS_DATA;
    } else {
      sum += TRANSACTIONS_GAS_CONSTANTS.NON_ZERO_GAS_DATA;
    }
  }
  return sum;
}
var TransactionUtils = { intrinsicGas };

// src/utils/units/units.ts
var import_bignumber = require("bignumber.js");
var import_sdk_errors22 = require("@vechain/sdk-errors");
var BIG_NUMBER_PRECISION = 80;
var VET_DECIMAL_EXPONENT = 18;
var WEI_UNIT_NAMES = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function bigNumberOf(value) {
  let bn;
  switch (typeof value) {
    case "bigint":
      bn = (0, import_bignumber.BigNumber)(value.toString());
      break;
    case "number":
      bn = (0, import_bignumber.BigNumber)(value);
      break;
    case "string": {
      if (Hex0x.isValid(value)) {
        bn = (0, import_bignumber.BigNumber)(
          hexToNumber(Hex.canon(value)).toString()
        );
      } else {
        bn = (0, import_bignumber.BigNumber)(value);
      }
    }
  }
  (0, import_sdk_errors22.assert)(
    "unitsUtils.bigNumberOf",
    !bn.isNaN(),
    import_sdk_errors22.DATA.INVALID_DATA_TYPE,
    "Not a number.",
    { value: value.toString() }
  );
  return bn;
}
function digitsOfFractionalPart(value) {
  let d = 0;
  const i = value.abs().integerValue(import_bignumber.BigNumber.ROUND_FLOOR);
  let f = value.abs().minus(i);
  while (!f.isInteger()) {
    ++d;
    f = f.times(10);
  }
  return d;
}
function digitsOfIntegerPart(value) {
  let d = 0;
  let i = value.abs().integerValue(import_bignumber.BigNumber.ROUND_FLOOR);
  while (i.gte(1)) {
    d++;
    i = i.div(10);
  }
  return d;
}
function digitsOfUnit(digitsOrUnit) {
  let digits;
  switch (typeof digitsOrUnit) {
    case "bigint":
      digits = Number(digitsOrUnit);
      break;
    case "number":
      digits = Math.floor(digitsOrUnit);
      break;
    case "string": {
      const index = WEI_UNIT_NAMES.indexOf(digitsOrUnit);
      if (index < 0) {
        throw (0, import_sdk_errors22.buildError)(
          "unitUtils.digitOfUnit",
          import_sdk_errors22.DATA.INVALID_DATA_TYPE,
          "Invalid unit name.",
          { digitsOrUnit }
        );
      }
      digits = index * 3;
    }
  }
  (0, import_sdk_errors22.assert)(
    "unitsUtils.digitOfUnit",
    digits <= BIG_NUMBER_PRECISION,
    import_sdk_errors22.DATA.INVALID_DATA_TYPE,
    "Precision overflow (digits or unit name).",
    { digitsOrUnit: digitsOrUnit.toString() }
  );
  (0, import_sdk_errors22.assert)(
    "unitsUtils.digitOfUnit",
    digits >= 0,
    import_sdk_errors22.DATA.INVALID_DATA_TYPE,
    "Negative precision (digits or unit name).",
    { digitsOrUnit: digitsOrUnit.toString() }
  );
  return digits;
}
function formatUnits(value, decimalsOrUnit = VET_DECIMAL_EXPONENT) {
  const bnConfig = import_bignumber.BigNumber.config();
  import_bignumber.BigNumber.set({
    DECIMAL_PLACES: BIG_NUMBER_PRECISION,
    ROUNDING_MODE: import_bignumber.BigNumber.ROUND_HALF_UP
  });
  try {
    const bn = bigNumberOf(value);
    const powerOfTen = digitsOfUnit(decimalsOrUnit);
    const divisor = (0, import_bignumber.BigNumber)(10).pow(powerOfTen);
    const result = bn.div(divisor);
    let fixedDecimals = digitsOfFractionalPart(result);
    if (fixedDecimals === 0 && decimalsOrUnit !== WEI_UNIT_NAMES[0]) {
      fixedDecimals = 1;
    }
    return result.toFixed(fixedDecimals);
  } catch (e) {
    throw (0, import_sdk_errors22.buildError)(
      "unitsUtils.formatUnits",
      import_sdk_errors22.DATA.INVALID_DATA_TYPE,
      e.message,
      { value, digitsOrUnit: decimalsOrUnit },
      e
    );
  } finally {
    import_bignumber.BigNumber.set(bnConfig);
  }
}
var formatVET = (value) => {
  return formatUnits(value, VET_DECIMAL_EXPONENT);
};
function parseUnits(value, digitsOrUnit = VET_DECIMAL_EXPONENT) {
  const bnConfig = import_bignumber.BigNumber.config();
  import_bignumber.BigNumber.set({
    DECIMAL_PLACES: BIG_NUMBER_PRECISION,
    ROUNDING_MODE: import_bignumber.BigNumber.ROUND_HALF_UP
  });
  try {
    const bn = bigNumberOf(value);
    const powerOfTen = digitsOfUnit(digitsOrUnit);
    const multiplier = (0, import_bignumber.BigNumber)(10).pow(powerOfTen);
    const result = bn.times(multiplier);
    const fractionDigits = digitsOfFractionalPart(result);
    const integerDigits = digitsOfIntegerPart(result);
    return BigInt(result.toPrecision(fractionDigits + integerDigits));
  } catch (e) {
    throw (0, import_sdk_errors22.buildError)(
      "unitsUtils.parseUnits",
      import_sdk_errors22.DATA.INVALID_DATA_TYPE,
      e.message,
      { value, decimalsOrUnit: digitsOrUnit },
      e
    );
  } finally {
    import_bignumber.BigNumber.set(bnConfig);
  }
}
var parseVET = (value) => {
  return parseUnits(value, VET_DECIMAL_EXPONENT);
};
var unitsUtils = {
  formatUnits,
  formatVET,
  parseUnits,
  parseVET
};

// src/utils/revision/revision.ts
var isRevisionBlock = (revision) => {
  return revision === "finalized" || isRevisionAccount(revision);
};
var isRevisionAccount = (revision) => {
  return revision === "best" || revision === "finalized" || typeof revision === "string" && Hex0x.isValid(revision) || typeof revision === "string" && dataUtils.isDecimalString(revision) || typeof revision === "number" && revision >= 0;
};
var revisionUtils = { isRevisionBlock, isRevisionAccount };

// src/secp256k1/secp256k1.ts
var import_sdk_errors23 = require("@vechain/sdk-errors");

// ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js
function number2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bytes2(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash3(hash4) {
  if (typeof hash4 !== "function" || typeof hash4.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number2(hash4.outputLen);
  number2(hash4.blockLen);
}
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js
var nc = __toESM(require("crypto"), 1);
var crypto2 = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : void 0;

// ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js
var u8a2 = (a) => a instanceof Uint8Array;
var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE2)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes3(data);
  if (!u8a2(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes2(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad2 = 0;
  arrays.forEach((a) => {
    if (!u8a2(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad2);
    pad2 += a.length;
  });
  return r;
}
var Hash2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes2(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint642(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
var SHA22 = class extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    exists2(this);
    const { view, buffer, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists2(this);
    output2(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE3);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js
var Chi2 = (a, b, c) => a & b ^ ~a & c;
var Maj2 = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K2 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV3 = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
var SHA2562 = class extends SHA22 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV3[0] | 0;
    this.B = IV3[1] | 0;
    this.C = IV3[2] | 0;
    this.D = IV3[3] | 0;
    this.E = IV3[4] | 0;
    this.F = IV3[5] | 0;
    this.G = IV3[6] | 0;
    this.H = IV3[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W2[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W2[i - 15];
      const W2 = SHA256_W2[i - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
      SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
      const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
      const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
      const T2 = sigma0 + Maj2(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha2563 = /* @__PURE__ */ wrapConstructor2(() => new SHA2562());

// ../../node_modules/@noble/curves/esm/abstract/modular.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n3 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n3 || power < _0n3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number3, modulo) {
  if (number3 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a = mod(number3, modulo);
  let b = modulo;
  let x = _0n3, y = _1n3, u = _1n3, v = _0n3;
  while (a !== _0n3) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n3) / _2n3;
  let Q, S, Z;
  for (Q = P - _1n3, S = 0; Q % _2n3 === _0n3; Q /= _2n3, S++)
    ;
  for (Z = _2n3; Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n3) / _4n;
    return function tonelliFast(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n3) / _2n3;
  return function tonelliSlow(Fp2, n) {
    if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n, Q1div2);
    let b = Fp2.pow(n, Q);
    while (!Fp2.eql(b, Fp2.ONE)) {
      if (Fp2.eql(b, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b); m < r; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge = Fp2.pow(g, _1n3 << BigInt(r - m - 1));
      g = Fp2.sqr(ge);
      x = Fp2.mul(x, ge);
      b = Fp2.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n3) / _4n;
    return function sqrt3mod4(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp2, n) {
      const n2 = Fp2.mul(n, _2n3);
      const v = Fp2.pow(n2, c1);
      const nv = Fp2.mul(n, v);
      const i = Fp2.mul(Fp2.mul(nv, _2n3), v);
      const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n3)
    throw new Error("Expected power > 0");
  if (power === _0n3)
    return f.ONE;
  if (power === _1n3)
    return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n3) {
    if (power & _1n3)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n3;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE3 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE3 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes3) => {
      if (bytes3.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes3.length}`);
      return isLE3 ? bytesToNumberLE(bytes3) : bytesToNumberBE(bytes3);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE3 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE3 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE3 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// ../../node_modules/@noble/curves/esm/abstract/curve.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n4) {
        if (n & _1n4)
          p = p.add(d);
        d = d.double();
        n >>= _1n4;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window = 0; window < windows; window++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window = 0; window < windows; window++) {
        const offset = window * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, precomputesMap, n, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// ../../node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes3 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes3) => {
    const tail = bytes3.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp2.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n) {
      const I = Point2.ZERO;
      if (n === _0n5)
        return I;
      assertGE(n);
      if (n === _1n5)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d);
        if (k2 & _1n5)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n);
        point = p;
        fake = f;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point2.BASE;
      const mul = (P, a2) => a2 === _0n5 || a2 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes3(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n5 < num && num < Fp2.ORDER;
  }
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp2.toBytes(a.x);
      const cat = concatBytes;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes3) {
      const len = bytes3.length;
      const head = bytes3[0];
      const tail = bytes3.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp2.sqrt(y2);
        const isYOdd = (y & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number3) {
    const HALF = CURVE_ORDER >> _1n5;
    return number3 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h * ir);
      const u2 = modN(s * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes3) {
    const num = bytesToNumberBE(bytes3);
    const delta = bytes3.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes3) {
    return modN(bits2int(bytes3));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n5 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash4, randomBytes: randomBytes4 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash4(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes4(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n5)
        return;
      const s = modN(ik * modN(m + r * d));
      if (s === _0n5)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n5);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign4(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify2(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN(h * is);
    const u2 = modN(r * is);
    const R = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign4,
    verify: verify2,
    ProjectivePoint: Point2,
    Signature,
    utils
  };
}

// ../../node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash2 {
  constructor(hash4, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash3(hash4);
    const key = toBytes2(_key);
    this.iHash = hash4.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash4.create().update(key).digest() : key);
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash4.create();
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    exists2(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists2(this);
    bytes2(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash4, key, message) => new HMAC(hash4, key).update(message).digest();
hmac.create = (hash4, key) => new HMAC(hash4, key);

// ../../node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash4) {
  return {
    hash: hash4,
    hmac: (key, ...msgs) => hmac(hash4, key, concatBytes2(...msgs)),
    randomBytes: randomBytes2
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash4) => weierstrass({ ...curveDef, ...getHash(hash4) });
  return Object.freeze({ ...create(defHash), create });
}

// ../../node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n5) / b;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n5, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n5, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha2563);
var _0n6 = BigInt(0);
var Point = secp256k1.ProjectivePoint;

// src/secp256k1/secp256k1.ts
function compressPublicKey(publicKey) {
  const prefix = publicKey.at(0);
  if (prefix === 4) {
    const x = publicKey.slice(1, 33);
    const y = publicKey.slice(33, 65);
    const isYOdd = y[y.length - 1] & 1;
    return concatBytes(Uint8Array.of(2 + isYOdd), x);
  } else {
    return publicKey;
  }
}
function derivePublicKey(privateKey, isCompressed = true) {
  assertIsValidPrivateKey(
    "secp256k1.derivePublicKey",
    privateKey,
    isValidPrivateKey
  );
  return secp256k1.getPublicKey(privateKey, isCompressed);
}
function generatePrivateKey() {
  return secp256k1.utils.randomPrivateKey();
}
function inflatePublicKey(publicKey) {
  const prefix = publicKey.at(0);
  if (prefix !== 4) {
    const x = publicKey.slice(0, 33);
    const p = secp256k1.ProjectivePoint.fromAffine(
      secp256k1.ProjectivePoint.fromHex(Hex.of(x)).toAffine()
    );
    return p.toRawBytes(false);
  } else {
    return publicKey;
  }
}
function isValidMessageHash(hash4) {
  return hash4.length === 32;
}
function isValidPrivateKey(privateKey) {
  return secp256k1.utils.isValidPrivateKey(privateKey);
}
function randomBytes3(bytesLength) {
  return randomBytes(bytesLength);
}
function recover(messageHash, sig) {
  assertIsValidSecp256k1MessageHash(
    "secp256k1.recover",
    messageHash,
    isValidMessageHash
  );
  (0, import_sdk_errors23.assert)(
    "secp256k1.recover",
    sig.length === SIGNATURE_LENGTH,
    import_sdk_errors23.SECP256K1.INVALID_SECP256k1_SIGNATURE,
    "Invalid signature given as input. Length must be exactly 65 bytes.",
    { sig }
  );
  const recovery = sig[64];
  (0, import_sdk_errors23.assert)(
    "secp256k1.recover",
    recovery === 0 || recovery === 1,
    import_sdk_errors23.SECP256K1.INVALID_SECP256k1_SIGNATURE_RECOVERY,
    "Invalid signature recovery value. Signature bytes at position 64 must be 0 or 1.",
    { recovery }
  );
  return secp256k1.Signature.fromCompact(sig.slice(0, 64)).addRecoveryBit(recovery).recoverPublicKey(messageHash).toRawBytes(false);
}
function sign(messageHash, privateKey) {
  assertIsValidSecp256k1MessageHash(
    "secp256k1.sign",
    messageHash,
    isValidMessageHash
  );
  assertIsValidPrivateKey("secp256k1.sign", privateKey, isValidPrivateKey);
  const sig = secp256k1.sign(messageHash, privateKey);
  return concatBytes(
    numberToBytesBE(sig.r, 32),
    numberToBytesBE(sig.s, 32),
    numberToVarBytesBE(sig.recovery)
  );
}
var secp256k12 = {
  compressPublicKey,
  derivePublicKey,
  generatePrivateKey,
  inflatePublicKey,
  isValidMessageHash,
  isValidPrivateKey,
  recover,
  randomBytes: randomBytes3,
  sign
};

// src/address/address.ts
var HEX_ADDRESS_REGEX = /^0x[0-9a-f]{40}$/i;
function fromPrivateKey(privateKey) {
  return fromPublicKey(secp256k12.derivePublicKey(privateKey));
}
function fromPublicKey(publicKey) {
  return toERC55Checksum(
    Hex0x.of(
      keccak256(secp256k12.inflatePublicKey(publicKey).slice(1)).slice(12)
    )
  );
}
function isAddress(addressToVerify) {
  return HEX_ADDRESS_REGEX.test(addressToVerify);
}
function toERC55Checksum(address) {
  (0, import_sdk_errors24.assert)(
    "addressUtils.toERC55Checksum",
    isAddress(address),
    import_sdk_errors24.ADDRESS.INVALID_ADDRESS,
    "Checksum failed: Input must be a valid VeChainThor address.",
    { address }
  );
  const digits = Hex.canon(address.toLowerCase());
  const hash4 = Hex.of(keccak256(digits));
  let result = "0x";
  for (let i = 0; i < digits.length; i++) {
    if (parseInt(hash4[i], 16) >= 8) {
      result += digits[i].toUpperCase();
    } else {
      result += digits[i];
    }
  }
  return result;
}
var addressUtils = {
  fromPrivateKey,
  fromPublicKey,
  isAddress,
  toERC55Checksum
};

// src/certificate/certificate.ts
var import_fast_json_stable_stringify = __toESM(require("fast-json-stable-stringify"));
var import_sdk_errors25 = require("@vechain/sdk-errors");
function encode3(cert) {
  return txt.encode(
    // The following `fastJsonStableStringify` strips blank chars and serialize alphabetical sorted properties.
    (0, import_fast_json_stable_stringify.default)({
      purpose: cert.purpose,
      payload: {
        type: cert.payload.type,
        content: cert.payload.content
      },
      domain: cert.domain,
      timestamp: cert.timestamp,
      signer: cert.signer.toLowerCase()
    })
  );
}
function sign2(cert, privateKey) {
  return {
    ...cert,
    signature: Hex0x.of(
      secp256k12.sign(blake2b256(encode3(cert)), privateKey)
    )
  };
}
function verify(cert) {
  (0, import_sdk_errors25.assert)(
    "certificate.verify",
    cert.signature !== void 0 && cert.signature !== null,
    import_sdk_errors25.CERTIFICATE.CERTIFICATE_NOT_SIGNED,
    "Verification failed: certificate's signature is missing.",
    { cert }
  );
  (0, import_sdk_errors25.assert)(
    "certificate.verify",
    Hex0x.isValid(cert.signature, false, true),
    import_sdk_errors25.CERTIFICATE.CERTIFICATE_INVALID_SIGNATURE_FORMAT,
    "Verification failed: signature format is invalid.",
    { cert }
  );
  const sign4 = hexToBytes(Hex.canon(cert.signature));
  const hash4 = blake2b256(encode3(cert));
  const signer = addressUtils.fromPublicKey(secp256k12.recover(hash4, sign4)).toLowerCase();
  (0, import_sdk_errors25.assert)(
    "certificate.verify",
    signer === cert.signer?.toLowerCase(),
    import_sdk_errors25.CERTIFICATE.CERTIFICATE_INVALID_SIGNER,
    "Verification failed: signature does not correspond to the signer's public key.",
    { cert }
  );
}
var certificate = { encode: encode3, sign: sign2, verify };

// src/clause/clause.ts
var import_sdk_errors26 = require("@vechain/sdk-errors");
function deployContract(contractBytecode, deployParams, clauseOptions) {
  let encodedParams = "";
  if (deployParams != null) {
    encodedParams = abi.encodeParams(deployParams.types, deployParams.values).replace("0x", "");
  }
  const transactionClause = {
    to: null,
    value: 0,
    data: contractBytecode + encodedParams
  };
  if (clauseOptions?.comment !== void 0) {
    return {
      ...transactionClause,
      comment: clauseOptions.comment
    };
  } else {
    return transactionClause;
  }
}
function functionInteraction(contractAddress, functionFragment, args, value = 0, clauseOptions) {
  const transactionClause = {
    to: contractAddress,
    value,
    data: new abi.Function(functionFragment).encodeInput(args)
  };
  if (clauseOptions !== void 0) {
    return {
      ...transactionClause,
      comment: clauseOptions.comment,
      abi: clauseOptions.includeABI === true ? functionFragment.format("json") : void 0
    };
  } else {
    return transactionClause;
  }
}
function transferToken(tokenAddress, recipientAddress, amount, clauseOptions) {
  try {
    return functionInteraction(
      tokenAddress,
      coder.createInterface(VIP180_ABI).getFunction("transfer"),
      [recipientAddress, BigInt(amount)],
      void 0,
      clauseOptions
    );
  } catch (error) {
    throw (0, import_sdk_errors26.buildError)(
      "transferToken",
      import_sdk_errors26.DATA.INVALID_DATA_TYPE,
      `Invalid 'amount' parameter. Expected an integer but received ${amount}.`
    );
  }
}
function transferVET(recipientAddress, amount, clauseOptions) {
  try {
    const bnAmount = BigInt(amount);
    (0, import_sdk_errors26.assert)(
      "transferVET",
      bnAmount > 0,
      import_sdk_errors26.DATA.INVALID_DATA_TYPE,
      `Invalid 'amount' parameter. Expected a positive amount but received ${amount}.`
    );
    const transactionClause = {
      to: recipientAddress,
      value: `0x${BigInt(amount).toString(16)}`,
      data: "0x"
    };
    if (clauseOptions?.comment !== void 0) {
      return {
        ...transactionClause,
        comment: clauseOptions.comment
      };
    } else {
      return transactionClause;
    }
  } catch (error) {
    throw (0, import_sdk_errors26.buildError)(
      "transferVET",
      import_sdk_errors26.DATA.INVALID_DATA_TYPE,
      `Invalid 'amount' parameter. Expected an integer but received ${amount}.`
    );
  }
}
function transferNFT(contractAddress, senderAddress, recipientAddress, tokenId, clauseOptions) {
  (0, import_sdk_errors26.assert)(
    "transferNFT",
    tokenId !== "",
    import_sdk_errors26.DATA.INVALID_DATA_TYPE,
    `Invalid 'tokenId' parameter. Expected an id but received ${tokenId}.`
  );
  (0, import_sdk_errors26.assert)(
    "transferNFT",
    addressUtils.isAddress(contractAddress),
    import_sdk_errors26.DATA.INVALID_DATA_TYPE,
    `Invalid 'contractAddress' parameter. Expected a contract address but received ${contractAddress}.`
  );
  const functionFragment = coder.createInterface(ERC721_ABI).getFunction("transferFrom");
  return functionInteraction(
    contractAddress,
    functionFragment,
    [senderAddress, recipientAddress, tokenId],
    void 0,
    clauseOptions
  );
}
var clauseBuilder = {
  deployContract,
  functionInteraction,
  transferToken,
  transferVET,
  transferNFT
};

// src/hdnode/hdnode.ts
var n_bip32 = __toESM(require("@scure/bip32"));
var n_bip39 = __toESM(require("@scure/bip39"));
var import_sdk_errors27 = require("@vechain/sdk-errors");

// ../../node_modules/@scure/base/lib/esm/index.js
// @__NO_SIDE_EFFECTS__
function assertNumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`Wrong integer: ${n}`);
}
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
// @__NO_SIDE_EFFECTS__
function chain(...args) {
  const id = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode4 = args.map((x) => x.encode).reduceRight(wrap, id);
  const decode4 = args.map((x) => x.decode).reduce(wrap, id);
  return { encode: encode4, decode: decode4 };
}
// @__NO_SIDE_EFFECTS__
function alphabet(alphabet2) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i) => {
        /* @__PURE__ */ assertNumber(i);
        if (i < 0 || i >= alphabet2.length)
          throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet2.length})`);
        return alphabet2[i];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet2.indexOf(letter);
        if (index === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
        return index;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join(separator = "") {
  if (typeof separator !== "string")
    throw new Error("join separator should be string");
  return {
    encode: (from) => {
      if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
        throw new Error("join.encode input should be array of strings");
      for (let i of from)
        if (typeof i !== "string")
          throw new Error(`join.encode: non-string input=${i}`);
      return from.join(separator);
    },
    decode: (to) => {
      if (typeof to !== "string")
        throw new Error("join.decode input should be string");
      return to.split(separator);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
  if (!Array.isArray(data))
    throw new Error("convertRadix: data should be array");
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach((d) => {
    /* @__PURE__ */ assertNumber(d);
    if (d < 0 || d >= from)
      throw new Error(`Wrong integer: ${d}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i = pos; i < digits.length; i++) {
      const digit = digits[i];
      const digitBase = from * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
        throw new Error("convertRadix: carry overflow");
      }
      carry = digitBase % to;
      const rounded = Math.floor(digitBase / to);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
// @__NO_SIDE_EFFECTS__
function radix(num) {
  /* @__PURE__ */ assertNumber(num);
  return {
    encode: (bytes3) => {
      if (!isBytes(bytes3))
        throw new Error("radix.encode input should be Uint8Array");
      return /* @__PURE__ */ convertRadix(Array.from(bytes3), 2 ** 8, num);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(/* @__PURE__ */ convertRadix(digits, num, 2 ** 8));
    }
  };
}
var genBase58 = (abc) => /* @__PURE__ */ chain(/* @__PURE__ */ radix(58), /* @__PURE__ */ alphabet(abc), /* @__PURE__ */ join(""));
var base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

// src/hdnode/hdnode.ts
function fromMnemonic(words, path = VET_DERIVATION_PATH) {
  let master;
  try {
    master = n_bip32.HDKey.fromMasterSeed(
      n_bip39.mnemonicToSeedSync(words.join(" ").toLowerCase())
    );
  } catch (error) {
    throw (0, import_sdk_errors27.buildError)(
      "HDNode.fromMnemonic",
      import_sdk_errors27.HDNODE.INVALID_HDNODE_MNEMONICS,
      "Invalid mnemonic words."
    );
  }
  try {
    return master.derive(path);
  } catch (error) {
    throw (0, import_sdk_errors27.buildError)(
      "HDNode.fromMnemonic",
      import_sdk_errors27.HDNODE.INVALID_HDNODE_DERIVATION_PATH,
      error.message,
      { path },
      error
    );
  }
}
function fromPrivateKey2(privateKey, chainCode) {
  if (privateKey.length === 32) {
    const header = concatBytes(
      X_PRIV_PREFIX,
      chainCode,
      Uint8Array.of(0),
      privateKey
    );
    privateKey.fill(0);
    const checksum = sha2562(sha2562(header)).subarray(0, 4);
    const expandedPrivateKey = concatBytes(header, checksum);
    try {
      return n_bip32.HDKey.fromExtendedKey(
        base58.encode(expandedPrivateKey)
      );
    } catch (error) {
      throw (0, import_sdk_errors27.buildError)(
        "HDNode.fromPrivateKey",
        import_sdk_errors27.HDNODE.INVALID_HDNODE_CHAIN_CODE,
        error.message,
        { chainCode }
      );
    }
  }
  privateKey.fill(0);
  throw (0, import_sdk_errors27.buildError)(
    "HDNode.fromPrivateKey",
    import_sdk_errors27.HDNODE.INVALID_HDNODE_PRIVATE_KEY,
    "Invalid private key. Length must be exactly 32 bytes."
  );
}
function fromPublicKey2(publicKey, chainCode) {
  if (chainCode.length === 32) {
    const header = concatBytes(
      X_PUB_PREFIX,
      chainCode,
      secp256k12.compressPublicKey(publicKey)
    );
    const checksum = sha2562(sha2562(header)).subarray(0, 4);
    const expandedPublicKey = concatBytes(header, checksum);
    try {
      return n_bip32.HDKey.fromExtendedKey(
        base58.encode(expandedPublicKey)
      );
    } catch (error) {
      throw (0, import_sdk_errors27.buildError)(
        "HDNode.fromPublicKey",
        import_sdk_errors27.HDNODE.INVALID_HDNODE_PUBLIC_KEY,
        "Invalid public key.",
        { publicKey },
        error
      );
    }
  }
  throw (0, import_sdk_errors27.buildError)(
    "HDNode.fromPublicKey",
    import_sdk_errors27.HDNODE.INVALID_HDNODE_CHAIN_CODE,
    "Invalid chain code. Length must be exactly 32 bytes.",
    { chainCode }
  );
}
var HDNode = {
  fromMnemonic,
  fromPrivateKey: fromPrivateKey2,
  fromPublicKey: fromPublicKey2
};

// src/keystore/keystore.ts
var import_sdk_logging = require("@vechain/sdk-logging");

// src/keystore/cryptography/ethers/keystore.ts
var import_ethers4 = require("ethers");
var import_sdk_errors28 = require("@vechain/sdk-errors");

// src/keystore/cryptography/ethers/const/keystore.ts
var SCRYPT_PARAMS = {
  N: 131072,
  r: 8,
  p: 1
};

// src/keystore/cryptography/ethers/keystore.ts
async function encrypt(privateKey, password) {
  const derivePublicKey2 = secp256k12.derivePublicKey(privateKey);
  const deriveAddress2 = addressUtils.fromPublicKey(
    Buffer.from(derivePublicKey2)
  );
  const keystoreAccount = {
    address: deriveAddress2,
    privateKey: Hex0x.of(privateKey)
  };
  const encryptOptions = {
    scrypt: {
      N: SCRYPT_PARAMS.N,
      r: SCRYPT_PARAMS.r,
      p: SCRYPT_PARAMS.p
    }
  };
  const keystoreJsonString = await import_ethers4.ethers.encryptKeystoreJson(
    keystoreAccount,
    password,
    encryptOptions
  );
  return JSON.parse(keystoreJsonString);
}
async function decrypt(keystore4, password) {
  (0, import_sdk_errors28.assert)(
    "keystore.decrypt",
    isValid(keystore4),
    import_sdk_errors28.KEYSTORE.INVALID_KEYSTORE,
    "Invalid keystore. Ensure the keystore is properly formatted and contains the necessary data.",
    {
      keystore: keystore4
    }
  );
  try {
    return await import_ethers4.ethers.decryptKeystoreJson(
      (0, import_sdk_errors28.stringifyData)(keystore4),
      password
    );
  } catch (e) {
    throw (0, import_sdk_errors28.buildError)(
      "keystore.decrypt",
      import_sdk_errors28.KEYSTORE.INVALID_PASSWORD,
      "Decryption failed: Invalid Password for the given keystore.",
      {
        keystore: keystore4,
        password
      },
      e
    );
  }
}
function isValid(keystore4) {
  return import_ethers4.ethers.isKeystoreJson((0, import_sdk_errors28.stringifyData)(keystore4));
}
var keystore = { encrypt, decrypt, isValid };

// src/keystore/cryptography/experimental/keystore.ts
var import_sdk_errors29 = require("@vechain/sdk-errors");
var import_aes = require("@noble/ciphers/aes");

// ../../node_modules/@noble/hashes/esm/hmac.js
var HMAC2 = class extends Hash {
  constructor(hash4, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    assert_default.hash(hash4);
    const key = toBytes(_key);
    this.iHash = hash4.create();
    if (typeof this.iHash.update !== "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash4.create().update(key).digest() : key);
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash4.create();
    for (let i = 0; i < pad2.length; i++)
      pad2[i] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    assert_default.exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac2 = (hash4, key, message) => new HMAC2(hash4, key).update(message).digest();
hmac2.create = (hash4, key) => new HMAC2(hash4, key);

// ../../node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash4, _password, _salt, _opts) {
  assert_default.hash(hash4);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  assert_default.number(c);
  assert_default.number(dkLen);
  assert_default.number(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac2.create(hash4, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
}
function pbkdf2(hash4, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash4, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// ../../node_modules/@noble/hashes/esm/scrypt.js
var rotl = (a, b) => a << b | a >>> 32 - b;
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0; i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0; i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0; i < r; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
}
function scryptInit(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  assert_default.number(N);
  assert_default.number(r);
  assert_default.number(p);
  assert_default.number(dkLen);
  assert_default.number(asyncTick);
  assert_default.number(maxmem);
  if (onProgress !== void 0 && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
function scrypt(password, salt, opts) {
  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0; pi < p; pi++) {
    const Pi = blockSize32 * pi;
    for (let i = 0; i < blockSize32; i++)
      V[i] = B32[Pi + i];
    for (let i = 0, pos = 0; i < N - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    }
    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
    blockMixCb();
    for (let i = 0; i < N; i++) {
      const j = B32[Pi + blockSize32 - 16] % N;
      for (let k = 0; k < blockSize32; k++)
        tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi, r);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}

// src/keystore/cryptography/experimental/keystore.ts
var KEYSTORE_CRYPTO_CIPHER = "aes-128-ctr";
var KEYSTORE_CRYPTO_PARAMS_DKLEN = 32;
var KEYSTORE_CRYPTO_KDF = "scrypt";
var KEYSTORE_VERSION = 3;
var SCRYPT_PARAMS2 = {
  N: 131072,
  r: 8,
  p: 1
};
function decodeScryptParams(keystore4) {
  const salt = hexToBytes(keystore4.crypto.kdfparams.salt);
  const N = keystore4.crypto.kdfparams.n;
  const r = keystore4.crypto.kdfparams.r;
  const p = keystore4.crypto.kdfparams.p;
  (0, import_sdk_errors29.assert)(
    "keystore.decrypt",
    N > 0 && (N & N - 1) === 0,
    import_sdk_errors29.KEYSTORE.INVALID_KEYSTORE,
    "Decryption failed: invalid  keystore.crypto.kdfparams.n parameter.",
    { keystore: keystore4 }
  );
  (0, import_sdk_errors29.assert)(
    "keystore.decrypt",
    r > 0 && p > 0,
    import_sdk_errors29.KEYSTORE.INVALID_KEYSTORE,
    "Decryption failed: both keystore.crypto.kdfparams.r or keystore.crypto.kdfparams.p parameter must be > 0.",
    { keystore: keystore4 }
  );
  const dkLen = keystore4.crypto.kdfparams.dklen;
  (0, import_sdk_errors29.assert)(
    "keystore.decrypt",
    dkLen === KEYSTORE_CRYPTO_PARAMS_DKLEN,
    import_sdk_errors29.KEYSTORE.INVALID_KEYSTORE,
    `Decryption failed: keystore.crypto.kdfparams.dklen parameter must be ${KEYSTORE_CRYPTO_PARAMS_DKLEN}`,
    { keystore: keystore4 }
  );
  return {
    N,
    dkLen: KEYSTORE_CRYPTO_PARAMS_DKLEN,
    name: KEYSTORE_CRYPTO_KDF,
    p,
    r,
    salt
  };
}
function encodeScryptParams(options) {
  const salt = options.salt ?? secp256k12.randomBytes(KEYSTORE_CRYPTO_PARAMS_DKLEN);
  let N = SCRYPT_PARAMS2.N;
  let r = SCRYPT_PARAMS2.r;
  let p = SCRYPT_PARAMS2.p;
  if (options.scrypt != null) {
    if (options.scrypt.N != null) {
      N = options.scrypt.N;
    }
    if (options.scrypt.r != null) {
      r = options.scrypt.r;
    }
    if (options.scrypt.p != null) {
      p = options.scrypt.p;
    }
  }
  (0, import_sdk_errors29.assert)(
    "keystore.encrypt",
    N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0),
    import_sdk_errors29.KEYSTORE.INVALID_KEYSTORE,
    "Encryption failed: invalid options.scrypt.N parameter.",
    { options }
  );
  (0, import_sdk_errors29.assert)(
    "keystore.encrypt",
    r > 0 && Number.isSafeInteger(r),
    import_sdk_errors29.KEYSTORE.INVALID_KEYSTORE,
    "Encryption failed: invalid options.scrypt.r parameter.",
    { options }
  );
  (0, import_sdk_errors29.assert)(
    "keystore.encrypt",
    p > 0 && Number.isSafeInteger(p),
    import_sdk_errors29.KEYSTORE.INVALID_KEYSTORE,
    "Encryption failed: invalid options.scrypt.p parameter.",
    { options }
  );
  return {
    name: KEYSTORE_CRYPTO_KDF,
    dkLen: KEYSTORE_CRYPTO_PARAMS_DKLEN,
    N,
    p,
    r,
    salt
  };
}
function encrypt2(privateKey, password) {
  return encryptKeystore(privateKey, password, {
    scrypt: {
      N: SCRYPT_PARAMS2.N,
      r: SCRYPT_PARAMS2.r,
      p: SCRYPT_PARAMS2.p
    }
  });
}
function encryptKeystore(privateKey, password, options) {
  try {
    const kdf = encodeScryptParams(options);
    const key = scrypt(password, kdf.salt, {
      N: kdf.N,
      r: kdf.r,
      p: kdf.p,
      dkLen: kdf.dkLen
    });
    const iv = options.iv ?? secp256k12.randomBytes(16);
    (0, import_sdk_errors29.assert)(
      "keystore.encrypt",
      iv.length === 16,
      import_sdk_errors29.KEYSTORE.INVALID_KEYSTORE,
      "Encryption failed: invalid options.iv length.",
      { iv }
    );
    const uuidRandom = options.uuid ?? secp256k12.randomBytes(16);
    (0, import_sdk_errors29.assert)(
      "keystore.encrypt",
      uuidRandom.length === 16,
      import_sdk_errors29.KEYSTORE.INVALID_KEYSTORE,
      "Encryption failed: options.uuid length must be 16",
      { iv }
    );
    const macPrefix = key.slice(16, 32);
    const ciphertext = (0, import_aes.ctr)(key.slice(0, 16), iv).encrypt(privateKey);
    return {
      address: Hex.canon(
        addressUtils.fromPublicKey(
          secp256k12.derivePublicKey(privateKey)
        )
      ),
      crypto: {
        cipher: KEYSTORE_CRYPTO_CIPHER,
        cipherparams: {
          iv: Hex.of(iv)
        },
        ciphertext: Hex.of(ciphertext),
        kdf: "scrypt",
        kdfparams: {
          dklen: KEYSTORE_CRYPTO_PARAMS_DKLEN,
          n: kdf.N,
          p: kdf.p,
          r: kdf.r,
          salt: Hex.of(kdf.salt)
        },
        // Compute the message authentication code, used to check the password.
        mac: Hex.of(
          keccak256(concatBytes(macPrefix, ciphertext))
        )
      },
      id: uuidV4(uuidRandom),
      version: KEYSTORE_VERSION
    };
  } finally {
    privateKey.fill(0);
    password.fill(0);
  }
}
function decrypt2(keystore4, password) {
  return decryptKeystore(keystore4, password);
}
function decryptKeystore(keystore4, password) {
  try {
    (0, import_sdk_errors29.assert)(
      "keystore.decrypt",
      keystore4.crypto.cipher.toLowerCase() === KEYSTORE_CRYPTO_CIPHER,
      import_sdk_errors29.KEYSTORE.INVALID_KEYSTORE,
      "Decryption failed: unsupported crypto cipher algorithm.",
      { keystore: keystore4 }
    );
    (0, import_sdk_errors29.assert)(
      "keystore.decrypt",
      keystore4.crypto.kdf.toLowerCase() === KEYSTORE_CRYPTO_KDF,
      import_sdk_errors29.KEYSTORE.INVALID_KEYSTORE,
      "Decryption failed: unsupported crypto key derivation function.",
      { keystore: keystore4 }
    );
    (0, import_sdk_errors29.assert)(
      "keystore.decrypt",
      keystore4.version === KEYSTORE_VERSION,
      import_sdk_errors29.KEYSTORE.INVALID_KEYSTORE,
      "Decryption failed: unsupported keystore version.",
      { keystore: keystore4 }
    );
    const kdf = decodeScryptParams(keystore4);
    const key = scrypt(password, kdf.salt, {
      N: kdf.N,
      r: kdf.r,
      p: kdf.p,
      dkLen: kdf.dkLen
    });
    const ciphertext = hexToBytes(keystore4.crypto.ciphertext);
    (0, import_sdk_errors29.assert)(
      "keystore.decrypt",
      keystore4.crypto.mac === Hex.of(
        keccak256(
          concatBytes(key.slice(16, 32), ciphertext)
        )
      ),
      import_sdk_errors29.KEYSTORE.INVALID_PASSWORD,
      "Decryption failed: invalid password for the given keystore."
    );
    const privateKey = (0, import_aes.ctr)(
      key.slice(0, 16),
      hexToBytes(keystore4.crypto.cipherparams.iv)
    ).decrypt(ciphertext);
    const address = addressUtils.fromPrivateKey(privateKey);
    if (keystore4.address !== "") {
      (0, import_sdk_errors29.assert)(
        "keystore.decrypt",
        address === addressUtils.toERC55Checksum(Hex0x.canon(keystore4.address)),
        import_sdk_errors29.KEYSTORE.INVALID_KEYSTORE,
        "Decryption failed: address/password mismatch.",
        { keystore: keystore4 }
      );
    }
    return {
      address,
      // @note: Convert the private key to a string to be compatible with ethers
      privateKey: Hex0x.of(privateKey)
    };
  } finally {
    password.fill(0);
  }
}
function isValid2(keystore4) {
  try {
    const copy = JSON.parse((0, import_sdk_errors29.stringifyData)(keystore4));
    if (copy.crypto.cipher.toLowerCase() === KEYSTORE_CRYPTO_CIPHER && copy.crypto.kdf.toLowerCase() === KEYSTORE_CRYPTO_KDF && copy.version === KEYSTORE_VERSION) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function uuidV4(bytes3) {
  bytes3[6] = bytes3[6] & 15 | 64;
  bytes3[8] = bytes3[8] & 63 | 128;
  const value = Hex.of(bytes3);
  return [
    value.substring(0, 8),
    value.substring(8, 12),
    value.substring(12, 16),
    value.substring(16, 20),
    value.substring(20, 32)
  ].join("-");
}
var keystore2 = { decrypt: decrypt2, encrypt: encrypt2, isValid: isValid2 };

// src/keystore/keystore.ts
var EXPERIMENTAL_CRYPTOGRAPHY = false;
function useExperimentalCryptography(experimentalCryptography) {
  EXPERIMENTAL_CRYPTOGRAPHY = experimentalCryptography;
}
async function encrypt3(privateKey, password) {
  if (EXPERIMENTAL_CRYPTOGRAPHY)
    (0, import_sdk_logging.VeChainSDKLogger)("warning").log({
      title: `Experimental cryptography`,
      messages: [
        `Remember, you are using an experimental cryptography library.`,
        "functions: keystore.encrypt"
      ]
    });
  return EXPERIMENTAL_CRYPTOGRAPHY ? keystore2.encrypt(privateKey, txt.encode(password)) : await keystore.encrypt(privateKey, password);
}
async function decrypt3(keystore4, password) {
  if (EXPERIMENTAL_CRYPTOGRAPHY)
    (0, import_sdk_logging.VeChainSDKLogger)("warning").log({
      title: `Experimental cryptography`,
      messages: [
        `Remember, you are using an experimental cryptography library.`,
        "functions: keystore.decrypt"
      ]
    });
  return EXPERIMENTAL_CRYPTOGRAPHY ? keystore2.decrypt(keystore4, txt.encode(password)) : await keystore.decrypt(keystore4, password);
}
function isValid3(keystore4) {
  if (EXPERIMENTAL_CRYPTOGRAPHY)
    (0, import_sdk_logging.VeChainSDKLogger)("warning").log({
      title: `Experimental cryptography`,
      messages: [
        `Remember, you are using an experimental cryptography library.`,
        "functions: keystore.isValid"
      ]
    });
  return EXPERIMENTAL_CRYPTOGRAPHY ? keystore2.isValid(keystore4) : keystore.isValid(keystore4);
}
var keystore3 = { encrypt: encrypt3, decrypt: decrypt3, isValid: isValid3, useExperimentalCryptography };

// src/mnemonic/mnemonic.ts
var bip39 = __toESM(require("@scure/bip39"));
var import_sdk_errors30 = require("@vechain/sdk-errors");
var import_english = require("@scure/bip39/wordlists/english");
function deriveAddress(words, path = "m/0") {
  const root = HDNode.fromMnemonic(words);
  try {
    return addressUtils.fromPublicKey(
      root.derive(path).publicKey
    );
  } catch (error) {
    throw (0, import_sdk_errors30.buildError)(
      "HDNode.fromMnemonic",
      import_sdk_errors30.HDNODE.INVALID_HDNODE_DERIVATION_PATH,
      "Invalid derivation path.",
      { path },
      error
    );
  }
}
function derivePrivateKey(words, path = "m/0") {
  const root = HDNode.fromMnemonic(words);
  try {
    return root.derive(path).privateKey;
  } catch (error) {
    throw (0, import_sdk_errors30.buildError)(
      "HDNode.fromMnemonic",
      import_sdk_errors30.HDNODE.INVALID_HDNODE_DERIVATION_PATH,
      "Invalid derivation path.",
      { path },
      error
    );
  }
}
function generate(wordlistSize, randomGenerator) {
  (0, import_sdk_errors30.assert)(
    "mnemonic.generate",
    wordlistSize === void 0 || MNEMONIC_WORDLIST_ALLOWED_SIZES.includes(wordlistSize),
    import_sdk_errors30.HDNODE.INVALID_HDNODE_MNEMONICS,
    "Invalid `wordlistSize` given as input. Allowed sizes are 12, 15, 18, 21, 24 words.",
    { wordlistSize }
  );
  randomGenerator = // Set random generator.
  randomGenerator ?? // Default random generator.
  ((numberOfBytes) => secp256k12.randomBytes(numberOfBytes));
  const wordlistSizeToUse = wordlistSize ?? 12;
  return bip39.entropyToMnemonic(
    randomGenerator(
      wordlistSizeToUse / 3 * 4
    ),
    import_english.wordlist
  ).split(" ");
}
function isValid4(words) {
  return bip39.validateMnemonic(words.join(" "), import_english.wordlist);
}
var mnemonic = {
  deriveAddress,
  derivePrivateKey,
  generate,
  isValid: isValid4
};

// src/transaction/transaction.ts
var import_sdk_errors31 = require("@vechain/sdk-errors");
var Transaction = class _Transaction {
  /**
   * Transaction body. It represents the body of the transaction.
   *
   * @note It is better to take it as a read-only property in order to avoid any external modification.
   */
  body;
  /**
   * Transaction signature. It represents the signature of the transaction.
   *
   * @note It is better to take it as a read-only property in order to avoid any external modification.
   */
  signature;
  /**
   * Constructor with parameters.
   * This constructor creates a transaction immutable object.
   *
   * @throws{TransactionBodyError, InvalidSecp256k1SignatureError}
   * @param body - Transaction body
   * @param signature - Optional signature for the transaction
   */
  constructor(body, signature) {
    (0, import_sdk_errors31.assert)(
      "Transaction constructor",
      _Transaction.isValidBody(body),
      import_sdk_errors31.TRANSACTION.INVALID_TRANSACTION_BODY,
      "Invalid transaction body. Ensure all required fields are correctly formatted and present.",
      { body }
    );
    this.body = body;
    if (signature !== void 0) {
      (0, import_sdk_errors31.assert)(
        "Transaction constructor",
        this._isSignatureValid(signature),
        import_sdk_errors31.SECP256K1.INVALID_SECP256k1_SIGNATURE,
        "Invalid transaction signature. Ensure it is correctly formatted.",
        { signature }
      );
      this.signature = signature;
    }
  }
  // ********** PUBLIC GET ONLY FUNCTIONS **********
  /**
   * Calculate intrinsic gas required for this transaction
   *
   * @returns Intrinsic gas required for this transaction
   */
  get intrinsicGas() {
    return TransactionUtils.intrinsicGas(this.body.clauses);
  }
  /**
   * Determines whether the transaction is delegated.
   *
   * @returns If transaction is delegated or not
   */
  get isDelegated() {
    return this._isDelegated(this.body);
  }
  /**
   * Get transaction delegator address from signature.
   *
   * @throws{TransactionDelegationError, TransactionNotSignedError}
   * @returns Transaction delegator address
   */
  get delegator() {
    (0, import_sdk_errors31.assert)(
      "delegator",
      this.isDelegated,
      import_sdk_errors31.TRANSACTION.INVALID_DELEGATION,
      "Transaction is not delegated. Delegator information is unavailable."
    );
    assertCantGetFieldOnUnsignedTransaction("delegator", this, "delegator");
    const signatureSliced = this.signature.subarray(
      65,
      this.signature?.length
    );
    const delegatorPublicKey = secp256k12.recover(
      this.getSignatureHash(this.origin),
      signatureSliced
    );
    return addressUtils.fromPublicKey(Buffer.from(delegatorPublicKey));
  }
  /**
   * Determines whether the transaction is signed or not.
   *
   * @returns If transaction is signed or not
   */
  get isSigned() {
    return this.signature !== void 0;
  }
  /**
   * Computes the signature hash for the transaction. The output is based on
   * the presence of the 'delegateFor' parameter.
   *
   * @param delegateFor - Optional address of the delegator.
   * @returns The computed hash.
   *
   * Mainly:
   *  - No 'delegateFor': return txHash
   * - 'delegateFor' return txHash +  hash('delegateFor' address)
   *
   * @remarks
   * delegateFor is used to sign a transaction on behalf of another account.
   * In fact when the delegator sign the transaction, delegator will add the address
   * of who send the transaction to sign (in this case the 'delegateFor' address parameter)
   *
   * @example
   * A is transaction origin
   * B is the delegator
   * TX is the transaction
   *
   * A sends a TX (signed by A) to B to who add his signature to TX using delegateFor parameter (that is A address)
   * on signing hash of TX computation.
   *
   * Mathematically:
   *
   * ```
   * final_signature = concat_buffer(
   *      sign(TX.signingHash(), A.privateKey),
   *      sign(TX.signingHash(A.address), B.privateKey)
   * )
   * ```
   *
   * Where:
   *
   * ```
   * TX.signatureHash() = blake2b256(TX.encoded)
   * TX.signingHash(A.address) = blake2b256(
   *      concat(
   *              blake2b256(TX.encoded),
   *              A.address
   *             )
   * )
   * ```
   *
   * @throws{InvalidAddressError}
   * @param delegateFor - Address of the delegator
   * @returns Signing hash of the transaction
   */
  getSignatureHash(delegateFor) {
    (0, import_sdk_errors31.assert)(
      "getSignatureHash",
      delegateFor === void 0 || addressUtils.isAddress(delegateFor),
      import_sdk_errors31.ADDRESS.INVALID_ADDRESS,
      "Invalid address given as input as delegateFor parameter. Ensure it is a valid address.",
      { delegateFor }
    );
    const transactionHash = blake2b256(this._encode(false));
    if (delegateFor !== void 0) {
      return Buffer.from(
        blake2b256(
          Buffer.concat([
            Buffer.from(transactionHash),
            Buffer.from(delegateFor.slice(2), "hex")
          ])
        )
      );
    }
    return Buffer.from(transactionHash);
  }
  /**
   * Encode a transaction
   *
   * @returns The transaction encoded
   */
  get encoded() {
    return this._encode(this.isSigned);
  }
  /**
   * Get transaction origin address from signature.
   *
   * @throws{TransactionNotSignedError}
   * @returns Transaction origin
   */
  get origin() {
    assertCantGetFieldOnUnsignedTransaction("origin", this, "origin");
    const signatureSliced = this.signature.subarray(0, 65);
    const originPublicKey = secp256k12.recover(
      this.getSignatureHash(),
      signatureSliced
    );
    return addressUtils.fromPublicKey(Buffer.from(originPublicKey));
  }
  /**
   * Get transaction ID from signature.
   *
   * @throws{TransactionNotSignedError}
   * @returns Transaction ID
   */
  get id() {
    assertCantGetFieldOnUnsignedTransaction("id", this, "id");
    return blake2b256(
      Buffer.concat([
        this.getSignatureHash(),
        Buffer.from(this.origin.slice(2), "hex")
      ]),
      "hex"
    );
  }
  // ********** INTERNAL PRIVATE FUNCTIONS **********
  /**
   * Internal function to check if transaction is delegated or not.
   * This function is used to check directly the transaction body.
   * @private
   *
   * @param body Transaction body to check
   * @returns Weather the transaction is delegated or not
   */
  _isDelegated(body) {
    const reserved = body.reserved ?? {};
    const features = reserved.features ?? 0;
    return (features & 1) === 1;
  }
  /**
   * Internal function to check if signature is valid or not.
   * This function is used to check directly the signature.
   * @private
   *
   * @param signature Signature to check
   * @returns Weather the signature is valid or not
   */
  _isSignatureValid(signature) {
    const expectedSignatureLength = this._isDelegated(this.body) ? SIGNATURE_LENGTH * 2 : SIGNATURE_LENGTH;
    return signature.length === expectedSignatureLength;
  }
  /**
   * Encodes the reserved field to ensure it exists in every encoding.
   *
   * Due to the fact that reserved field is optional in TransactionBody,
   * BUT mandatory in RLPProfiler, we need to have it in every encoding.
   * Fot this reason this function is needed.
   * @private
   *
   * @returns Encoding of reserved field
   */
  _encodeReservedField() {
    const reserved = this.body.reserved ?? {};
    const featuresKind = TRANSACTION_FEATURES_KIND.kind;
    const featuresList = [
      featuresKind.data(reserved.features ?? 0, TRANSACTION_FEATURES_KIND.name).encode(),
      ...reserved.unused ?? []
    ];
    while (featuresList.length > 0) {
      if (featuresList[featuresList.length - 1].length === 0) {
        featuresList.pop();
      } else {
        break;
      }
    }
    return featuresList;
  }
  /**
   * Make the RLP encoding of a transaction body.
   * @private
   *
   * @param body Body to encode
   * @param isSigned If transaction is signed or not
   * @returns RLP encoding of transaction body
   */
  _lowLevelEncodeTransactionBodyWithRLP(body, isSigned) {
    if (isSigned) {
      return SIGNED_TRANSACTION_RLP.encodeObject({
        ...body,
        signature: this.signature
      });
    }
    return UNSIGNED_TRANSACTION_RLP.encodeObject(body);
  }
  /**
   * Private utility function to encode a transaction.
   * @private
   *
   * @param isSigned If transaction is signed or not (needed to determine if encoding with SIGNED_TRANSACTION_RLP or UNSIGNED_TRANSACTION_RLP)
   * @returns Encoding of transaction
   */
  _encode(isSigned) {
    return this._lowLevelEncodeTransactionBodyWithRLP(
      {
        // Existing body (clauses, gasPrice, gasLimit, nonce, chainTag, blockRef, expiration, ... AND OPTIONALLY reserved field)
        ...this.body,
        /*
         * @note: this.body.clauses is already an array.
         * But TypeScript doesn't know that and for this reason we need to cast it.
         * Otherwise encodeObject will throw an error.
         */
        clauses: this.body.clauses,
        // New reserved field
        reserved: this._encodeReservedField()
      },
      isSigned
    );
  }
  /**
   * utility function to check transaction body validity.
   *
   * @param body Transaction body to check
   */
  static isValidBody(body) {
    return (
      // Chain tag
      body.chainTag !== void 0 && body.chainTag >= 0 && body.chainTag <= 255 && // Block reference
      body.blockRef !== void 0 && Hex0x.isValid(body.blockRef) && Buffer.from(body.blockRef.slice(2), "hex").length === BLOCK_REF_LENGTH && // Expiration
      body.expiration !== void 0 && // Clauses
      body.clauses !== void 0 && // Gas price coef
      body.gasPriceCoef !== void 0 && // Gas
      body.gas !== void 0 && // Depends on
      body.dependsOn !== void 0 && // Nonce
      body.nonce !== void 0
    );
  }
};

// src/transaction/handlers/sign.ts
var import_sdk_errors32 = require("@vechain/sdk-errors");
function sign3(transactionBody, signerPrivateKey) {
  assertIsValidTransactionSigningPrivateKey(
    "sign",
    signerPrivateKey,
    secp256k12.isValidPrivateKey
  );
  const transactionToSign = new Transaction(transactionBody);
  (0, import_sdk_errors32.assert)(
    "sign",
    !transactionToSign.isDelegated,
    import_sdk_errors32.TRANSACTION.INVALID_DELEGATION,
    "Transaction is delegated. Use signWithDelegator method instead.",
    { transactionBody }
  );
  const signature = secp256k12.sign(
    transactionToSign.getSignatureHash(),
    signerPrivateKey
  );
  return new Transaction(transactionBody, Buffer.from(signature));
}
function signWithDelegator(transactionBody, signerPrivateKey, delegatorPrivateKey) {
  assertIsValidTransactionSigningPrivateKey(
    "signWithDelegator",
    signerPrivateKey,
    secp256k12.isValidPrivateKey,
    "signer"
  );
  assertIsValidTransactionSigningPrivateKey(
    "signWithDelegator",
    delegatorPrivateKey,
    secp256k12.isValidPrivateKey,
    "delegator"
  );
  const transactionToSign = new Transaction(transactionBody);
  (0, import_sdk_errors32.assert)(
    "signWithDelegator",
    transactionToSign.isDelegated,
    import_sdk_errors32.TRANSACTION.INVALID_DELEGATION,
    "Transaction is not delegated. Use sign method instead.",
    { transactionToSign }
  );
  const transactionHash = transactionToSign.getSignatureHash();
  const delegatedHash = transactionToSign.getSignatureHash(
    addressUtils.fromPublicKey(
      Buffer.from(secp256k12.derivePublicKey(signerPrivateKey))
    )
  );
  const signature = Buffer.concat([
    secp256k12.sign(transactionHash, signerPrivateKey),
    secp256k12.sign(delegatedHash, delegatorPrivateKey)
  ]);
  return new Transaction(transactionBody, signature);
}

// src/transaction/handlers/decode.ts
var import_sdk_errors33 = require("@vechain/sdk-errors");
function decode3(rawTransaction, isSigned) {
  const decoder = isSigned ? SIGNED_TRANSACTION_RLP : UNSIGNED_TRANSACTION_RLP;
  const decodedRLPBody = decoder.decodeObject(
    rawTransaction
  );
  const bodyWithoutReservedField = {
    blockRef: decodedRLPBody.blockRef,
    chainTag: decodedRLPBody.chainTag,
    clauses: decodedRLPBody.clauses,
    dependsOn: decodedRLPBody.dependsOn,
    expiration: decodedRLPBody.expiration,
    gas: decodedRLPBody.gas,
    gasPriceCoef: decodedRLPBody.gasPriceCoef,
    nonce: decodedRLPBody.nonce
  };
  const correctTransactionBody = decodedRLPBody.reserved.length > 0 ? {
    ...bodyWithoutReservedField,
    reserved: _decodeReservedField(
      decodedRLPBody.reserved
    )
  } : bodyWithoutReservedField;
  return decodedRLPBody.signature !== void 0 ? new Transaction(
    correctTransactionBody,
    decodedRLPBody.signature
  ) : new Transaction(correctTransactionBody);
}
function _decodeReservedField(reserved) {
  (0, import_sdk_errors33.assert)(
    "_decodeReservedField",
    reserved[reserved.length - 1].length !== 0,
    import_sdk_errors33.TRANSACTION.INVALID_TRANSACTION_BODY,
    "Invalid reserved field. Fields in the reserved buffer must be properly trimmed.",
    { reserved }
  );
  const featuresField = TRANSACTION_FEATURES_KIND.kind.buffer(reserved[0], TRANSACTION_FEATURES_KIND.name).decode();
  return reserved.length > 1 ? {
    features: featuresField,
    unused: reserved.slice(1)
  } : { features: featuresField };
}

// src/transaction/transaction-handler.ts
var TransactionHandler = {
  // Sign transaction
  sign: sign3,
  signWithDelegator,
  // Decode transaction
  decode: decode3
};

// src/utils/const/network.ts
var VECHAIN_MAINNET_CHAIN_TAG = 74;
var VECHAIN_TESTNET_CHAIN_TAG = 39;
var VECHAIN_SOLO_CHAIN_TAG = 246;
var ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
var VTHO_ADDRESS = "0x0000000000000000000000000000456e65726779";
var PARAMS_ADDRESS = "0x0000000000000000000000000000506172616d73";
var mainnetGenesisBlock = {
  number: 0,
  id: "0x00000000851caf3cfdb6e899cf5958bfb1ac3413d346d43539627e6be7ec1b4a",
  size: 170,
  parentID: "0xffffffff53616c757465202620526573706563742c20457468657265756d2100",
  timestamp: 1530316800,
  gasLimit: 1e7,
  beneficiary: "0x0000000000000000000000000000000000000000",
  gasUsed: 0,
  totalScore: 0,
  txsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  txsFeatures: 0,
  stateRoot: "0x09bfdf9e24dd5cd5b63f3c1b5d58b97ff02ca0490214a021ed7d99b93867839c",
  receiptsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  signer: "0x0000000000000000000000000000000000000000",
  isTrunk: true,
  transactions: []
};
var testnetGenesisBlock = {
  number: 0,
  id: "0x000000000b2bce3c70bc649a02749e8687721b09ed2e15997f466536b20bb127",
  size: 170,
  parentID: "0xffffffff00000000000000000000000000000000000000000000000000000000",
  timestamp: 1530014400,
  gasLimit: 1e7,
  beneficiary: "0x0000000000000000000000000000000000000000",
  gasUsed: 0,
  totalScore: 0,
  txsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  txsFeatures: 0,
  stateRoot: "0x4ec3af0acbad1ae467ad569337d2fe8576fe303928d35b8cdd91de47e9ac84bb",
  receiptsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  signer: "0x0000000000000000000000000000000000000000",
  isTrunk: true,
  transactions: []
};
var soloGenesisBlock = {
  number: 0,
  id: "0x00000000c05a20fbca2bf6ae3affba6af4a74b800b585bf7a4988aba7aea69f6",
  size: 170,
  parentID: "0xffffffff00000000000000000000000000000000000000000000000000000000",
  timestamp: 15264e5,
  gasLimit: 1e7,
  beneficiary: "0x0000000000000000000000000000000000000000",
  gasUsed: 0,
  totalScore: 0,
  txsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  txsFeatures: 0,
  stateRoot: "0x93de0ffb1f33bc0af053abc2a87c4af44594f5dcb1cb879dd823686a15d68550",
  receiptsRoot: "0x45b0cfc220ceec5b7c1c62c4d4193d38e4eba48e8815729ce75f9c0ab0e4c1c0",
  signer: "0x0000000000000000000000000000000000000000",
  isTrunk: true,
  transactions: []
};
var MAINNET_NETWORK = {
  genesisBlock: mainnetGenesisBlock,
  chainTag: VECHAIN_MAINNET_CHAIN_TAG
};
var TESTNET_NETWORK = {
  genesisBlock: testnetGenesisBlock,
  chainTag: VECHAIN_TESTNET_CHAIN_TAG
};
var SOLO_NETWORK = {
  genesisBlock: soloGenesisBlock,
  chainTag: VECHAIN_SOLO_CHAIN_TAG
};
var networkInfo = {
  mainnet: MAINNET_NETWORK,
  testnet: TESTNET_NETWORK,
  solo: SOLO_NETWORK
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BLOCK_REF_LENGTH,
  ERC721_ABI,
  HDNode,
  Hex,
  Hex0x,
  INTEGER_REGEX,
  MAINNET_NETWORK,
  MNEMONIC_WORDLIST_ALLOWED_SIZES,
  NUMERIC_REGEX,
  PARAMS_ABI,
  PARAMS_ADDRESS,
  PRIVATE_KEY_MAX_VALUE,
  Quantity,
  RLPBase,
  RLPProfiles,
  RLP_CODER,
  SIGNATURE_LENGTH,
  SIGNED_TRANSACTION_RLP,
  SOLO_NETWORK,
  TESTNET_NETWORK,
  TRANSACTIONS_GAS_CONSTANTS,
  TRANSACTION_FEATURES_KIND,
  TRANSACTION_SIGNATURE_KIND,
  Transaction,
  TransactionHandler,
  TransactionUtils,
  UNSIGNED_TRANSACTION_RLP,
  VET_DERIVATION_PATH,
  VIP180_ABI,
  VTHO_ADDRESS,
  X_PRIV_PREFIX,
  X_PUB_PREFIX,
  ZERO_ADDRESS,
  ZERO_BYTES,
  abi,
  addressUtils,
  assertCantGetFieldOnUnsignedTransaction,
  assertCompactFixedHexBlobBuffer,
  assertFixedHexBlobKindBuffer,
  assertFixedHexBlobKindData,
  assertIsAddress,
  assertIsArray,
  assertIsRevisionForAccount,
  assertIsRevisionForBlock,
  assertIsSignedTransaction,
  assertIsValidBuffer,
  assertIsValidPrivateKey,
  assertIsValidReturnType,
  assertIsValidSecp256k1MessageHash,
  assertIsValidTransactionSigningPrivateKey,
  assertValidHexBlobKindBuffer,
  assertValidHexBlobKindData,
  assertValidNumericKindBuffer,
  assertValidTransactionHead,
  assertValidTransactionID,
  blake2b256,
  blake2b256OfHex,
  bloom,
  bloomUtils,
  certificate,
  clauseBuilder,
  coder,
  core,
  dataUtils,
  decodeBufferToHexWithLeadingZeros,
  decodeBufferToNumberOrHex,
  encodeBigIntToBuffer,
  encodeCompactFixedHexBlob,
  fragment,
  isDerivationPathValid,
  keccak256,
  keystore,
  mnemonic,
  networkInfo,
  revisionUtils,
  secp256k1,
  sha256,
  unitsUtils,
  validateNumericKindData,
  vechain_sdk_core_ethers
});
/*! Bundled license information:

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
