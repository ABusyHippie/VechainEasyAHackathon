import { TransactionBody as TransactionBody$1, EventFragment as EventFragment$1, Result, TransactionClause, Transaction, vechain_sdk_core_ethers, ClauseOptions, ExtendedTransactionClause, InterfaceAbi, FunctionFragment, DeployParams } from '@vechain/sdk-core';
import { EventEmitter } from 'events';
import { Abi, AbiParametersToPrimitiveTypes, ExtractAbiFunctionNames, AbiFunction, ExtractAbiFunction, ExtractAbiEventNames, ExtractAbiEvent } from 'abitype';
import { AxiosError, AxiosInstance } from 'axios';
import { HTTPClientError } from '@vechain/sdk-errors';

/**
 * Asserts that the transaction can be signed by validating the private key and the transaction body.
 *
 * @param methodName - The method name where the error was thrown.
 * @param originSignature - The signature of the transaction.
 * @param txBody - The transaction body.
 *
 * @throws an error if the transaction cannot be signed.
 */
declare const assertTransactionCanBeSigned: (methodName: string, originSignature: Buffer, txBody: TransactionBody$1) => void;

// @NOTE: Errors handling (https://eips.ethereum.org/EIPS/eip-1193#errors) will be delegated to `errors` package

/**
 * Interface for EIP-1193 provider request arguments.
 *
 * @see https://eips.ethereum.org/EIPS/eip-1193#request
 */
interface EIP1193RequestArguments {
    readonly method: string;
    readonly params?: unknown[];
}

/**
 * Standardized provider interface for EIP-1193.
 *
 * @see https://eips.ethereum.org/EIPS/eip-1193#message
 *
 * The Final usage will be:
 *
 * ```typescript
 * EIP1193ProviderMessage.request(args: EIP1193RequestArguments): Promise<unknown>;
 * ```
 */
interface EIP1193ProviderMessage {
    request: (args: EIP1193RequestArguments) => Promise<unknown>;
}

/* --- Input options start --- */

/**
 * Input options for:
 * * getAccount
 * * getBytecode
 * * getStorage
 * Methods
 */
interface AccountInputOptions {
    /**
     * (Optional) The block number or ID to reference the bytecode version.
     */
    revision?: string;
}

/* --- Input options end --- */

/* --- Responses Outputs start --- */

/**
 * The account details represent the balance, energy & whether the account is a smart contract.
 */
interface AccountDetail {
    /**
     * The balance of VET of the account.
     */
    balance: string;

    /**
     * The balance of VTHO of the account.
     */
    energy: string;

    /**
     * Whether the account is a smart contract (i.e., hasCode is true)
     */
    hasCode: boolean;
}

/**
 * The bytecode of a smart contract.
 * The bytecode is represented in hex string.
 */
interface ResponseBytecode {
    /**
     * Bytecode of the smart contract
     */
    code: string;
}

/**
 * The storage data of a smart contract at the specified position.
 * The storage data is represented in hex string.
 */
interface ResponseStorage {
    /**
     * Hex string of the storage data
     */
    value: string;
}

/* --- Responses Outputs start --- */

/**
 * Type for connected peer.
 * A connected peer is a node that is connected to the node you have specified for the thorest client.
 */
interface ConnectedPeer {
    /**
     * Name of the peer in the format of `[network]/[version]-[gitcommit]-[versionmeta]/[os]/[goversion]`.
     * e.g., `thor/v2.1.0-2b5853f-release/linux/go1.21.0`
     */
    name: string;
    /**
     * Represents the block ID of the best block of the peer.
     */
    bestBlockID: string;
    /**
     * Represents the Accumulated Witness Number (AWN) of the best block of the peer.
     */
    totalScore: number;
    /**
     * ID of the peer.
     */
    peerID: string;
    /**
     * IP address of the peer.
     */
    netAddr: string;
    /**
     * indicates whether the connection to a peer is inbound or outbound.
     * If `inbound` is true,  the peer has initiated the connection to your node. In other words, the connection request came from the peer to your VeChainThor node.
     * If `inbound` is false, your node has initiated the connection to the peer. In other words, the connection request came from your VeChainThor node to the peer.
     */
    inbound: boolean;
    /**
     * Duration of the connection with the peer.
     */
    duration: number;
}

/**
 * The `NodesModule` class serves as a module for node-related functionality, for example, checking the health of a node.
 */
declare class NodesModule {
    readonly thor: ThorClient;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the VeChain blockchain API.
     */
    constructor(thor: ThorClient);
    /**
     * Retrieves connected peers of a node.
     *
     * @returns A promise that resolves to the list of connected peers.
     */
    getNodes(): Promise<ConnectedPeer | null>;
    /**
     * Checks the health of a node using the following algorithm:
     * 1. Make an HTTP GET request to retrieve the last block timestamp.
     * 2. Calculates the difference between the current time and the last block timestamp.
     * 3. If the difference is less than the tolerance, the node is healthy.
     * Note, we could also check '/node/network/peers since' but the difficulty with this approach is
     * if you consider a scenario where the node is connected to 20+ peers, which is healthy, and it receives the new blocks as expected.
     * But what if the node's disk is full, and it's not writing the new blocks to its database? In this case the node is off-sync even
     * though it's technically alive and connected
     * @returns A boolean indicating whether the node is healthy.
     * @throws {InvalidDataTypeError} - if the timestamp key does not exist in the response from the API call to the node
     * @throws {InvalidDataTypeError} - if the timestamp key exists in the response from the API call to the node but the value is not a number
     * @throws {InvalidDataTypeError} - if the response from the API call to the node is not an object
     * @throws {InvalidDataTypeError} - if the response from the API call to the node is null or undefined
     */
    isHealthy(): Promise<boolean>;
    /**
     * Extracts the timestamp from the block
     * @remarks
     * This function throws an error if the timestamp key does not exist in the response from the API call to the node
     * @param response the response from the API call to the node
     * @returns the timestamp from the block
     * @throws {InvalidDataTypeError} - if the timestamp key does not exist in the response from the API call to the node
     * @throws {InvalidDataTypeError} - if the timestamp key exists in the response from the API call to the node but the value is not a number
     * @throws {InvalidDataTypeError} - if the response from the API call to the node is not an object
     * @throws {InvalidDataTypeError} - if the response from the API call to the node is null or undefined
     */
    private readonly getTimestampFromBlock;
}

/* --- Input options start --- */



/**
 * Range interface for specifying a range of data.
 */
interface Range {
    /**
     * The unit for specifying the range (block or time).
     */
    unit?: 'block' | 'time'; // The unit for specifying the range (block or time).

    /**
     * The starting point of the range.
     */
    from?: number;

    /**
     * The ending point of the range.
     */
    to?: number;
}

/**
 * Options interface for specifying Pagination Options (offset and limits).
 */
interface PaginationOptions {
    /**
     * Offset for pagination.
     */
    offset?: number;

    /**
     * Limit for the number of results to return.
     */
    limit?: number;
}

/**
 * FilterCriteria interface for filtering event logs.
 */
interface FilterCriteria {
    criteria: EventCriteria;
    eventFragment: EventFragment$1;
}

/**
 * EventCriteria interface for filtering event logs.
 */
interface EventCriteria {
    /**
     * Address filter for event criteria.
     */
    address?: string;
    /**
     * Event topics filter.
     */
    topic0?: string;
    topic1?: string;
    topic2?: string;
    topic3?: string;
    topic4?: string;
}

/**
 * Order interface for filtering event logs.
 */
type EventDisplayOrder = 'asc' | 'desc';

/**
 * FilterRawEventLogsArg interface for filtering raw event logs.
 */
interface FilterRawEventLogsOptions {
    /**
     * Block range
     */
    range?: Range;
    /**
     * Pagination options
     */
    options?: PaginationOptions;
    /**
     * Event filters
     */
    criteriaSet?: EventCriteria[];
    /**
     * Sorting order
     */
    order?: EventDisplayOrder;
}

/**
 * FilterEventLogsArg interface for filtering decoded event logs.
 */
interface FilterEventLogsOptions {
    /**
     * Block range
     */
    range?: Range;
    /**
     * Pagination options
     */
    options?: PaginationOptions;
    /**
     * Event filters
     */
    criteriaSet?: FilterCriteria[];
    /**
     * Sorting order
     */
    order?: EventDisplayOrder;
}

/**
 * FilterTransferLogsArg interface for filtering transfer logs.
 */
interface FilterTransferLogsOptions {
    /**
     * Block range to query
     */
    range?: Range;
    /**
     * Pagination options
     */
    options?: PaginationOptions;
    /**
     * Criteria to filter transfers by
     */
    criteriaSet: TransferCriteria[];
    /**
     * Ordering of results
     */
    order: EventDisplayOrder;
}

/* --- Input options end --- */

/* --- Responses Outputs start --- */

/**
 * Event metadata for an entity.
 */
interface Metadata {
    /**
     * Block identifier associated with the entity
     */
    blockID: string;
    /**
     * Block number associated with the entity
     */
    blockNumber: number;
    /**
     * Timestamp of the block
     */
    blockTimestamp: number;
    /**
     * Transaction ID associated with the entity
     */
    txID: string;
    /**
     * Transaction origin information
     */
    txOrigin: string;
    /**
     * Index of the clause
     */
    clauseIndex: number;
}

/**
 * TransferCriteria interface for filtering transfer logs.
 */
interface TransferCriteria {
    /**
     * Transaction origin filter for transfer criteria.
     */

    txOrigin?: string;
    /**
     * Sender's address filter.
     */

    sender?: string;
    /**
     * Recipient's address filter.
     */
    recipient?: string;
}

/**
 * Event interface representing event data.
 */
interface Event$1 {
    /**
     * The address related to the event.
     */
    address: string;

    /**
     * Event topics or categories.
     */
    topics: string[];

    /**
     * Event data.
     */
    data: string;
}

/**
 * Transfer interface representing transfer data.
 */
interface Transfer {
    /**
     * The sender's address in the transfer.
     */
    sender: string;

    /**
     * The recipient's address in the transfer.
     */
    recipient: string;

    /**
     * The amount being transferred.
     */
    amount: string;
}

/**
 * EventLogs interface, combining Event and EventMetadata.
 */
interface EventLogs extends Event$1 {
    /**
     * Event logs with associated metadata
     */
    meta: Metadata;

    /**
     * The decoded data from the event.
     */
    decodedData?: Result[];
}

/**
 * TransferLogs interface, combining Transfer and WithMeta.
 */
interface TransferLogs extends Transfer {
    /**
     * Transfer logs with associated metadata
     */
    meta: Metadata;
}

/**
 * The `LogsClient` class provides methods to interact with log-related endpoints
 * of the VeChainThor blockchain. It allows filtering event and transfer logs.
 */
declare class LogsModule {
    readonly thor: ThorClient;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the VeChain blockchain API.
     */
    constructor(thor: ThorClient);
    /**
     * Filters event logs based on the provided criteria. Raw event logs are not decoded.
     *
     * @param filterOptions - An object specifying filtering criteria for event logs.
     * @returns A promise that resolves to filtered event logs.
     */
    filterRawEventLogs(filterOptions: FilterRawEventLogsOptions): Promise<EventLogs[]>;
    /**
     * Filters event logs based on the provided criteria and decodes them using the provided fragments.
     * The decoded data is added to the event logs as a new property.
     * The result is an array of event logs grouped by the event topic hash.
     * @param filterOptions
     * @returns A promise that resolves to an array of event logs grouped by event.
     */
    filterEventLogs(filterOptions: FilterEventLogsOptions): Promise<EventLogs[][]>;
    /**
     * Removes duplicated fragments from the provided array. Fragments are considered duplicated if they have the same topic hash.
     * @param fragments - An array of event fragments.
     * @private Returns a map of unique fragments.
     */
    private removeDuplicatedFragments;
    /**
     * Filters transfer logs based on the provided criteria.
     *
     * @param filterOptions - An object specifying filtering criteria for transfer logs.
     * @returns A promise that resolves to filtered transfer logs.
     */
    filterTransferLogs(filterOptions: FilterTransferLogsOptions): Promise<TransferLogs[]>;
}

/* --- Input options start --- */



/**
 * Input options for Blocks module.
 */
interface BlocksModuleOptions {
    /**
     * (Optional) Whether the polling is enabled.
     */
    isPollingEnabled?: boolean;
    /**
     * (Optional) Callback function called when an error occurs.
     */
    onBlockError?: (error: Error) => undefined;
}

/**
 * Options for `waitForBlockCompressed` and  `waitForBlockExpanded` methods.
 */
interface WaitForBlockOptions {
    /**
     * Timeout in milliseconds.
     * After this time, the method will throw an error.
     */
    timeoutMs?: number;
    /**
     * Interval in milliseconds.
     * The method will check the blocks status every `intervalMs` milliseconds.
     */
    intervalMs?: number;
}

/* --- Input options end --- */

/* --- Responses Outputs start --- */

/**
 * BlockDetail is an interface representing detailed information about a blockchain block.
 */
interface BlockDetail {
    /**
     * Unique identifier for the block.
     */
    id: string;

    /**
     * Block number in the blockchain.
     */
    number: number;

    /**
     * Size of the block in bytes.
     */
    size: number;

    /**
     * Identifier of the parent block.
     */
    parentID: string;

    /**
     * Timestamp when the block was created.
     */
    timestamp: number;

    /**
     * Maximum gas limit for transactions in the block.
     */
    gasLimit: number;

    /**
     * Address of the beneficiary (miner) of the block.
     */
    beneficiary: string;

    /**
     * Total gas used by transactions in the block.
     */
    gasUsed: number;

    /**
     * Represents the Accumulated Witness Number (AWN) of the block.
     * It is used when selecting the trunk block in the VeChainThor consensus algorithm.
     *
     * @link see [VeChainThor Trunk](https://docs.vechain.org/introduction-to-vechain/about-the-vechain-blockchain/consensus-deep-dive#meta-transaction-features-3)
     */
    totalScore: number;

    /**
     * Root hash of the transactions in the block.
     */
    txsRoot: string;

    /**
     * Optional features associated with transactions.
     */
    txsFeatures?: number;

    /**
     * Root hash of the state tree after applying transactions.
     */
    stateRoot: string;

    /**
     * Root hash of the receipts of transactions.
     */
    receiptsRoot: string;

    /**
     * Address of the signer or validator for the block.
     */
    signer: string;

    /**
     * Indicates if the block contains a community fund (com).
     */
    com?: boolean;

    /**
     * Indicates if the block is finalized (optional).
     */
    isFinalized?: boolean;

    /**
     * Since there is no computational competition in PoA, the “longest chain” rule does not apply.
     * Instead, we consider the better branch as the one witnessed by more AMs (Authority Master nodes).
     *
     * @link see [VeChainThor Trunk](https://docs.vechain.org/introduction-to-vechain/about-the-vechain-blockchain/consensus-deep-dive#meta-transaction-features-3)
     */
    isTrunk: boolean;
}

/**
 * Type for the compressed block detail.
 * Here we have the transactions as an array of strings.
 */
interface CompressedBlockDetail extends BlockDetail {
    transactions: string[];
}

/**
 * Type for the expanded block detail.
 * Here we have the transactions expanded with the details.
 */
interface ExpandedBlockDetail extends BlockDetail {
    transactions: TransactionsExpandedBlockDetail[];
}

/**
 * Output represents the result or consequence of a blockchain transaction.
 */
interface Output {
    /**
     * address of the contract involved in the clause output.
     */
    contractAddress: string | null;
    /**
     * Events emitted by executing the clause.
     */
    events: Event$1[];
    /**
     * Transfers of VET or VIP180 tokens that occur from the clause.
     */
    transfers: Transfer[];
}

/**
 * TransactionsExpandedBlockDetail is an interface representing detailed information about transactions in a blockchain block.
 */
interface TransactionsExpandedBlockDetail {
    /**
     * Unique identifier for the transaction.
     */
    id: string;

    /**
     * Chain tag of the blockchain.
     */
    chainTag: string;

    /**
     * Reference to the block.
     */
    blockRef: string;

    /**
     * Expiration timestamp of the transaction.
     */
    expiration: number;

    /**
     * Clauses represent the individual conditions or terms in a blockchain transaction.
     */
    clauses: TransactionClause[];

    /**
     * Gas price coefficient for the transaction.
     */
    gasPriceCoef: number;

    /**
     * Gas limit for the transaction.
     */
    gas: number;

    /**
     * Origin (sender) of the transaction.
     */
    origin: string;

    /**
     * Delegator associated with the transaction.
     */
    delegator: string;

    /**
     * Nonce value for preventing replay attacks.
     */
    nonce: string;

    /**
     * Transaction dependency.
     */
    dependsOn: string;

    /**
     * Size of the transaction in bytes.
     */
    size: number;

    /**
     * Gas used by the transaction.
     */
    gasUsed: number;

    /**
     * Account paying for the gas.
     */
    gasPayer: string;

    /**
     * Amount paid for the transaction.
     */
    paid: string;

    /**
     * Reward associated with the transaction.
     */
    reward: string;

    /**
     * Indicates if the transaction is reverted.
     */
    reverted: boolean;

    /**
     * Outputs represent the results or consequences of a blockchain transaction.
     */
    outputs: Output[];
}

/** The `BlocksModule` class encapsulates functionality for interacting with blocks
 * on the VeChainThor blockchain.
 */
declare class BlocksModule {
    readonly thor: ThorClient;
    /**
     * The head block (best block). This is updated by the event poll instance every time a new block is produced.
     * @private
     */
    private headBlock;
    /**
     * Error handler for block-related errors.
     */
    onBlockError?: (error: Error) => undefined;
    /**
     * The Poll instance for event polling
     * @private
     */
    private pollInstance?;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the VeChain blockchain API.
     * @param options - (Optional) Other optional parameters for polling and error handling.
     */
    constructor(thor: ThorClient, options?: BlocksModuleOptions);
    /**
     * Destroys the instance by stopping the event poll.
     */
    destroy(): void;
    /**
     * Sets up the event polling for the best block.
     * @private
     * */
    private setupPolling;
    /**
     * Retrieves details of a compressed specific block identified by its revision (block number or ID).
     *
     * @param revision - The block number or ID to query details for.
     * @returns A promise that resolves to an object containing the details of the compressed block.
     */
    getBlockCompressed(revision: string | number): Promise<CompressedBlockDetail | null>;
    /**
     * Retrieves details of an expanded specific block identified by its revision (block number or ID).
     *
     * @param revision - The block number or ID to query details for.
     * @returns A promise that resolves to an object containing the details of the expanded block.
     */
    getBlockExpanded(revision: string | number): Promise<ExpandedBlockDetail | null>;
    /**
     * Retrieves details of the latest block.
     *
     * @returns A promise that resolves to an object containing the compressed block details.
     */
    getBestBlockCompressed(): Promise<CompressedBlockDetail | null>;
    /**
     * Retrieves details of the latest block.
     *
     * @returns A promise that resolves to an object containing the expanded block details.
     */
    getBestBlockExpanded(): Promise<ExpandedBlockDetail | null>;
    /**
     * Asynchronously retrieves a reference to the best block in the blockchain.
     *
     * This method first calls `getBestBlockCompressed()` to obtain the current best block. If no block is found (i.e., if `getBestBlockCompressed()` returns `null`),
     * the method returns `null` indicating that there's no block to reference. Otherwise, it extracts and returns the first 18 characters of the
     * block's ID, providing the ref to the best block.
     *
     * @returns {Promise<string | null>} A promise that resolves to either a string representing the first 18 characters of the best block's ID,
     * or `null` if no best block is found.
     *
     * @Example:
     * const blockRef = await getBestBlockRef();
     * if (blockRef) {
     *     console.log(`Reference to the best block: ${blockRef}`);
     * } else {
     *     console.log("No best block found.");
     * }
     */
    getBestBlockRef(): Promise<string | null>;
    /**
     * Retrieves the finalized block.
     *
     * @returns A promise that resolves to an object containing the finalized block.
     */
    getFinalBlockCompressed(): Promise<CompressedBlockDetail | null>;
    /**
     * Retrieves details of the finalized block.
     *
     * @returns A promise that resolves to an object containing the finalized block details.
     */
    getFinalBlockExpanded(): Promise<ExpandedBlockDetail | null>;
    /**
     * Synchronously waits for a specific block revision using polling.
     *
     * @param blockNumber - The block number to wait for.
     * @param expanded - A boolean indicating whether to wait for an expanded block.
     * @param options - (Optional) Allows to specify timeout and interval in milliseconds
     * @returns A promise that resolves to an object containing the compressed block.
     */
    private _waitForBlock;
    /**
     * Synchronously waits for a specific block revision using polling.
     *
     * @param blockNumber - The block number to wait for.
     * @param options - (Optional) Allows to specify timeout and interval in milliseconds
     * @returns A promise that resolves to an object containing the compressed block.
     */
    waitForBlockCompressed(blockNumber: number, options?: WaitForBlockOptions): Promise<CompressedBlockDetail | null>;
    /**
     * Synchronously waits for a specific expanded block revision using polling.
     *
     * @param blockNumber - The block number to wait for.
     * @param options - (Optional) Allows to specify timeout and interval in milliseconds
     * @returns A promise that resolves to an object containing the expanded block details.
     */
    waitForBlockExpanded(blockNumber: number, options?: WaitForBlockOptions): Promise<ExpandedBlockDetail | null>;
    /**
     * Returns the head block (best block).
     * @returns {BlockDetail | null} The head block (best block).
     */
    getHeadBlock(): CompressedBlockDetail | null;
    /**
     * Retrieves details of the genesis block.
     *
     * @returns A promise that resolves to an object containing the block details of the genesis block.
     */
    getGenesisBlock(): Promise<CompressedBlockDetail | null>;
    /**
     * Retrieves all addresses involved in a given block. This includes beneficiary, signer, clauses,
     * delegator, gas payer, origin, contract addresses, event addresses, and transfer recipients and senders.
     *
     * @param {ExpandedBlockDetail} block - The block object to extract addresses from.
     *
     * @returns {string[]} - An array of addresses involved in the block, included
     * empty addresses, duplicate elements are removed.
     *
     * @see {bloomUtils.filterOf}
     */
    getAllAddressesIntoABlock(block: ExpandedBlockDetail): string[];
}

/**
 * Transaction clause type for transaction simulation having value only string.
 */
type SimulateTransactionClause = TransactionClause;

/* --- Input options start --- */

/**
 * Options for `waitForTransaction` method.
 */
interface WaitForTransactionOptions {
    /**
     * Timeout in milliseconds.
     * After this time, the method will throw an error.
     */
    timeoutMs?: number;
    /**
     * Interval in milliseconds.
     * The method will check the transaction status every `intervalMs` milliseconds.
     */
    intervalMs?: number;
}

/**
 * Options for `buildTransactionBody` method.
 */
interface TransactionBodyOptions {
    /**
     * 8 bytes prefix of some block's ID
     */
    blockRef?: string;

    /**
     * Last byte of genesis block ID
     */
    chainTag?: number;

    /**
     * The ID of the transaction that this transaction depends on.
     */
    dependsOn?: string;

    /**
     * The expiration time of the transaction.
     * The transaction will expire after the number of blocks specified by this value.
     */
    expiration?: number;

    /**
     * Coefficient used to calculate the gas price for the transaction.
     * Value must be between 0 and 255.
     */
    gasPriceCoef?: number;

    /**
     * Whether the transaction is delegated to another account for gas payment.
     */
    isDelegated?: boolean;

    /**
     * Nonce value for various purposes.
     * Basic is to prevent replay attack by make transaction unique.
     * Every transaction with same chainTag, blockRef, ... must have different nonce.
     */
    nonce?: string | number;
}

/**
 * Options for `signTransaction` method.
 */
type SignTransactionOptions =
    | { delegatorUrl: string; delegatorPrivateKey?: never }
    | { delegatorPrivateKey: string; delegatorUrl?: never };

/**
 * Input options for:
 * * getTransactionReceipt
 * Methods
 */
interface GetTransactionReceiptInputOptions {
    /**
     * (Optional) The block number or ID to reference the transaction.
     */
    head?: string;
}

/**
 * Input options for:
 * * getTransaction
 * Methods
 */
type GetTransactionInputOptions = GetTransactionReceiptInputOptions & {
    /**
     * (Optional) If true, returns the pending transaction details instead of the final transaction details.
     */
    pending?: boolean;
};

/**
 * Type for transaction simulation options.
 */
interface SimulateTransactionOptions {
    /**
     * The block number or block ID of which the transaction simulation is based on
     */
    revision?: string;
    /**
     * The offered gas for the transaction simulation
     */
    gas?: string | number;
    /**
     * The price of gas for the transaction simulation
     */
    gasPrice?: string;
    /**
     * The caller of the transaction simulation. (i.e., the address that performs the transaction)
     */
    caller?: string;

    // ------ START: EXTENDED EVM CONTEXT OPTIONS ------ //

    /*
        The following options are useful when simulating transactions that provide additional context to the EVM.
        The additional context is handled by the built-in Extension-V2 Smart contract (https://docs.vechain.org/developer-resources/built-in-contracts#extension-v2-sol)

        The contract allows for smart contract developers to obtain additional context about the transaction in their smart contract code, for example:
        - The expiration of the transaction
        - The block reference of the transaction
        - The gas payer of the transaction
        - The proved work of the transaction (https://docs.vechain.org/core-concepts/transactions/transaction-calculation#proof-of-work)
    */

    /**
     * The VeChainThor blockchain allows for transaction-level proof of work (PoW) and converts the proved work into extra gas price that will be used by
     * the system to generate more reward to the block generator, the Authority Master node, that validates the transaction.
     * In other words, users can utilize their local computational power to make their transactions more likely to be included in a new block.
     *
     * @link [VeChainThor Proof of Work](https://docs.vechain.org/core-concepts/transactions/transaction-calculation#proof-of-work)
     */
    provedWork?: string;
    /**
     * The address that pays for the gas fee of the transaction simulation.
     * If different from the caller, then a delegated transaction is simulated.
     */
    gasPayer?: string;
    /**
     * The expiration of the transaction simulation.
     * Represents how long, in terms of the number of blocks, the transaction will be allowed to be mined in VeChainThor
     */
    expiration?: number;
    /**
     * BlockRef stores the reference to a particular block whose next block is the earliest block the current transaction can be included.
     *
     * @link [VeChainThor BlockRef](https://docs.vechain.org/core-concepts/transactions/meta-transaction-features/controllable-transaction-lifecycle)
     */
    blockRef?: string;

    // ------ END: EXTENDED EVM CONTEXT OPTIONS ------ //
}

/* --- Input options end --- */

/* --- Responses Outputs start --- */

/**
 * Represents the result of sending a transaction.
 *
 * @interface SendTransactionResult
 */
interface SendTransactionResult {
    /**
     * The unique identifier associated with the transaction.
     *
     * @type {string}
     */
    id: string;

    wait: () => Promise<TransactionReceipt | null>;
}

/**
 * Represents the result of getting a delegation signature.
 */
interface GetDelegationSignatureResult {
    /**
     * The signature of the transaction.
     */
    signature: string;
}

/**
 * Transaction Metadata interface.
 */
interface TransactionMetadata {
    blockID: string;
    blockNumber: number;
    blockTimestamp: number;
    txID?: string;
    txOrigin?: string;
}

/**
 * Type for RAW transaction detail.
 * It is the response of `getTransaction` with `raw` set to `true`.
 */
interface TransactionDetailRaw {
    /**
     * Raw data
     */
    raw: string;
    /**
     * Transaction meta data
     */
    meta: Omit<TransactionMetadata, 'txID' | 'txOrigin'>;
}

/**
 * Type for NO RAW transaction detail.
 * It is the response of `getTransaction` with `raw` set to `false`.
 */
type TransactionDetailNoRaw = TransactionBody$1 & {
    id: string;
    origin: string;
    delegator: string | null;
    size: number;
    meta: TransactionMetadata;
};

/**
 * Type for transaction receipt.
 */
interface TransactionReceipt {
    /**
     * Gas used in the transaction
     */
    gasUsed: number;
    /**
     * For delegated transactions the gas payer
     * */
    gasPayer: string;
    /**
     * Energy paid for used gas
     */
    paid: string;
    /**
     * Energy reward given to block proposer
     */
    reward: string;
    /**
     * If the transaction has been reverted
     */
    reverted: boolean;
    /**
     * Outputs of the transaction, e.g. contract, events, transfers
     */
    outputs: Output[];
    /**
     * Data associated with the transaction e.g. blockID, blockNumber, txID
     */
    meta: TransactionMetadata;
}

/**
 * Type for transaction call simulation result.
 */
interface TransactionSimulationResult {
    /**
     * Data returned from the transaction simulation
     */
    data: string;
    /**
     * Events emitted from the transaction simulation
     */
    events: Event[];
    /**
     * Transfers that occur from the transaction simulation
     */
    transfers: Transfer[];
    /**
     * Gas used from the transaction simulation
     */
    gasUsed: number;
    /**
     * Boolean indicating if the transaction simulation reverted
     */
    reverted: boolean;
    /**
     * Error message from the transaction simulation if it reverted
     */
    vmError: string;
}

/**
 * The `TransactionsModule` handles transaction related operations and provides
 * convenient methods for sending transactions and waiting for transaction confirmation.
 */
declare class TransactionsModule {
    readonly thor: ThorClient;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the VeChain blockchain API.
     */
    constructor(thor: ThorClient);
    /**
     * Retrieves the details of a transaction.
     *
     * @param id - Transaction ID of the transaction to retrieve.
     * @param options - (Optional) Other optional parameters for the request.
     * @returns A promise that resolves to the details of the transaction.
     */
    getTransaction(id: string, options?: GetTransactionInputOptions): Promise<TransactionDetailNoRaw | null>;
    /**
     * Retrieves the details of a transaction.
     *
     * @param id - Transaction ID of the transaction to retrieve.
     * @param options - (Optional) Other optional parameters for the request.
     * @returns A promise that resolves to the details of the transaction.
     */
    getTransactionRaw(id: string, options?: GetTransactionInputOptions): Promise<TransactionDetailRaw | null>;
    /**
     * Retrieves the receipt of a transaction.
     *
     * @param id - Transaction ID of the transaction to retrieve.
     * @param options - (Optional) Other optional parameters for the request.
     *                  If `head` is not specified, the receipt of the transaction at the best block is returned.
     * @returns A promise that resolves to the receipt of the transaction.
     */
    getTransactionReceipt(id: string, options?: GetTransactionReceiptInputOptions): Promise<TransactionReceipt | null>;
    /**
     * Retrieves the receipt of a transaction.
     *
     * @param raw - The raw transaction.
     * @returns The transaction id of send transaction.
     */
    sendRawTransaction(raw: string): Promise<SendTransactionResult>;
    /**
     * Sends a signed transaction to the network.
     *
     * @param signedTx - the transaction to send. It must be signed.
     *
     * @returns A promise that resolves to the transaction ID of the sent transaction.
     *
     * @throws an error if the transaction is not signed or if the transaction object is invalid.
     */
    sendTransaction(signedTx: Transaction): Promise<SendTransactionResult>;
    /**
     * Waits for a transaction to be included in a block.
     *
     * @param txID - The transaction ID of the transaction to wait for.
     * @param options - Optional parameters for the request. Includes the timeout and interval between requests.
     *                  Both parameters are in milliseconds. If the timeout is not specified, the request will not time out!
     *
     * @returns A promise that resolves to the transaction receipt of the transaction. If the transaction is not included in a block before the timeout,
     *          the promise will resolve to `null`.
     *
     * @throws an error if the transaction ID is invalid.
     */
    waitForTransaction(txID: string, options?: WaitForTransactionOptions): Promise<TransactionReceipt | null>;
    /**
     * Builds a transaction body with the given clauses without having to
     * specify the chainTag, expiration, gasPriceCoef, gas, dependsOn and reserved fields.
     *
     * @param clauses - The clauses of the transaction.
     * @param gas - The gas to be used to perform the transaction.
     * @param options - Optional parameters for the request. Includes the expiration, gasPriceCoef, dependsOn and isDelegated fields.
     *                  If the `expiration` is not specified, the transaction will expire after 32 blocks.
     *                  If the `gasPriceCoef` is not specified, the transaction will use the default gas price coef of 127.
     *                  If the `dependsOn is` not specified, the transaction will not depend on any other transaction.
     *                  If the `isDelegated` is not specified, the transaction will not be delegated.
     *
     * @returns A promise that resolves to the transaction body.
     *
     * @throws an error if the genesis block or the latest block cannot be retrieved.
     */
    buildTransactionBody(clauses: TransactionClause[], gas: number, options?: TransactionBodyOptions): Promise<TransactionBody$1>;
    /**
     * Ensures that names in clauses are resolved to addresses
     *
     * @param clauses - The clauses of the transaction.
     * @returns A promise that resolves to clauses with resolved addresses
     */
    resolveNamesInClauses(clauses: TransactionClause[]): Promise<TransactionClause[]>;
    /**
     * Simulates the execution of a transaction.
     * Allows to estimate the gas cost of a transaction without sending it, as well as to retrieve the return value(s) of the transaction.
     *
     * @param clauses - The clauses of the transaction to simulate.
     * @param options - (Optional) The options for simulating the transaction.
     *
     * @returns A promise that resolves to an array of simulation results.
     *          Each element of the array represents the result of simulating a clause.
     */
    simulateTransaction(clauses: SimulateTransactionClause[], options?: SimulateTransactionOptions): Promise<TransactionSimulationResult[]>;
    /**
     * Decode the revert reason from the encoded revert reason into a transaction.
     *
     * @param encodedRevertReason - The encoded revert reason to decode.
     * @param errorFragment - (Optional) The error fragment to use to decode the revert reason (For Solidity custom errors).
     * @returns A promise that resolves to the decoded revert reason.
     * Revert reason can be a string error or Panic(error_code)
     */
    decodeRevertReason(encodedRevertReason: string, errorFragment?: string): string;
    /**
     * Get the revert reason of an existing transaction.
     *
     * @param transactionHash - The hash of the transaction to get the revert reason for.
     * @param errorFragment - (Optional) The error fragment to use to decode the revert reason (For Solidity custom errors).
     * @returns A promise that resolves to the revert reason of the transaction.
     */
    getRevertReason(transactionHash: string, errorFragment?: string): Promise<string | null>;
}

/**
 * Default timeout for HTTP requests, in milliseconds.
 */
declare const DEFAULT_HTTP_TIMEOUT = 30000;
/**
 * HTTP regex.
 */
declare const HTTP_REGEX: RegExp;
/**
 * HTTPS regex.
 */
declare const HTTPS_REGEX: RegExp;

/**
 * Node healthcheck Tolerance in seconds.
 * @example When set to 30, it means that we consider a node healthy even when it's off-sync by roughly 3 blocks.
 */
declare const NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS = 30;

/**
 * The selector for the error event.
 */
declare const ERROR_SELECTOR: string;
/**
 * The selector for the panic event.
 */
declare const PANIC_SELECTOR: string;

/**
 * Converts an AxiosError into a standard Error.
 *
 * This function converts an AxiosError, which may contain HTTP response details, into a standard Error.
 * It handles cases where the AxiosError has an HTTP response with status and data.
 *
 * @param error - The AxiosError to convert into an Error.
 * @returns A standard Error with a descriptive message.
 */
declare const convertError: (error: AxiosError) => HTTPClientError;

/**
 * Constructs a query object for HTTP requests by filtering out undefined values.
 *
 * @param params - An object containing the query parameters with potential undefined values.
 * @returns An object containing only the defined query parameters.
 */
declare const buildQuery: (params: Record<string, string | boolean | undefined>) => Record<string, string>;

/**
 * Represents the parameters for making an HTTP request.
 *
 * This interface specifies options for configuring an HTTP request, including query parameters,
 * request body, custom headers, and a function to validate response headers.
 */
interface HttpParams {
    /**
     * Query parameters to include in the request.
     */
    query?: Record<string, string>;

    /**
     * The request body, which can be of any type.
     */
    body?: unknown;

    /**
     * Custom headers to be included in the request.
     */
    headers?: Record<string, string>;

    /**
     * A callback function to validate response headers.
     * @param headers - The response headers to validate.
     */
    validateResponseHeader?: (headers: Record<string, string>) => void;
}

/**
 * Represents the options for configuring an HTTP client.
 */
interface HttpClientOptions {
    /**
     * The timeout for an HTTP request, in milliseconds.
     */
    timeout?: number;

    /**
     * An Axios instance to use for sending HTTP requests.
     * This is useful for customizing the HTTP client, such as adding a custom user agent.
     */
    axiosInstance?: AxiosInstance;
}

/**
 * Represents a concrete implementation of the `IHttpClient` interface, providing methods for making HTTP requests.
 *
 * This class leverages Axios for handling HTTP requests and allows for interaction with HTTP services.
 * It is configured with a base URL and request timeout upon instantiation.
 */
declare class HttpClient {
    readonly baseURL: string;
    /**
     * Axios instance to make http requests
     */
    protected readonly axios: AxiosInstance;
    /**
     * Instantiates an `HttpClient` object with a specified base URL and HTTP request timeout.
     *
     * @param baseURL - The base URL for all network requests.
     * @param options - (Optional) An object containing additional configuration options for the HTTP client, such as a custom Axios instance and a request timeout.
     */
    constructor(baseURL: string, options?: HttpClientOptions);
    /**
     * Sends an HTTP request using the Axios library.
     *
     * @param method - The HTTP method to be used ('GET' or 'POST').
     * @param path - The path to access on the server relative to the base URL.
     * @param params - (Optional) Additional request parameters such as query parameters, request body, and custom headers.
     * @returns A promise that resolves to the response data from the HTTP request.
     * @throws {HTTPClientError} Will throw an error if the request fails, with more detailed information if the error is Axios-specific.
     */
    http(method: 'GET' | 'POST', path: string, params?: HttpParams): Promise<unknown>;
    /**
     * Validates the response headers if a validation function is provided.
     *
     * @param params - (Optional) The request parameters.
     * @param headers - The response headers.
     */
    private validateResponseHeader;
}

/**
 * Options for the force stop of the sync polling.
 */
interface SyncPollInputOptions {
    /**
     * The maximum number of iterations.
     * Poll will stop after this number of iterations, no matter condition is met or not.
     *
     * @note If not specified limit on iterations is NOT given.
     */
    maximumIterations?: number;

    /**
     * The interval of time (in milliseconds) between each function call.
     *
     * @note If not specified a default value is given.
     */
    requestIntervalInMilliseconds?: number;

    /**
     * The maximum amount of time (in milliseconds) to wait for the condition to be met.
     *
     * @note If not specified limit on time is NOT given.
     */
    maximumWaitingTimeInMilliseconds?: number;
}

/**
 * Poll until the condition is met.
 *
 * @note: Be careful!, this function is synchronous and will block the thread until the condition is met.
 * Thus mean it can run forever if the condition is never met.
 * To avoid infinite loop, you can use the `options.maximumIterations` parameter.
 *
 * @example It can be used to wait until:
 *  - A balance is updated after a transaction is sent
 *  - A transaction is mined
 *  - A block is mined
 *  ...
 *
 * @param pollingFunction - The function to be called.
 * @param options - Polling options. @see {SyncPollInputOptions} type. If not specified, the default values are used. In particular: `requestIntervalInMilliseconds` is 1000, `maximumIterations` is not specified
 *                  and `maximumWaitingTimeInMilliseconds` is not specified.
 * @returns An object with a `waitUntil` method. It blocks execution until the condition is met. When the condition is met, it returns the result of the poll.
 */
declare function SyncPoll<TReturnType>(pollingFunction: () => Promise<TReturnType> | TReturnType, options?: SyncPollInputOptions): {
    waitUntil: (condition: (data: TReturnType) => boolean) => Promise<TReturnType>;
};

/**
 * Poll in an event based way.
 * This Poll is Asynchronous. It exploits:
 * - The EventEmitter to emit events
 * - The setInterval function to poll
 *
 * @example It can be used to trigger events every time
 *  - When balance is updated after a transaction is sent a message is sent
 *  - When a transaction is mined a message is sent
 *  - When a certain block is mined an operation can start
 *  ...
 */
declare class EventPoll<TReturnType> extends EventEmitter {
    /**
     * The current iteration. It counts how many iterations have been done.
     * This parameter is useful to know how many iterations have been done.
     * For example, it can be used to stop the poll after a certain number of iterations.
     */
    private currentIteration;
    /**
     * Error thrown during the execution of the poll.
     */
    private error?;
    /**
     * Indicates whether to stop execution on error of the
     * {@link _intervalLoop} function.
     *
     * @type {boolean}
     */
    private readonly hasToStopOnError;
    /**
     * The interval used to poll.
     */
    private intervalId?;
    /**
     * The function to be called.
     */
    private readonly pollingFunction;
    /**
     * The interval of time (in milliseconds) between each request.
     */
    private readonly requestIntervalInMilliseconds;
    /**
     * Constructor for creating an instance of EventPoll.
     *
     * @param {Function} pollingFunction - The function to be executed repeatedly.
     * @param {number} requestIntervalInMilliseconds - The interval in milliseconds between each execution of the polling function.
     * @param {boolean} [hasToStopOnError=true] - Indicates whether to stop polling if an error occurs.
     */
    constructor(pollingFunction: () => Promise<TReturnType>, requestIntervalInMilliseconds: number, hasToStopOnError: boolean);
    /**
     * Get how many iterations have been done.
     *
     * @returns The number of iterations.
     */
    get getCurrentIteration(): number;
    /**
     * Basic interval loop function.
     * This function must be called into setInterval.
     * It calls the promise and emit the event.
     */
    private _intervalLoop;
    /**
     * Listen to the 'data' event.
     * This method is the redefinition of the EventEmitter.on method.
     * Because the EventEmitter.on method does not allow to specify the type of the data.
     * And we must be type safe.
     *
     * This is equivalent to:
     *
     * ```typescript
     * eventPoll.on('data', (data) => { ... });
     * ```
     * @param onDataCallback - The callback to be called when the event is emitted.
     */
    onData(onDataCallback: (data: TReturnType, eventPoll: EventPoll<TReturnType>) => void): this;
    /**
     * Listen to the 'error' event.
     * This method is the redefinition of the EventEmitter.on method.
     * Because the EventEmitter.on method does not allow to specify the type of the data.
     * And we must be type safe.
     *
     * This is equivalent to:
     *
     * ```typescript
     * eventPoll.on('error', (data) => { ... });
     * ```
     * @param onErrorCallback - The callback to be called when the event is emitted.
     */
    onError(onErrorCallback: (error: Error) => void): this;
    /**
     * Listen to the 'start' event.
     * This happens when the poll is stopped.
     *
     * @param onStartCallback - The callback to be called when the event is emitted.
     */
    onStart(onStartCallback: (eventPoll: EventPoll<TReturnType>) => void): this;
    /**
     * Listen to the 'stop' event.
     * This happens when the poll is stopped.
     *
     * @param onStopCallback - The callback to be called when the event is emitted.
     */
    onStop(onStopCallback: (eventPoll: EventPoll<TReturnType>) => void): this;
    /**
     * Start listening to the event.
     */
    startListen(): void;
    /**
     * Stop listening to the event.
     */
    stopListen(): void;
}
/**
 * Creates an event poll that performs a callback function repeatedly at a specified interval.
 * This method is useful to create an event poll in a more readable way.
 *
 * @param {Function} callBack - The callback function to be executed on each interval. It should return a Promise.
 * @param {number} requestIntervalInMilliseconds - The interval in milliseconds at which the callback function will be executed.
 * @param {boolean} [hasToStopOnError=true] - Optional parameter to specify whether the poll should stop on error. Default is true.
 * @returns {EventPoll} - The created event poll instance.
 */
declare function createEventPoll<TReturnType>(callBack: () => Promise<TReturnType>, requestIntervalInMilliseconds: number, hasToStopOnError?: boolean): EventPoll<TReturnType>;

declare const Poll: {
    SyncPoll: typeof SyncPoll;
    createEventPoll: typeof createEventPoll;
};

/**
 * Generates a query string from a record of key-value pairs.
 * Only includes keys in the query string whose values are defined.
 *
 * @param params - The record of key-value pairs.
 * @returns The query string.
 */
declare const toQueryString: (params: Record<string, string | number | boolean | undefined>) => string;
/**
 * Sanitizes a base URL by removing trailing slashes and adding the protocol if missing.
 *
 * @param url - The URL to validate.
 * @returns The sanitized URL without the protocol.
 */
declare const sanitizeWebsocketBaseURL: (url: string) => string;

/* --- Input options start --- */

interface EventOptions {
    /**
     * The block id to start from, defaults to the best block.
     */
    position?: string;
    /**
     * The contract address to filter events by.
     */
    contractAddress?: string;
    /**
     * The topic0 to filter events by.
     */
    topic0?: string;
    /**
     * The topic1 to filter events by.
     */
    topic1?: string;
    /**
     * The topic2 to filter events by.
     */
    topic2?: string;
    /**
     * The topic3 to filter events by.
     */
    topic3?: string;
    /**
     * The topic4 to filter events by.
     */
    topic4?: string;
}

interface VetTransferOptions {
    /**
     * The block id to start from, defaults to the best block.
     */
    position?: string;
    /**
     * The signer address to filter transfers by.
     */
    signerAddress?: string;
    /**
     * The sender address to filter transfers by.
     */
    sender?: string;
    /**
     * The receiver address to filter transfers by.
     */
    receiver?: string;
}

/**
 * Endpoints for the REST API.
 */
declare const thorest: {
    /**
     * Accounts related endpoints.
     */
    accounts: {
        get: {
            ACCOUNT_DETAIL: (address: string) => string;
            ACCOUNT_BYTECODE: (address: string) => string;
            STORAGE_AT: (address: string, position: string) => string;
        };
        post: {
            SIMULATE_TRANSACTION: (revision?: string) => string;
        };
    };
    /**
     * Blocks related endpoints.
     */
    blocks: {
        get: {
            BLOCK_DETAIL: (revision: string | number) => string;
        };
    };
    /**
     * Nodes related endpoints.
     */
    nodes: {
        get: {
            NODES: () => string;
        };
    };
    /**
     * Logs related endpoints.
     */
    logs: {
        post: {
            EVENT_LOGS: () => string;
            TRANSFER_LOGS: () => string;
        };
    };
    /**
     * Transactions related endpoints.
     */
    transactions: {
        get: {
            TRANSACTION: (id: string) => string;
            TRANSACTION_RECEIPT: (id: string) => string;
        };
        post: {
            TRANSACTION: () => string;
        };
    };
    /**
     * Subscriptions related endpoints.
     */
    subscriptions: {
        get: {
            /**
             * Subscribe to new blocks.
             *
             * @param baseURL - The URL of the node to request the subscription from.
             * @param position - (optional) The block id to start from, defaults to the best block.
             *
             * @returns The websocket subscription URL.
             */
            BLOCK: (baseURL: string, position?: string) => string;
            /**
             * Subscribe to new events.
             *
             * @param baseURL - The URL of the node to request the subscription from.
             * @param options - (optional) The options for the subscription.
             *
             * @returns The websocket subscription URL.
             */
            EVENT: (baseURL: string, options?: EventOptions) => string;
            /**
             * Subscribe to new VET transfers.
             *
             * @param baseURL - The URL of the node to request the subscription from.
             * @param options - (optional) The options for the subscription.
             *
             * @returns The websocket subscription URL.
             */
            VET_TRANSFER: (baseURL: string, options?: VetTransferOptions) => string;
            /**
             * Subscribe to new legacy beats.
             * A beat is a notification that a new block has been added to the blockchain with a bloom filter which can be used to check if the block contains any relevant account.
             * @note This subscription has been improved with dynamic size bloom filter with the new `BEAT` subscription.
             *
             * @param baseURL - The URL of the node to request the subscription from.
             * @param position - (optional) The block id to start from, defaults to the best block.
             *
             * @returns The websocket subscription URL.
             */
            BEAT_LEGACY: (baseURL: string, position?: string) => string;
            /**
             * Subscribe to new beats.
             * A beat is a notification that a new block has been added to the blockchain with a bloom filter which can be used to check if the block contains any relevant account.
             *
             * @param baseURL - The URL of the node to request the subscription from.
             * @param position - (optional) The block id to start from, defaults to the best block.
             *
             * @returns The websocket subscription URL.
             */
            BEAT: (baseURL: string, position?: string) => string;
            /**
             * Subscribe to new transactions.
             *
             * @returns The websocket subscription URL.
             */
            NEW_TRANSACTIONS: (baseURL: string) => string;
        };
    };
    /**
     * Debug related endpoints.
     */
    debug: {
        post: {
            TRACE_TRANSACTION_CLAUSE: () => string;
            TRACE_CONTRACT_CALL: () => string;
            RETRIEVE_STORAGE_RANGE: () => string;
        };
    };
};

/* --------- Event types start --------- */

/**
 * An Event Parameter ABI object.
 */
interface EventParameter {
    /**
     * Whether the parameter is an indexed parameter.
     */
    indexed: boolean;
    /**
     * The name of the parameter.
     */
    name: string;
    /**
     * The type of the parameter.
     */
    type: string;
    /**
     * The internal type of the parameter.
     */
    internalType?: string;
}

/**
 * An Event ABI object.
 */
interface EventAbi {
    /**
     * Whether the event was declared as anonymous.
     */
    anonymous: boolean;
    /**
     * The inputs of the event.
     */
    inputs: EventParameter[];
    /**
     * The name of the event.
     */
    name: string;
    /**
     * The type of the event. For an event, this is always 'event'.
     */
    type: string;
}

/**
 * An Ethers Event Fragment object.
 *
 * @see [Ethers Event Fragment](https://docs.ethers.org/v6/api/abi/abi-coder/#EventFragment)
 */
type EventFragment = vechain_sdk_core_ethers.EventFragment;

/**
 * An event represented as a string, an EventAbi object or an ethers EventFragment object.
 * If a string is provided, it must adhere to ether's Format Types.
 *
 * @see [Ethers Format Types](https://docs.ethers.org/v5/api/utils/abi/interface/#Interface--formatting)
 * @see [Ethers Event Fragment](https://docs.ethers.org/v6/api/abi/abi-coder/#EventFragment)
 */
type EventLike = string | EventAbi | EventFragment;

/* --------- Event types end --------- */

/* --- Input options start --- */

/**
 * Options for event subscription.
 */
interface EventSubscriptionOptions {
    /**
     * The block id from which to start the subscription.
     *
     * @note the Block ID must refer to a block that does not exceed the backtrace limit of the node. (Default: 1000)
     * @see [Backtrace limit](https://docs.vechain.org/start-building/tutorials/how-to-run-a-thor-solo-node#command-line-options)
     */
    blockID?: string;

    /**
     * The address of the contract that emitted the event to subscribe to.
     */
    address?: string;
}

interface BlockSubscriptionOptions {
    /**
     * The block id from which to start the subscription.
     *
     * @note the Block ID must refer to a block that does not exceed the backtrace limit of the node. (Default: 1000)
     * @see [Backtrace limit](https://docs.vechain.org/start-building/tutorials/how-to-run-a-thor-solo-node#command-line-options)
     */
    blockID?: string;
}

interface VETtransfersSubscriptionOptions {
    /**
     * The block id from which to start the subscription.
     *
     * @note the Block ID must refer to a block that does not exceed the backtrace limit of the node. (Default: 1000)
     * @see [Backtrace limit](https://docs.vechain.org/start-building/tutorials/how-to-run-a-thor-solo-node#command-line-options)
     */
    blockID?: string;

    /**
     * The address of the contract that emitted the event to subscribe to.
     */
    signerAddress?: string;

    /**
     * The address of the sender of the VET transfer to subscribe to.
     */
    sender?: string;

    /**
     * The address of the recipient of the VET transfer to subscribe to.
     */
    recipient?: string;
}

/**
 * Subscriptions utilities.
 * Contains functions for obtaining URLs for subscribing to events through a websocket connection.
 */
declare const subscriptions: {
    getEventSubscriptionUrl: (baseURL: string, event: EventLike, indexedValues?: unknown[], options?: EventSubscriptionOptions) => string;
    getBlockSubscriptionUrl: (baseURL: string, options?: BlockSubscriptionOptions) => string;
    getNewTransactionsSubscriptionUrl: (baseURL: string) => string;
    getVETtransfersSubscriptionUrl: (baseURL: string, options?: VETtransfersSubscriptionOptions) => string;
    getLegacyBeatSubscriptionUrl: (baseURL: string, options?: BlockSubscriptionOptions) => string;
    getBeatSubscriptionUrl: (baseURL: string, options?: BlockSubscriptionOptions) => string;
};

declare const vnsUtils: {
    resolveName: (thorClient: ThorClient, name: string) => Promise<null | string>;
    resolveNames: (thorClient: ThorClient, names: string[]) => Promise<Array<null | string>>;
    lookupAddress: (thorClient: ThorClient, address: string) => Promise<null | string>;
    lookupAddresses: (thorClient: ThorClient, addresses: string[]) => Promise<Array<null | string>>;
};

/**
 * Provide a set of utils for the delegation type.
 * It is a mutual exclusion between delegatorPrivateKey and delegatorUrl. (@see SignTransactionOptions)
 *
 * The aim of this handler is to:
 *   - Understand the kind of delegation and the delegation info
 *   - Provide a method to get the delegation signature
 *
 * @param delegator - The delegator options.
 */
declare const DelegationHandler: (delegator?: SignTransactionOptions | null) => {
    isDelegated: () => boolean;
    delegatorOrUndefined: () => SignTransactionOptions | undefined;
    delegatorOrNull: () => SignTransactionOptions | null;
    getDelegationSignatureUsingUrl: (tx: Transaction, originAddress: string, httpClient: HttpClient) => Promise<Buffer>;
};

declare module 'abitype' {
    export interface Register {
        AddressType: string;
    }
}

/* --------- Input types Start --------- */

/**
 * Defines the options for executing a contract transaction.
 */
type ContractTransactionOptions = {
    value?: number;
    signTransactionOptions?: SignTransactionOptions;
} & TransactionBodyOptions &
    ClauseOptions;

/**
 * Defines the options for executing a contract call within a blockchain environment.
 */
type ContractCallOptions = SimulateTransactionOptions & ClauseOptions;

/* --------- Input types End --------- */

/**
 * Represents the result of a contract call operation, encapsulating the output of the call.
 */
type ContractCallResult = vechain_sdk_core_ethers.Result;

/**
 * Represents a contract clause, which includes the clause and the corresponding function fragment.
 */
interface ContractClause {
    clause: ExtendedTransactionClause;
    functionFragment: vechain_sdk_core_ethers.FunctionFragment;
}

/**
 * Represents a filter for events emitted by a smart contract. This class allows for the specification of criteria to filter
 * events and provides a method to fetch event logs based on those criteria.
 */
declare class ContractFilter<TAbi extends Abi> {
    /**
     * The smart contract instance to apply the filter on.
     */
    contract: Contract<TAbi>;
    /**
     * A set of criteria used to filter events.
     */
    criteriaSet: FilterCriteria[];
    /**
     * Constructs an instance of the `ContractFilter` class.
     *
     * @param contract - The smart contract instance to apply the filter on.
     * @param criteriaSet - A set of criteria used to filter events.
     */
    constructor(contract: Contract<TAbi>, criteriaSet: FilterCriteria[]);
    /**
     * Retrieves event logs based on the specified filter criteria, range, pagination options, and order.
     *
     * @param range - The block range to fetch the events from. Defaults to the entire blockchain history if not provided.
     * @param options - Pagination options for fetching the events.
     * @param order - The order in which to display the events. Defaults to ascending ('asc') if not provided.
     * @returns An array of event logs that match the specified criteria.
     */
    get(range?: Range, options?: PaginationOptions, order?: EventDisplayOrder): Promise<EventLogs[][]>;
}

/**
 * Represents a generic contract function type that accepts an arbitrary number of arguments
 * and returns a value of generic type `T`. This type is typically used to model the behavior of
 * smart contract functions in a blockchain context.
 *
 * @typeParam T - The expected return type of the function. Defaults to `unknown` if not specified.
 * @param args - An array of arguments that the contract function accepts. The types of these arguments
 *               are not specified, allowing for flexibility in function signatures.
 * @returns A value of type `T`, representing the result of the contract function execution.
 */
type ContractFunctionSync<T = unknown, TABIFunction> = (
    ...args: [
        ...Partial<{ value: number; comment: string }>,
        ...AbiParametersToPrimitiveTypes<TABIFunction['inputs'], 'inputs'>
    ]
) => T;

/**
 * Defines a synchronous function type for handling contract events.
 *
 * @template T - The return type of the contract event function. Defaults to `unknown`.
 * @template TAbiEvent - The ABI event type for the contract event.
 *
 * This type represents a function that takes a variable number of arguments, which are partial
 * representations of the input parameters defined in the ABI for the event, and returns a value of type `T`.
 */
type ContractEventSync<T = unknown, TABIEvent> = (
    ...args: Partial<
        AbiParametersToPrimitiveTypes<TABIEvent['inputs'], 'inputs'>
    >
) => T;

/**
 * Represents a generic contract function type that accepts an arbitrary number of arguments
 * and returns a promise that resolves to a generic type `T`. This type is typically used to
 * model the behavior of smart contract functions in a blockchain context.
 *
 * @typeParam T - The expected return type of the promise. Defaults to `unknown` if not specified.
 * @param args - An array of arguments that the contract function accepts. The types of these arguments
 *               are not specified, allowing for flexibility in function signatures.
 * @returns A promise that resolves to the type `T`, representing the result of the contract function execution.
 */
type ContractFunctionAsync<T = unknown, TABIFunction> = (
    ...args: [
        ...Partial<{ value: number; comment: string }>,
        ...AbiParametersToPrimitiveTypes<TABIFunction['inputs'], 'inputs'>
    ]
) => Promise<T>;

/**
 * Defines a mapping of contract function names to their corresponding read-only contract functions.
 * Each function in this record is expected to return a `Promise` that resolves to `ContractCallResult`,
 * which should encapsulate the result of a read-only contract call.
 *
 * The keys of this record represent the names of the contract functions, and the values are the contract
 * functions themselves, adhering to the `ContractFunctionAsync` type with `ContractCallResult` as the return type.
 *
 * @template TAbi - The ABI of the contract which includes the contract functions.
 * @template TFunctionName - The names of the contract functions extracted from the ABI that are either 'pure' or 'view'.
 * @template TAbiFunction - The contract function extracted from the ABI based on the function name.
 */
type ContractFunctionRead<
    TAbi extends Abi,
    TFunctionName extends ExtractAbiFunctionNames<TAbi, 'pure' | 'view'>,
    TAbiFunction extends AbiFunction = ExtractAbiFunction<TAbi, TFunctionName>
> = Record<
    TFunctionName,
    ContractFunctionAsync<
        AbiParametersToPrimitiveTypes<TAbiFunction['outputs'], 'outputs'>,
        TAbiFunction
    >
>;

/**
 * Defines a mapping of contract function names to their corresponding transactional contract functions.
 * Each function in this record is expected to return a `Promise` that resolves to `SendTransactionResult`,
 * which should encapsulate the result of a transactional contract call (e.g., modifying state on the blockchain).
 *
 * The keys of this record represent the names of the contract functions, and the values are the contract
 * functions themselves, adhering to the `ContractFunctionAsync` type with `SendTransactionResult` as the return type.
 *
 * @template TAbi - The ABI of the contract which includes the contract functions.
 * @template TFunctionName - The names of the contract functions extracted from the ABI that are either 'payable' or 'nonpayable'.
 * @template TAbiFunction - The contract function extracted from the ABI based on the function name.
 */
type ContractFunctionTransact<
    TAbi extends Abi,
    TFunctionName extends ExtractAbiFunctionNames<
        TAbi,
        'payable' | 'non payable'
    >,
    TAbiFunction extends AbiFunction = ExtractAbiFunction<TAbi, TFunctionName>
> = Record<
    TFunctionName,
    ContractFunctionAsync<SendTransactionResult, TAbiFunction>
>;

/**
 * Defines a mapping of contract event names to their corresponding filter contract functions.
 * Each function in this record is expected to return a `ContractFilter` instance, which can be used to
 * filter events emitted by the contract.
 *
 * The keys of this record represent the names of the contract events, and the values are the contract
 * functions themselves, adhering to the `ContractEventSync` type with `ContractFilter` as the return type.
 *
 * @template TAbi - The ABI (Application Binary Interface) of the contract.
 * @template TEventName - The names of the events extracted from the ABI.
 * @template TAbiEvent - The event type extracted from the ABI for a given event name.
 */
type ContractFunctionFilter<
    TAbi extends Abi,
    TEventName extends ExtractAbiEventNames<TAbi>,
    TAbiEvent extends AbiFunction = ExtractAbiEvent<TAbi, TEventName>
> = Record<TEventName, ContractEventSync<ContractFilter<TAbi>, TAbiEvent>>;

/**
 * Defines a mapping of contract function names to their corresponding transactional contract functions.
 * Each function in this record is expected to return a value of type `TransactionClause`, which represents
 * a transaction clause that can be used to interact with the contract.
 *
 * The keys of this record represent the names of the contract functions, and the values are the contract
 * functions themselves, adhering to the `ContractFunctionSync` type with `ContractClause` as the return type.
 *
 * @template TAbi - The ABI (Application Binary Interface) of the contract.
 * @template TFunctionName - The names of the functions extracted from the ABI, restricted to 'pure' or 'view' functions.
 * @template TAbiFunction - The function type extracted from the ABI for a given function name.
 */
type ContractFunctionClause<
    TAbi extends Abi,
    TFunctionName extends ExtractAbiFunctionNames<TAbi, 'pure' | 'view'>,
    TAbiFunction extends AbiFunction = ExtractAbiFunction<TAbi, TFunctionName>
> = Record<TFunctionName, ContractFunctionSync<ContractClause, TAbiFunction>>;

/**
 * Defines a mapping of contract event names to their corresponding filter criteria contract functions.
 * Each function in this record is expected to return a value of type `FilterCriteria`, which represents
 * the criteria used to filter events emitted by the contract.
 *
 * The keys of this record represent the names of the contract events, and the values are the contract
 * functions themselves, adhering to the `ContractEventSync` type with `FilterCriteria` as the return type.
 *
 * @template TAbi - The ABI (Application Binary Interface) of the contract.
 * @template TEventName - The names of the events extracted from the ABI.
 * @template TAbiEvent - The event type extracted from the ABI for a given event name.
 */
type ContractFunctionCriteria<
    TAbi extends Abi,
    TEventName extends ExtractAbiEventNames<TAbi>,
    TAbiEvent extends AbiFunction = ExtractAbiEvent<TAbi, TEventName>
> = Record<TEventName, ContractEventSync<FilterCriteria, TAbiEvent>>;

/**
 * Available types for the VeChainProvider's
 *
 * @NOTE: We use our supported providers instead of ethers providers.
 * If you create a new provider, you need to add it here.
 */
type AvailableVeChainProviders = VeChainProvider | HardhatVeChainProvider;

/**
 * Type for transaction input
 *
 * @note Types of the properties can differ WRT ethers.TransactionRequest
 */
interface TransactionRequestInput {
    /**
     *  The target of the transaction.
     */
    to?: null | string;

    /**
     *  The sender of the transaction.
     */
    from?: null | string;

    /**
     * Nonce value for various purposes.
     * Basic is to prevent replay attack by make transaction unique.
     * Every transaction with same chainTag, blockRef, ... must have different nonce.
     */
    nonce?: string | number;

    /**
     * Transaction gas.
     */
    gas?: string | number;

    /**
     *  The maximum amount of gas to allow this transaction to consume.
     */
    gasLimit?: string;

    /**
     *  The gas price to use for legacy transactions or transactions on
     *  legacy networks.
     *
     *  Most of the time the ``max*FeePerGas`` is preferred.
     */
    gasPrice?: string;

    /**
     * Coefficient used to calculate the gas price for the transaction.
     * Value must be between 0 and 255.
     */
    gasPriceCoef?: number;

    /**
     *  The transaction data.
     */
    data?: string;

    /**
     *  The transaction value (in wei).
     */
    value?: string | number;

    /**
     *  When using ``call`` or ``estimateGas``, this allows a specific
     *  block to be queried. Many backends do not support this and when
     *  unsupported errors are silently squelched and ``"latest"`` is used.
     */
    blockTag?: string;

    /**
     * Add clauses to ethers.TransactionRequest
     */
    clauses?: TransactionClause[];

    /**
     * The ID of the transaction that this transaction depends on.
     */
    dependsOn?: string;

    /**
     * The expiration time of the transaction.
     * The transaction will expire after the number of blocks specified by this value.
     */
    expiration?: number;

    /**
     * 8 bytes prefix of some block's ID
     */
    blockRef?: string;

    /**
     * Last byte of genesis block ID
     */
    chainTag?: number;

    /**
     * A reserved field intended for features use.
     *
     * In standard EVM transactions, this reserved field typically is not present.
     * However, it's been designed to cater to VIP-191, which deals with fee delegation.
     *
     * If the `features` within the `reserved` field is set as `1111...111`, it indicates that the transaction has been delegated.
     * The method to check if the transaction is delegated is:
     *
     * ```typescript
     * reserved.features & 1 === 1
     * ```
     *
     * @example
     *
     * 1.
     * ```typescript
     * feature = 111101;
     * isDelegated = (111101 & 111111) === 111101; // false (not delegated)
     * ```
     *
     * 2.
     * ```typescript
     * feature = 111111;
     * isDelegated = (111111 & 111111) === 111111; // true (delegated)
     * ```
     *
     * @remarks
     * For more information on the subject, refer to {@link https://github.com/vechain/VIPs/blob/master/vips/VIP-191.md | VIP-191}.
     */
    reserved?: {
        /**
         * Tx feature bits
         */
        features?: number;
        /**
         * Unused
         */
        unused?: Buffer[];
    };

    /**
     * The VeChainThor blockchain allows for transaction-level proof of work (PoW) and converts the proved work into extra gas price that will be used by
     * the system to generate more reward to the block generator, the Authority Masternode, that validates the transaction.
     * In other words, users can utilize their local computational power to make their transactions more likely to be included in a new block.
     *
     * @link [VeChainThor Proof of Work](https://docs.vechain.org/core-concepts/transactions/transaction-calculation#proof-of-work)
     */
    provedWork?: string;

    /**
     * The address that pays for the gas fee of the transaction simulation.
     * If different from the caller, then a delegated transaction is simulated.
     */
    gasPayer?: string;

    // START: NOT SUPPORTED FIELDS in VeChain BUT added to take compatibility with ethers

    /**
     *  The chain ID for the network this transaction is valid on.
     */
    chainId?: string;

    /**
     *  The [[link-eip-2930]] access list. Storage slots included in the access
     *  list are //warmed// by preloading them, so their initial cost to
     *  fetch is guaranteed, but then each additional access is cheaper.
     */
    accessList?: null | vechain_sdk_core_ethers.AccessListish;

    /**
     *  A custom object, which can be passed along for network-specific
     *  values.
     */
    customData?: unknown;

    /**
     *  The [[link-eip-1559]] maximum priority fee to pay per gas.
     */
    maxPriorityFeePerGas?: string;

    /**
     *  The [[link-eip-1559]] maximum total fee to pay per gas. The actual
     *  value used is protocol enforced to be the block's base fee.
     */
    maxFeePerGas?: string;

    /**
     *  The transaction type.
     */
    type?: null | number;

    /**
     *  When using ``call``, this enables CCIP-read, which permits the
     *  provider to be redirected to web-based content during execution,
     *  which is then further validated by the contract.
     *
     *  There are potential security implications allowing CCIP-read, as
     *  it could be used to expose the IP address or user activity during
     *  the fetch to unexpected parties.
     */
    enableCcipRead?: boolean;

    // END: NOT SUPPORTED FIELDS in VeChain BUT added to take compatibility with ethers
}

/**
 * A signer for VeChain, adding specific methods for VeChain to the ethers signer
 *
 * @NOTE: Su support completely our providers (that already support ethers provider format)
 * We use our supported providers instead of ethers providers
 */
interface VeChainSigner {
    /**
     * The provider attached to this Signer (if any).
     */
    provider: AvailableVeChainProviders | null;

    /**
     *  Returns a new instance of this Signer connected to //provider// or detached
     *  from any Provider if null.
     *
     * @param provider - The provider to connect to
     * @returns a new instance of this Signer connected to //provider// or detached
     */
    connect: (provider: AvailableVeChainProviders | null) => this;

    /**
     * Get the address of the Signer.
     *
     * @returns the address of the signer
     */
    getAddress: () => Promise<string>;

    /**
     *  Gets the next nonce required for this Signer to send a transaction.
     *
     *  @param blockTag - The blocktag to base the transaction count on, keep in mind
     *         many nodes do not honour this value and silently ignore it [default: ``"latest"``]
     *
     *  @NOTE: This method generates a random number as nonce. It is because the nonce in VeChain is a 6-byte number.
     */
    getNonce: (blockTag?: string) => Promise<string>;

    /**
     *  Prepares a {@link TransactionRequestInput} for calling:
     *  - resolves ``to`` and ``from`` addresses
     *  - if ``from`` is specified, check that it matches this Signer
     *
     *  @note: Here the base support of multi-clause transaction is added.
     *  So, if clauses are provided in the transaction, it will be used as it is.
     *  Otherwise, standard transaction will be prepared.
     *
     *  @param transactionToPopulate - The call to prepare
     *  @returns the prepared call transaction
     */
    populateCall: (
        transactionToPopulate: TransactionRequestInput
    ) => Promise<TransactionRequestInput>;

    /**
     *  Prepares a {@link TransactionRequestInput} for sending to the network by
     *  populating any missing properties:
     *  - resolves ``to`` and ``from`` addresses
     *  - if ``from`` is specified , check that it matches this Signer
     *  - populates ``nonce`` via ``signer.getNonce("pending")``
     *  - populates gas parameters via ``signer.estimateGas(tx)``
     *  - ... and other necessary properties
     *
     *  @param transactionToPopulate - The call to prepare
     *  @returns the prepared transaction
     */
    populateTransaction: (
        transactionToPopulate: TransactionRequestInput
    ) => Promise<TransactionBody>;

    /**
     *  Estimates the required gas required to execute //tx// on the Blockchain. This
     *  will be the expected amount a transaction will require
     *  to successfully run all the necessary computations and store the needed state
     *  that the transaction intends.
     *
     *  @param transactionToEstimate - The transaction to estimate gas for
     *  @returns the total estimated gas required
     */
    estimateGas: (
        transactionToEstimate: TransactionRequestInput
    ) => Promise<number>;

    /**
     *  Evaluates the //tx// by running it against the current Blockchain state. This
     *  cannot change state and has no cost, as it is effectively simulating
     *  execution.
     *
     *  This can be used to have the Blockchain perform computations based on its state
     *  (e.g. running a Contract's getters) or to simulate the effect of a transaction
     *  before actually performing an operation.
     *
     *  @param transactionToEvaluate - The transaction to evaluate
     *  @param revision - The revision to evaluate the transaction against
     *  @returns the result of the evaluation
     */
    call: (
        transactionToEvaluate: TransactionRequestInput,
        revision?: string
    ) => Promise<string>;

    /**
     * Signs %%transactionToSign%%, returning the fully signed transaction. This does not
     * populate any additional properties within the transaction.
     *
     * @param transactionToSign - The transaction to sign
     * @returns The fully signed transaction
     */
    signTransaction: (
        transactionToSign: TransactionRequestInput
    ) => Promise<string>;

    /**
     * --- START: TEMPORARY COMMENT ---
     * Probably add in the future with vechain_sdk_core_ethers.TransactionRequest as a return type
     * --- END: TEMPORARY COMMENT ---
     *
     *  Sends %%transactionToSend%% to the Network. The ``signer.populateTransaction(transactionToSend)``
     *  is called first to ensure all necessary properties for the
     *  transaction to be valid have been populated first.
     *
     *  @param transactionToSend - The transaction to send
     *  @returns The transaction response
     */
    sendTransaction: (
        transactionToSend: TransactionRequestInput
    ) => Promise<string>;

    /**
     *  Signs an [[link-eip-191]] prefixed a personal message.
     *
     *  If the %%message%% is a string, it is signed as UTF-8 encoded bytes. It is **not**
     *  interpreted as a [[BytesLike]]; so the string ``"0x1234"`` is signed as six
     *  characters, **not** two bytes.
     *
     *  To sign that example as two bytes, the Uint8Array should be used
     *  (i.e. ``new Uint8Array([ 0x12, 0x34 ])``).
     */
    signMessage: (message: string | Uint8Array) => Promise<string>;

    /**
     *  Signs the [[link-eip-712]] typed data.
     */
    signTypedData: (
        domain: vechain_sdk_core_ethers.TypedDataDomain,
        types: Record<string, vechain_sdk_core_ethers.TypedDataField[]>,
        value: Record<string, unknown>
    ) => Promise<string>;

    /**
     *  Resolves an VNS Name to an address.
     */
    resolveName: (vnsName: string) => Promise<null | string>;
}

/**
 * Utility method to convert a transaction body to a transaction request input
 *
 * @param transactionBody - The transaction body to convert
 * @param from - The address of the sender
 *
 * @returns The transaction request input
 */
declare function transactionBodyToTransactionRequestInput(transactionBody: TransactionBody$1, from: string): TransactionRequestInput;

declare const signerUtils: {
    transactionBodyToTransactionRequestInput: typeof transactionBodyToTransactionRequestInput;
};

/**
 * Abstract VeChain signer.
 * This abstract class avoids people every time implementing standard signer
 * methods.
 * By implementing this abstract class, it will be easier to create new signers
 */
declare abstract class VeChainAbstractSigner implements VeChainSigner {
    /**
     * The provider attached to this Signer (if any).
     */
    provider: AvailableVeChainProviders | null;
    /**
     * Create a new VeChainPrivateKeySigner.
     * A signer can be initialized using a private key.
     *
     * @param provider - The provider to connect to
     */
    protected constructor(provider: AvailableVeChainProviders | null);
    /**
     *  Returns a new instance of this Signer connected to //provider// or detached
     *  from any Provider if null.
     *
     * @param provider - The provider to connect to
     * @returns a new instance of this Signer connected to //provider// or detached
     */
    abstract connect(provider: AvailableVeChainProviders | null): this;
    /**
     * Get the address of the Signer.
     *
     * @returns the address of the signer
     */
    abstract getAddress(): Promise<string>;
    /**
     *  Prepares a {@link TransactionRequestInput} for calling:
     *  - resolves ``to`` and ``from`` addresses
     *  - if ``from`` is specified, check that it matches this Signer
     *
     *  @note: Here the base support of multi-clause transaction is added.
     *  So, if clauses are provided in the transaction, it will be used as it is.
     *  Otherwise, standard transaction will be prepared.
     *
     *  @param transactionToPopulate - The call to prepare
     *  @returns the prepared call transaction
     */
    populateCall(transactionToPopulate: TransactionRequestInput): Promise<TransactionRequestInput>;
    /**
     *  Prepares a {@link TransactionRequestInput} for sending to the network by
     *  populating any missing properties:
     *  - resolves ``to`` and ``from`` addresses
     *  - if ``from`` is specified , check that it matches this Signer
     *  - populates ``nonce`` via ``signer.getNonce("pending")``
     *  - populates gas parameters via ``signer.estimateGas(tx)``
     *  - ... and other necessary properties
     *
     *  @param transactionToPopulate - The call to prepare
     *  @returns the prepared transaction
     */
    populateTransaction(transactionToPopulate: TransactionRequestInput): Promise<TransactionBody$1>;
    /**
     *  Estimates the required gas required to execute //tx// on the Blockchain. This
     *  will be the expected amount a transaction will require
     *  to successfully run all the necessary computations and store the needed state
     *  that the transaction intends.
     *
     *  @param transactionToEstimate - The transaction to estimate gas for
     *  @returns the total estimated gas required
     */
    estimateGas(transactionToEstimate: TransactionRequestInput): Promise<number>;
    /**
     *  Evaluates the //tx// by running it against the current Blockchain state. This
     *  cannot change state and has no cost, as it is effectively simulating
     *  execution.
     *
     *  This can be used to have the Blockchain perform computations based on its state
     *  (e.g. running a Contract's getters) or to simulate the effect of a transaction
     *  before actually performing an operation.
     *
     *  @param transactionToEvaluate - The transaction to evaluate
     *  @param revision - The block number or block ID of which the transaction simulation is based on
     *  @returns the result of the evaluation
     */
    call(transactionToEvaluate: TransactionRequestInput, revision?: string): Promise<string>;
    /**
     *  Gets the next nonce required for this Signer to send a transaction.
     *
     *  @param blockTag - The blocktag to base the transaction count on, keep in mind
     *         many nodes do not honour this value and silently ignore it [default: ``"latest"``]
     *
     *  @NOTE: This method generates a random number as nonce. It is because the nonce in VeChain is a 6-byte number.
     */
    getNonce(blockTag?: string): Promise<string>;
    /**
     * Signs %%transactionToSign%%, returning the fully signed transaction. This does not
     * populate any additional properties with eth_getTransactionCount: RPC_METHODS, p0: (string | undefined)[], args: EIP1193RequestArguments* @param transactionToSign - The transaction to sign
     * @returns The fully signed transaction
     */
    abstract signTransaction(transactionToSign: TransactionRequestInput): Promise<string>;
    /**
     * --- START: TEMPORARY COMMENT ---
     * Probably add in the future with vechain_sdk_core_ethers.TransactionRequest as a return type
     * --- END: TEMPORARY COMMENT ---
     *
     *  Sends %%transactionToSend%% to the Network. The ``signer.populateTransaction(transactionToSend)``
     *  is called first to ensure all necessary properties for the
     *  transaction to be valid have been populated first.
     *
     *  @param transactionToSend - The transaction to send
     *  @returns The transaction response
     */
    abstract sendTransaction(transactionToSend: TransactionRequestInput): Promise<string>;
    /**
     * Signs an [[link-eip-191]] prefixed a personal message.
     *
     * @param {string|Uint8Array} message - The message to be signed.
     *                                      If the %%message%% is a string, it is signed as UTF-8 encoded bytes.
     *                                      It is **not** interpreted as a [[BytesLike]];
     *                                      so the string ``"0x1234"`` is signed as six characters, **not** two bytes.
     * @return {Promise<string>} - A Promise that resolves to the signature as a string.
     */
    abstract signMessage(message: string | Uint8Array): Promise<string>;
    /**
     * Signs the [[link-eip-712]] typed data.
     *
     * @param {vechain_sdk_core_ethers.TypedDataDomain} domain - The domain parameters used for signing.
     * @param {Record<string, vechain_sdk_core_ethers.TypedDataField[]>} types - The types used for signing.
     * @param {Record<string, unknown>} value - The value data to be signed.
     *
     * @return {Promise<string>} - A promise that resolves with the signature string.
     */
    abstract signTypedData(domain: vechain_sdk_core_ethers.TypedDataDomain, types: Record<string, vechain_sdk_core_ethers.TypedDataField[]>, value: Record<string, unknown>): Promise<string>;
    /**
     * Use vet.domains to resolve name to address
     * @param vnsName - The name to resolve
     * @returns the address for a name or null
     */
    resolveName(vnsName: string): Promise<null | string>;
    /**
     * Build the transaction clauses
     * form a transaction given as input
     *
     * @param transaction - The transaction to sign
     * @returns The transaction clauses
     */
    protected _buildClauses(transaction: TransactionRequestInput): TransactionClause[];
}

/**
 * Basic VeChain signer with the private key.
 * This signer can be initialized using a private key.
 */
declare class VeChainPrivateKeySigner extends VeChainAbstractSigner {
    private readonly privateKey;
    private readonly MESSAGE_PREFIX;
    /**
     * Create a new VeChainPrivateKeySigner.
     * A signer can be initialized using a private key.
     *
     * @param privateKey - The private key of the signer
     * @param provider - The provider to connect to
     */
    constructor(privateKey: Buffer, provider: AvailableVeChainProviders | null);
    /**
     *  Returns a new instance of this Signer connected to //provider// or detached
     *  from any Provider if null.
     *
     * @param provider - The provider to connect to
     * @returns a new instance of this Signer connected to //provider// or detached
     */
    connect(provider: AvailableVeChainProviders | null): this;
    /**
     * Get the address of the Signer.
     *
     * @returns the address of the signer
     */
    getAddress(): Promise<string>;
    /**
     * Signs %%transactionToSign%%, returning the fully signed transaction. This does not
     * populate any additional properties with eth_getTransactionCount: RPC_METHODS, p0: (string | undefined)[], args: EIP1193RequestArguments* @param transactionToSign - The transaction to sign
     * @returns The fully signed transaction
     */
    signTransaction(transactionToSign: TransactionRequestInput): Promise<string>;
    /**
     * --- START: TEMPORARY COMMENT ---
     * Probably add in the future with vechain_sdk_core_ethers.TransactionRequest as a return type
     * --- END: TEMPORARY COMMENT ---
     *
     *  Sends %%transactionToSend%% to the Network. The ``signer.populateTransaction(transactionToSend)``
     *  is called first to ensure all necessary properties for the
     *  transaction to be valid have been populated first.
     *
     *  @param transactionToSend - The transaction to send
     *  @returns The transaction response
     */
    sendTransaction(transactionToSend: TransactionRequestInput): Promise<string>;
    /**
     * Signs an [EIP-191](https://eips.ethereum.org/EIPS/eip-191) prefixed a personal message.
     *
     * This function is a drop-in replacement for {@link ethers.BaseWallet.signMessage} function.
     *
     * @param {string|Uint8Array} message - The message to be signed.
     *                                      If the %%message%% is a string, it is signed as UTF-8 encoded bytes.
     *                                      It is **not** interpreted as a [[BytesLike]];
     *                                      so the string ``"0x1234"`` is signed as six characters, **not** two bytes.
     * @return {Promise<string>} - A Promise that resolves to the signature as a string.
     */
    signMessage(message: string | Uint8Array): Promise<string>;
    /**
     * Signs the [[link-eip-712]] typed data.
     *
     * This function is a drop-in replacement for {@link ethers.BaseWallet.signTypedData} function,
     * albeit Ethereum Name Services are not resolved because he resolution depends on **ethers** provider implementation.
     *
     * @param {ethers.TypedDataDomain} domain - The domain parameters used for signing.
     * @param {Record<string, ethers.TypedDataField[]>} types - The types used for signing.
     * @param {Record<string, unknown>} value - The value data to be signed.
     *
     * @return {Promise<string>} - A promise that resolves with the signature string.
     */
    signTypedData(domain: vechain_sdk_core_ethers.TypedDataDomain, types: Record<string, vechain_sdk_core_ethers.TypedDataField[]>, value: Record<string, unknown>): Promise<string>;
    /**
     * Signs a transaction internal method
     *
     * @param transaction - The transaction to sign
     * @param delegator - The delegator to use
     * @param thorClient - The ThorClient instance
     * @param privateKey - The private key of the signer
     * @returns The fully signed transaction
     */
    _signFlow(transaction: TransactionRequestInput, delegator: SignTransactionOptions | null, thorClient: ThorClient, privateKey: Buffer): Promise<string>;
    /**
     * Signs a transaction where the gas fee is paid by a delegator.
     *
     * @param unsignedTransactionBody - The unsigned transaction body to sign.
     * @param originPrivateKey - The private key of the origin account.
     * @param  - (Optional) The private key of the delegator account.
     * @param thorClient - The ThorClient instance.
     * @param delegatorOptions - Optional parameters for the request. Includes the `delegatorUrl` and `delegatorPrivateKey` fields.
     *                  Only one of the following options can be specified: `delegatorUrl`, `delegatorPrivateKey`.
     *
     * @returns A promise that resolves to the signed transaction.
     *
     * @throws an error if the delegation fails.
     */
    private _signWithDelegator;
}

/**
 * A class representing a smart contract deployed on the blockchain.
 */
declare class Contract<TAbi extends Abi> {
    readonly thor: ThorClient;
    readonly address: string;
    readonly abi: InterfaceAbi;
    private signer?;
    readonly deployTransactionReceipt: TransactionReceipt | undefined;
    read: ContractFunctionRead<TAbi, ExtractAbiFunctionNames<TAbi, 'pure' | 'view'>>;
    transact: ContractFunctionTransact<TAbi, ExtractAbiFunctionNames<TAbi, 'payable' | 'nonpayable'>>;
    filters: ContractFunctionFilter<TAbi, ExtractAbiEventNames<TAbi>>;
    clause: ContractFunctionClause<TAbi, ExtractAbiFunctionNames<TAbi>>;
    criteria: ContractFunctionCriteria<TAbi, ExtractAbiEventNames<TAbi>>;
    private contractCallOptions;
    private contractTransactionOptions;
    /**
     * Initializes a new instance of the `Contract` class.
     * @param address The address of the contract.
     * @param abi The Application Binary Interface (ABI) of the contract, which defines the contract's methods and events.
     * @param thor An instance of ThorClient to interact with the blockchain.
     * @param signer The signer caller used for signing transactions.
     * @param transactionReceipt (Optional) The transaction receipt of the contract deployment.
     */
    constructor(address: string, abi: InterfaceAbi, thor: ThorClient, signer?: VeChainSigner, transactionReceipt?: TransactionReceipt);
    /**
     * Sets the options for contract calls.
     * @param options - The contract call options to set.
     * @returns The updated contract call options.
     */
    setContractReadOptions(options: ContractCallOptions): ContractCallOptions;
    /**
     * Clears the current contract call options, resetting them to an empty object.
     * @returns The updated contract call options.
     */
    getContractReadOptions(): ContractCallOptions;
    /**
     * Clears the current contract call options, resetting them to an empty object.
     */
    clearContractReadOptions(): void;
    /**
     * Sets the options for contract transactions.
     * @param options - The contract transaction options to set.
     * @returns The updated contract transaction options.
     */
    setContractTransactOptions(options: ContractTransactionOptions): ContractTransactionOptions;
    /**
     * Retrieves the options for contract transactions.
     * @returns The contract transaction options.
     */
    getContractTransactOptions(): ContractTransactionOptions;
    /**
     * Clears the current contract transaction options, resetting them to an empty object.
     */
    clearContractTransactOptions(): void;
    /**
     * Sets the private key of the caller for signing transactions.
     * @param signer - The caller signer
     */
    setSigner(signer: VeChainSigner): VeChainSigner;
    /**
     * Get the caller signer used for signing transactions.
     * @returns The signer used for signing transactions.
     */
    getSigner(): VeChainSigner | undefined;
    /**
     * Retrieves the function fragment for the specified function name.
     * @param prop - The name of the function.
     * @private
     * @throws An error if the specified function name or symbol is not found in the contract's ABI. The error includes
     * the `ERROR_CODES.ABI.INVALID_FUNCTION` code and a message indicating the function is not present in the ABI.
     *
     */
    getFunctionFragment(prop: string | symbol): FunctionFragment;
    /**
     * Retrieves the event fragment for the specified event name.
     * @param eventName - The name of the event.
     * @return The event fragment for the specified event name.
     */
    getEventFragment(eventName: string | symbol): EventFragment$1;
}

/**
 * A factory class for deploying smart contracts to a blockchain using a ThorClient.
 */
declare class ContractFactory<TAbi extends Abi> {
    /**
     * The ABI (Application Binary Interface) of the contract.
     */
    private readonly abi;
    /**
     * The bytecode of the smart contract.
     */
    private readonly bytecode;
    /**
     * The signer used for signing transactions.
     */
    private readonly signer;
    /**
     * An instance of ThorClient to interact with the blockchain.
     */
    private readonly thor;
    /**
     * The result of the deployment transaction, undefined until a deployment is started.
     */
    private deployTransaction;
    /**
     * Initializes a new instance of the `ContractFactory` class.
     * @param abi The Application Binary Interface (ABI) of the contract, which defines the contract's methods and events.
     * @param bytecode The compiled bytecode of the contract, representing the contract's executable code.
     * @param signer The signer used for signing transactions during contract deployment, ensuring the deployer's identity.
     * @param thor An instance of ThorClient to interact with the blockchain.
     */
    constructor(abi: InterfaceAbi, bytecode: string, signer: VeChainSigner, thor: ThorClient);
    /**
     * Initiates the deployment of a smart contract.
     *
     * This method performs several steps to deploy a smart contract:
     * 1. Builds a transaction clause for deploying the contract.
     * 2. Estimates the gas cost required for the transaction.
     * 3. Constructs the transaction body with the estimated gas cost.
     * 4. Signs the transaction using the provided signer.
     * 5. Sends the signed transaction to the blockchain.
     *
     * @param {DeployParams?} deployParams (Optional) parameters for contract deployment.
     * @param {ContractTransactionOptions?} options (Optional) transaction options, such as gas limit.
     * @returns {Promise<ContractFactory>} A promise that resolves to the instance of `ContractFactory`,
     *          allowing for fluent chaining of further actions or queries.
     * @throws {Error} Throws an error if any step in the deployment process fails.
     */
    startDeployment(deployParams?: DeployParams, options?: ContractTransactionOptions): Promise<ContractFactory<TAbi>>;
    /**
     * Waits for the completion of a contract deployment transaction.
     *
     * This method checks for the presence of a deployed transaction result and then
     * waits for the transaction to be processed. Upon successful processing, it
     * constructs and returns a new `Contract` instance based on the transaction receipt.
     *
     * @throws An error if the deployed transaction result is not found or if the
     *         contract deployment fails.
     * @returns {Promise<Contract>} A promise that resolves to a `Contract` instance
     *          once the deployment transaction is completed.
     */
    waitForDeployment(): Promise<Contract<TAbi>>;
    /**
     * Returns the deploy transaction result, if available.
     */
    getDeployTransaction(): SendTransactionResult | undefined;
}

/**
 * Represents a module for interacting with smart contracts on the blockchain.
 */
declare class ContractsModule {
    readonly thor: ThorClient;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the VeChain blockchain API.
     */
    constructor(thor: ThorClient);
    /**
     * Creates a new instance of `ContractFactory` configured with the specified ABI, bytecode, and signer.
     * This factory is used to deploy new smart contracts to the blockchain network managed by this instance.
     *
     * @param abi - The Application Binary Interface (ABI) of the contract, which defines the contract's methods and events.
     * @param bytecode - The compiled bytecode of the contract, representing the contract's executable code.
     * @param signer - The signer used for signing transactions during contract deployment, ensuring the deployer's identity.
     * @returns An instance of `ContractFactory` configured with the provided ABI, bytecode, and signer, ready for deploying contracts.
     */
    createContractFactory<TAbi extends Abi>(abi: TAbi, bytecode: string, signer: VeChainSigner): ContractFactory<TAbi>;
    /**
     * Initializes and returns a new Contract instance with the provided parameters.
     *
     * @param address - The blockchain address of the contract to load.
     * @param abi - The Application Binary Interface (ABI) of the contract, which defines the contract's methods and structures.
     * @param signer - Optional. The signer caller, used for signing transactions when interacting with the contract.
     * @returns A new instance of the Contract, initialized with the provided address, ABI, and optionally, a signer.
     */
    load<Tabi extends Abi>(address: string, abi: Tabi, signer?: VeChainSigner): Contract<Tabi>;
    /**
     * Executes a read-only call to a smart contract function, simulating the transaction to obtain the result.
     *
     * @param contractAddress - The address of the smart contract to interact with.
     * @param functionFragment - The function fragment, including the name and types of the function to be called, derived from the contract's ABI.
     * @param functionData - An array of arguments to be passed to the smart contract function, corresponding to the function's parameters.
     * @param contractCallOptions - (Optional) Additional options for the contract call, such as the sender's address, gas limit, and gas price, which can affect the simulation's context.
     * @returns A promise that resolves to the decoded output of the smart contract function call, the format of which depends on the function's return types.
     *
     * The function simulates a transaction using the provided parameters without submitting it to the blockchain, allowing read-only operations to be tested without incurring gas costs or modifying the blockchain state.
     */
    executeCall(contractAddress: string, functionFragment: FunctionFragment, functionData: unknown[], contractCallOptions?: ContractCallOptions): Promise<ContractCallResult | string>;
    /**
     * Executes a read-only call to multiple smart contract functions, simulating the transaction to obtain the results.
     * @param clauses - An array of contract clauses to interact with the contract functions.
     * @param options - (Optional) Additional options for the contract call, such as the sender's address, gas limit, and gas price, which can affect the simulation's context.
     */
    executeMultipleClausesCall(clauses: ContractClause[], options?: SimulateTransactionOptions): Promise<Array<ContractCallResult | string>>;
    /**
     * Executes a transaction to interact with a smart contract function.
     *
     * @param signer - The signer used for signing the transaction.
     * @param contractAddress - The address of the smart contract.
     * @param functionFragment - The function fragment, including the name and types of the function to be called, derived from the contract's ABI.
     * @param functionData - The input data for the function.
     * @param options - (Optional) An object containing options for the transaction body. Includes all options of the `buildTransactionBody` method
     *                  besides `isDelegated`.
     *                  @see {@link TransactionsModule.buildTransactionBody}
     *
     * @returns A promise resolving to a SendTransactionResult object.
     */
    executeTransaction(signer: VeChainSigner, contractAddress: string, functionFragment: FunctionFragment, functionData: unknown[], options?: ContractTransactionOptions): Promise<SendTransactionResult>;
    /**
     * Executes a transaction to interact with multiple smart contract functions.
     * @param clauses - An array of transaction clauses to interact with the contract functions.
     * @param signer - The signer used to signing the transaction.
     */
    executeMultipleClausesTransaction(clauses: ContractClause[], signer: VeChainSigner): Promise<SendTransactionResult>;
    /**
     * Gets the base gas price in wei.
     * The base gas price is the minimum gas price that can be used for a transaction.
     * It is used to obtain the VTHO (energy) cost of a transaction.
     *
     * @link [Total Gas Price](https://docs.vechain.org/core-concepts/transactions/transaction-calculation#total-gas-price)
     *
     * @returns The base gas price in wei.
     */
    getBaseGasPrice(): Promise<unknown>;
}

/* --- Input options start --- */

type EstimateGasOptions = Omit<SimulateTransactionOptions, 'caller'> & {
    /**
     * percentage of gas to add on top of the estimated gas.
     * Value must be between (0, 1]. (e.g. 0.1 = 10%)
     */
    gasPadding?: number;
};

/* --- Input options end --- */

/* --- Responses Outputs start --- */

/**
 * The result of estimating the gas cost of a transaction.
 */
interface EstimateGasResult {
    /**
     * The total gas cost estimation of the transaction.
     */
    totalGas: number;

    /**
     * Boolean indicating whether the transaction reverted or not.
     */
    reverted: boolean;

    /**
     * Decoded Solidity revert reasons for each clause.
     * If the n-th clause reverted, then the n-th element of this array will be the decoded revert reason for the n-th clause.
     *
     * @note revertReasons will be undefined if the transaction did not revert.
     */
    revertReasons: Array<string | bigint>;

    /**
     * The error message produced by the Virtual Machine.
     *
     * @note vmErrors will be undefined if the transaction did not revert.
     */
    vmErrors: string[];
}

/**
 * The `GasModule` handles gas related operations and provides
 * convenient methods for estimating the gas cost of a transaction.
 */
declare class GasModule {
    readonly thor: ThorClient;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the VeChain blockchain API.
     */
    constructor(thor: ThorClient);
    /**
     * Simulates a transaction and returns an object containing information regarding the gas used and whether the transaction reverted.
     *
     * @param clauses - The clauses of the transaction to simulate.
     * @param caller - The address of the account sending the transaction.
     * @param options - Optional parameters for the request. Includes all options of the `simulateTransaction` method excluding the `caller` option.
     *                  @see {@link TransactionsClient#simulateTransaction}
     *                  Also, includes the `gasPadding` option which is a percentage of gas to add on top of the estimated gas. The value must be between (0, 1].
     *
     * @note The caller option is suggested as estimation without this parameter may not be accurate.
     *
     * @returns An object containing information regarding the gas used and whether the transaction reverted, together with the decoded revert reason and VM errors.
     *
     * @throws an error if the clauses are invalid or if an error occurs during the simulation.
     */
    estimateGas(clauses: SimulateTransactionClause[], caller?: string, options?: EstimateGasOptions): Promise<EstimateGasResult>;
}

/**
 * Config for the '4byte' name type
 */
type FourByteNameConfig = Record<string, unknown>;

/**
 * Return type for the '4byte' name type
 */
type FourByteNameReturnType = Record<string, number>;

/**
 * Config for the 'bigram' name type
 */
type BigramNameConfig = Record<string, unknown>;

/**
 * Return type for the 'bigram' name type
 */
type BigramNameReturnType = Record<string, number>;

/**
 * Config for the 'call' name type
 */
type CallNameConfig = Record<string, unknown>;

/**
 * Return type for the 'call' name type
 */
interface CallNameReturnType {
    /**
     * Transaction parameters
     */
    from: string;
    gas: string;
    gasUsed: string;
    to: string;
    input: string;
    output?: string;

    /**
     * Transaction errors (if any)
     */
    error?: string;

    /**
     * Trace clause type (/debug/tracers endpoint)
     */
    calls?: Array<{
        from: string;
        gas: string;
        gasUsed: string;
        to: string;
        input: string;
        output: string;
        type: string;
    }>;

    /**
     * Trace contract type (/debug/tracers/call endpoint)
     */
    value?: string;
    type?: string;
}

/**
 * Config for the default ('' or null) name type
 */
type DefaultNameConfig = Record<string, unknown>;

/**
 * Return type for the default ('' or null) name type
 */
interface DefaultNameReturnType {
    gas: number;
    failed: boolean;
    returnValue: string;
    structLogs: Array<{
        pc: number;
        op: string;
        gas: number;
        gasCost: number;
        depth: number;
        stack: string[];
    }>;
}

/**
 * Config for the 'evmdis' name type
 */
type EVMDisNameConfig = Record<string, unknown>;

/**
 * Return type for the 'evmdis' name type
 */
type EVMDisNameReturnType = Array<{
    op: number;
    depth: number;
    result: string[];
    len: number;
}>;

/**
 * Config for the 'noop' name type
 */
type NoopNameConfig = Record<string, unknown>;

/**
 * Return type for the 'noop' name type
 */
type NoopNameReturnType = Record<string, unknown>;

/**
 * Config for the 'opcount' name type
 */
type OPCountNameConfig = Record<string, unknown>;

/**
 * Return type for the 'opcount' name type
 */
type OPCountNameReturnType = number;

/**
 * Config for the 'prestate' name type
 */
type PreStateNameConfig = Record<string, unknown>;

/**
 * Return type for the 'prestate' name type
 */
type PreStateNameReturnType = Record<
    string,
    {
        balance: string;
        energy: string;
        code?: string;
        storage?: Record<string, string>;
    }
>;

/**
 * Config for the 'trigram' name type
 */
type TrigramNameConfig = Record<string, unknown>;

/**
 * Return type for the 'trigram' name type
 */
type TrigramNameReturnType = Record<string, number>;

/**
 * Config for the 'unigram' name type
 */
type UnigramNameConfig = Record<string, unknown>;

/**
 * Return type for the 'unigram' name type
 */
type UnigramNameReturnType = Record<string, number>;

/**
 * Type for target of TraceTransactionClause.
 */
interface TransactionTraceTarget {
    /**
     * Block ID.
     */
    blockID: string;
    /**
     * Transaction ID or Transaction index.
     */
    transaction: number | string;
    /**
     * Clause index.
     */
    clauseIndex: number;
}

/**
 * TracerName is the name of the tracer to use.
 *
 * It determines Output and Input configuration.
 *
 * An empty name stands for the default struct logger tracer.
 */
type TracerName =
    | ''
    | '4byte'
    | 'call'
    | 'noop'
    | 'prestate'
    | 'unigram'
    | 'bigram'
    | 'trigram'
    | 'evmdis'
    | 'opcount'
    | null;

/**
 * The configuration of the tracer.
 *
 * Used for traceTransactionClause and traceContractCall functions.
 *
 * It is specific to the name of the tracer.
 *
 * @see{TracerName}
 */
type TracerConfig<TraceNameType extends TracerName | undefined> =
    TraceNameType extends ''
        ? DefaultNameConfig
        : TraceNameType extends '4byte'
          ? FourByteNameConfig
          : TraceNameType extends 'call'
            ? CallNameConfig
            : TraceNameType extends 'noop'
              ? NoopNameConfig
              : TraceNameType extends 'prestate'
                ? PreStateNameConfig
                : TraceNameType extends 'unigram'
                  ? UnigramNameConfig
                  : TraceNameType extends 'bigram'
                    ? BigramNameConfig
                    : TraceNameType extends 'trigram'
                      ? TrigramNameConfig
                      : TraceNameType extends 'evmdis'
                        ? EVMDisNameConfig
                        : TraceNameType extends 'opcount'
                          ? OPCountNameConfig
                          : TraceNameType extends null
                            ? DefaultNameConfig
                            : TraceNameType extends undefined
                              ? DefaultNameConfig
                              : never;

/**
 * The return type of the tracer.
 *
 * Used for traceTransactionClause and traceContractCall functions.
 *
 * It is specific to the name of the tracer.
 *
 * @see{TracerName}
 */
type TraceReturnType<TraceNameType extends TracerName | undefined> =
    TraceNameType extends ''
        ? DefaultNameReturnType
        : TraceNameType extends '4byte'
          ? FourByteNameReturnType
          : TraceNameType extends 'call'
            ? CallNameReturnType
            : TraceNameType extends 'noop'
              ? NoopNameReturnType
              : TraceNameType extends 'prestate'
                ? PreStateNameReturnType
                : TraceNameType extends 'unigram'
                  ? UnigramNameReturnType
                  : TraceNameType extends 'bigram'
                    ? BigramNameReturnType
                    : TraceNameType extends 'trigram'
                      ? TrigramNameReturnType
                      : TraceNameType extends 'evmdis'
                        ? EVMDisNameReturnType
                        : TraceNameType extends 'opcount'
                          ? OPCountNameReturnType
                          : TraceNameType extends null
                            ? DefaultNameReturnType
                            : TraceNameType extends undefined
                              ? DefaultNameReturnType
                              : never;

/**
 * Type for input for trace contract call - target contract.
 */
interface ContractCallTraceContractTargetInput {
    /**
     * The recipient of the call. Null indicates contract deployment.
     */
    to?: string | null;

    /**
     * The input data for the contract call.
     */
    data?: string;

    /**
     * The amount of token to be transferred.
     */
    value?: string;
}

/**
 * Type for input for trace contract call - transaction options.
 */
type ContractCallTraceTransactionOptionsInput = Omit<
    SimulateTransactionOptions,
    'revision'
>;

/**
 * Type for input options
 * for retrieve storage range function
 */
interface RetrieveStorageRangeInputOptions {
    /**
     * The address of the contract/ account to be traced.
     */
    address?: string;

    /**
     * The start key of the storage range.
     * Default is 0x0000000000000000000000000000000000000000000000000000000000000000.
     */
    keyStart?: string;

    /**
     * The maximum number of results to be returned. Default is 1000.
     */
    maxResult?: number;
}

/**
 * Return type for retrieve storage range function
 */
interface RetrieveStorageRangeReturnType {
    /**
     * The next key to be used for the next retrieve storage range call.
     */
    nextKey: string | null;

    /**
     * The data is non-nullable, but an empty object is returned if no data is found.
     */
    storage: Record<
        string,
        {
            /**
             * Storage key.
             */
            key: string;

            /**
             * Storage value.
             */
            value: string;
        }
    >;
}

/** The `DebugModule` class encapsulates functionality to handle Debug
 * on the VeChainThor blockchain.
 */
declare class DebugModule {
    readonly thor: ThorClient;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the VeChain blockchain API.
     */
    constructor(thor: ThorClient);
    /**
     * Trace transaction clause.
     *
     * This endpoint allows you to create a tracer for a specific clause.
     * Tracers are instrumental in monitoring and analyzing the execution flow within the EVM.
     * You can customize the tracer using various options to tailor it to your specific debugging needs.
     *
     * @param input - The input for the trace transaction clause. It has:
     * * target - The target of the tracer. It is a combination of blockID, transaction (transaction ID or index into block), and clauseIndex.
     * * config - The configuration of the tracer. It is specific to the name of the tracer.
     * @param name - The name of the tracer to use. It determines Output and Input configuration.
     *
     * @throws{InvalidDataTypeError} - If the input is invalid.
     */
    traceTransactionClause(input: {
        target: TransactionTraceTarget;
        config?: TracerConfig<typeof name>;
    }, name?: TracerName): Promise<TraceReturnType<typeof name>>;
    /**
     * Trace a contract call.
     *
     * This endpoint enables clients to create a tracer for a specific function call.
     * You can customize the tracer using various options to suit your debugging requirements.
     *
     * @param input - The input for the trace contract call. It has:
     * * contractInput - The contract call information.
     * * config - The configuration of the tracer. It is specific to the name of the tracer.
     * * transactionOptions - The transaction options.
     * @param name - The name of the tracer to use. It determines Output and Input configuration.
     *
     * @throws{InvalidDataTypeError} - If the input is invalid.
     */
    traceContractCall(input: {
        contractInput?: ContractCallTraceContractTargetInput;
        transactionOptions?: ContractCallTraceTransactionOptionsInput;
        config?: TracerConfig<typeof name>;
    }, name?: TracerName): Promise<TraceReturnType<typeof name>>;
    /**
     * Retrieve the storage range.
     *
     * This endpoint enables clients to retrieve the storage range for the
     * coordinates specified in the `input` parameter.
     *
     * @param input - the coordinates to retrieve the storage range. It has:
     * * target - {@link TransactionTraceTarget} specifies `blockID`,
     *           `transaction` address and `clauseIndex` number.
     * * options - {@link RetrieveStorageRangeInputOptions} specified the
     *           `address` if the contract or account to retrieve the
     *           storage range for. Nullable.
     */
    retrieveStorageRange(input: {
        target: TransactionTraceTarget;
        options?: RetrieveStorageRangeInputOptions;
    }): Promise<RetrieveStorageRangeReturnType>;
    /**
     * Validate target of traceTransactionClause and retrieveStorageRange.
     *
     * @param target - Target of traceTransactionClause and retrieveStorageRange to validate.
     * @param functionName - The name of the function.
     *
     * @private
     *
     * @throws{InvalidDataTypeError} - If the input is invalid.
     */
    private validateTarget;
}

/**
 * The `ThorClient` class serves as an interface to interact with the VeChain Thor blockchain.
 * It provides various methods.
 * Essentially, it can be considered a layer on top of the `ThorestClient`.
 */
declare class ThorClient {
    readonly httpClient: HttpClient;
    /**
     * The `AccountsModule` instance
     */
    readonly accounts: AccountsModule;
    /**
     * The `NodesModule` instance
     */
    readonly nodes: NodesModule;
    /**
     * The `BlocksModule` instance
     */
    readonly blocks: BlocksModule;
    /**
     * The `LogsModule` instance used for interacting with log-related endpoints.
     */
    readonly logs: LogsModule;
    readonly transactions: TransactionsModule;
    /**
     * The 'ContractClient' instance
     */
    readonly contracts: ContractsModule;
    /**
     * The `GasModule` instance
     */
    readonly gas: GasModule;
    /**
     * The `DebugModule` instance
     */
    readonly debug: DebugModule;
    /**
     * Constructs a new `ThorClient` instance with a given HTTP client.
     *
     * @param httpClient - The HTTP client instance used for making network requests.
     * @param options - (Optional) Other optional parameters for polling and error handling.
     */
    constructor(httpClient: HttpClient, options?: BlocksModuleOptions);
    /**
     * Creates a new `ThorClient` instance from a given URL.
     *
     * @param networkUrl - The URL of the network to connect to.
     * @param options - (Optional) Other optional parameters for polling and error handling.
     * @returns A new `ThorClient` instance.
     */
    static fromUrl(networkUrl: string, options?: BlocksModuleOptions): ThorClient;
    /**
     * Destroys the `ThorClient` instance by stopping the event polling
     * and any other cleanup.
     */
    destroy(): void;
}

/**
 * The `AccountModule` class provides methods to interact with account-related endpoints
 * of the VeChainThor blockchain. It allows fetching details, bytecode, and storage data
 * for a specific blockchain account.
 */
declare class AccountsModule {
    readonly thor: ThorClient;
    /**
     * Initializes a new instance of the `Thor` class.
     * @param thor - The Thor instance used to interact with the VeChain blockchain API.
     */
    constructor(thor: ThorClient);
    /**
     * Retrieves account details such as balance of VET, VTHO, and if the address is a smart contract.
     *
     * @param address - The account address to query details for.
     * @param options - (Optional) Other optional parameters for the request.
     * @returns A promise that resolves to an object containing the account details (balance, energy, hasCode).
     *
     * @throws {InvalidDataTypeError} - Will throw an error if the revision is not a valid block number or ID
     *         or if the address is not a valid address.
     */
    getAccount(address: string, options?: AccountInputOptions): Promise<AccountDetail>;
    /**
     * Fetches the bytecode of a contract at a given address.
     *
     * @param address - The contract address to get the bytecode for.
     * @param options - (Optional) Other optional parameters for the request.
     * @returns A promise that resolves to the contract bytecode as a string.
     *
     * @throws {InvalidDataTypeError} - Will throw an error if the revision is not a valid block number or ID
     *         or if the address is not a valid address.
     */
    getBytecode(address: string, options?: AccountInputOptions): Promise<string>;
    /**
     * Retrieves the value from a smart contract's storage at a given position.
     *
     * @param address - The contract address to query storage from.
     * @param position - The position in the storage to retrieve the value from. Must be a 32 bytes hex string (66 characters including `0x` prefix).
     * @param options - (Optional) Other optional parameters for the request.
     * @returns A promise that resolves to the storage value in hex string format.
     *
     * @throws {InvalidDataTypeError} - Will throw an error if the revision is not a valid block number or ID
     *         or if the position is not a 32 bytes hex string or if the address is not a valid address.
     */
    getStorageAt(address: string, position: string, options?: AccountInputOptions): Promise<string>;
}

/**
 * Represent a single account in a provider internal wallet.
 * Basically an account is a triple of **address**, **private key** and **public key**.
 */
interface ProviderInternalWalletAccount {
    /**
     * Address of the account.
     */
    address: string;

    /**
     * Private key of the account.
     */
    privateKey?: Buffer;

    /**
     * Public key of the account.
     */
    publicKey?: Buffer;
}

/**
 * Represent a provider internal base wallet.
 * Basically it is a list {@link ProviderInternalWalletAccount} used to contain account data into provider.
 * A provider internal wallet is able to generate a signer when it is needed by the provider.
 *
 * e.g., Provider can need the Signer with methods like eth_sendTransaction, ...
 *
 * @note To be compatible with provider-internal-wallet stack it is better
 * to implement this interface for each kind of provider internal wallet you want to use.
 */
interface ProviderInternalWallet {
    /**
     * Options for signing a transaction with delegator.
     */
    delegator?: SignTransactionOptions;

    /**
     * List of accounts in the wallet.
     */
    accounts: ProviderInternalWalletAccount[];

    /**
     * Get a signer into the internal wallet provider
     * for the given address.
     *
     * @param parentProvider - The parent provider of the Internal Wallet.
     * @param addressOrIndex - Address or index of the account.
     * @returns The signer for the given address.
     */
    getSigner: (
        parentProvider: AvailableVeChainProviders,
        addressOrIndex?: string | number
    ) => Promise<VeChainSigner | null>;

    /**
     * SYNC Version of getSigner()
     *
     * Get a signer into the internal wallet provider
     * for the given address.
     *
     * @param parentProvider - The parent provider of the Internal Wallet.
     * @param addressOrIndex - Address or index of the account.
     * @returns The signer for the given address.
     */
    getSignerSync: (
        parentProvider: AvailableVeChainProviders,
        addressOrIndex?: string | number
    ) => VeChainSigner | null;

    /**
     * Get the list of addresses in the wallet.
     *
     * @returns The list of addresses in the wallet.
     */
    getAddresses: () => Promise<string[]>;

    /**
     * SYNC Version of getAddresses()
     *
     * Get the list of addresses in the wallet.
     *
     * @returns The list of addresses in the wallet.
     */
    getAddressesSync: () => string[];

    /**
     * Get an account given an address or an index.
     *
     * @param addressOrIndex - Address or index of the account.
     * @returns The account with the given address, or null if not found.
     */
    getAccount: (
        addressOrIndex?: string | number
    ) => Promise<ProviderInternalWalletAccount | null>;

    /**
     * SYNC Version of getAccount()
     *
     * Get an account given an address or an index.
     *
     * @param addressOrIndex - Address or index of the account.
     * @returns The account with the given address, or null if not found.
     */
    getAccountSync: (
        addressOrIndex?: string | number
    ) => ProviderInternalWalletAccount | null;

    /**
     * Get the options for signing a transaction with delegator (if any).
     *
     * @returns The options for signing a transaction with delegator.
     */
    getDelegator: () => Promise<SignTransactionOptions | null>;

    /**
     * SYNC Version of getDelegator()
     *
     * Get the options for signing a transaction with delegator (if any).
     *
     * @returns The options for signing a transaction with delegator.
     */
    getDelegatorSync: () => SignTransactionOptions | null;
}

/**
 * Abstract implementation of Provider internal wallet class.
 */
declare abstract class AbstractProviderInternalWallet implements ProviderInternalWallet {
    /**
     * List of accounts in the wallet.
     */
    readonly accounts: ProviderInternalWalletAccount[];
    /**
     * Options for signing a transaction with delegator.
     */
    readonly delegator?: SignTransactionOptions;
    /**
     * Create a new wallet.
     *
     * @param accounts List of accounts in the wallet.
     * @param options Optional options for signing a transaction with delegator.
     */
    constructor(accounts: ProviderInternalWalletAccount[], options?: {
        delegator?: SignTransactionOptions;
    });
    /**
     * Get a signer into the internal wallet provider
     * for the given address.
     *
     * @param parentProvider - The parent provider of the Internal Wallet.
     * @param addressOrIndex - Address of the account.
     * @returns The signer for the given address.
     */
    abstract getSigner(parentProvider: AvailableVeChainProviders, addressOrIndex?: string | number): Promise<VeChainSigner | null>;
    /**
     * SYNC Version of getSigner()
     *
     * Get a signer into the internal wallet provider
     * for the given address.
     *
     * @param parentProvider - The parent provider of the Internal Wallet.
     * @param addressOrIndex - Address or index of the account.
     * @returns The signer for the given address.
     */
    getSignerSync(parentProvider: AvailableVeChainProviders, addressOrIndex?: string | number): VeChainSigner | null;
    /**
     * Get the list of addresses in the wallet.
     *
     * @returns The list of addresses in the wallet.
     */
    abstract getAddresses(): Promise<string[]>;
    /**
     * SYNC Version of getAddresses()
     *
     * Get the list of addresses in the wallet.
     *
     * @returns The list of addresses in the wallet.
     */
    getAddressesSync(): string[];
    /**
     * Get an account given an address or an index.
     *
     * @param addressOrIndex - Address or index of the account.
     * @returns The account with the given address, or null if not found.
     */
    abstract getAccount(addressOrIndex?: string | number): Promise<ProviderInternalWalletAccount | null>;
    /**
     * SYNC Version of getAccount()
     *
     * Get an account given an address or an index.
     *
     * @param addressOrIndex - Address or index of the account.
     * @returns The account with the given address, or null if not found.
     */
    getAccountSync(addressOrIndex?: string | number): ProviderInternalWalletAccount | null;
    /**
     * Get the options for signing a transaction with delegator (if any).
     *
     * @returns The options for signing a transaction with delegator.
     */
    abstract getDelegator(): Promise<SignTransactionOptions | null>;
    /**
     * SYNC Version of getDelegator()
     *
     * Get the options for signing a transaction with delegator (if any).
     *
     * @returns The options for signing a transaction with delegator.
     */
    getDelegatorSync(): SignTransactionOptions | null;
}

/**
 * Provider internal Base wallet class.
 *
 * This is the most basic wallet implementation we can have:
 * * This wallet is generated by a list of private keys
 */
declare class ProviderInternalBaseWallet extends AbstractProviderInternalWallet {
    /**
     * Get a signer into the internal wallet provider
     * for the given address.
     *
     * @param parentProvider - The parent provider of the Internal Wallet.
     * @param addressOrIndex - Address of the account.
     * @returns The signer for the given address.
     */
    getSigner(parentProvider: AvailableVeChainProviders, addressOrIndex?: string | number): Promise<VeChainSigner | null>;
    /**
     * Get the list of addresses in the wallet.
     *
     * @returns The list of addresses in the wallet.
     */
    getAddresses(): Promise<string[]>;
    /**
     * Get an account given an address or an index.
     *
     * @param addressOrIndex - Address or index of the account.
     * @returns The account with the given address, or null if not found.
     */
    getAccount(addressOrIndex?: string | number): Promise<ProviderInternalWalletAccount | null>;
    /**
     * Get the options for signing a transaction with delegator (if any).
     *
     * @returns The options for signing a transaction with delegator.
     */
    getDelegator(): Promise<SignTransactionOptions | null>;
}

declare class ProviderInternalHDWallet extends ProviderInternalBaseWallet {
    /**
     * Mnemonic of the wallet.
     */
    readonly mnemonic: string[];
    /**
     * Derivation path of the wallet.
     */
    readonly derivationPath: string;
    /**
     * Number of accounts to generate.
     */
    readonly count: number;
    /**
     * Initial index of the accounts to generate.
     */
    readonly initialIndex: number;
    /**
     * Create a new HD wallet.
     *
     * @param mnemonic - Mnemonic of the wallet as an array of words.
     * @param count - Number of accounts to generate.
     * @param initialIndex - Initial index of the accounts to generate.
     * @param derivationPath - Derivation path of the wallet.
     * @param options - Options for signing a transaction with delegator.
     */
    constructor(mnemonic: string[], count?: number, initialIndex?: number, derivationPath?: string, options?: {
        delegator?: SignTransactionOptions;
    });
}

/**
 * Represents the parameters for a subscription.
 * This interface includes all necessary details for managing a subscription.
 */
interface SubscriptionParams {
    /**
     * The unique identifier for the subscription.
     * This string uniquely identifies the subscription instance.
     */
    readonly subscription: string;

    /**
     * The result associated with the subscription.
     * This can be of any type and contains the data or outcome that the subscription yields.
     */
    readonly result: unknown;
}

/**
 * Describes an event related to a subscription.
 * This interface encapsulates the method invoked and the parameters associated with the subscription event.
 */
interface SubscriptionEvent {
    /**
     * The name of the method associated with the subscription event.
     */
    readonly method: string;

    /**
     * The parameters associated with the subscription event.
     * This includes all necessary details such as the subscription identifier and the result.
     */
    readonly params: SubscriptionParams;
}

/**
 * Defines the options used to filter events in a subscription. These options can specify which events to include based on various blockchain parameters.
 */
interface FilterOptions {
    /**
     * The contract address or addresses to filter for events.
     */
    address?: string | string[];

    /**
     * The starting block number (inclusive) from which to begin filtering events.
     */
    fromBlock?: string;

    /**
     * The ending block number (inclusive) at which to stop filtering events.
     */
    toBlock?: string;

    /**
     * An array of topic identifiers to filter events. Each event must match all specified topics to be included.
     */
    topics?: string[];

    /**
     * The hash of a specific block. If defined, only events from this block are included.
     */
    blockhash?: string;
}

/**
 * Represents a subscription to a specific type of data or event within a system.
 * This could be used for subscribing to updates or changes in the data.
 */
interface Subscription {
    /**
     * The type of subscription, indicating what kind of data or events this subscription pertains to.
     */
    type: string;

    /**
     * Optional configuration options for the subscription that can filter or modify the data received.
     */
    options?: FilterOptions;
}

interface NewHeadsSubscription {
    readonly subscriptionId: string;
    readonly subscription: Subscription;
}

/**
 * Manages multiple subscriptions within a system, keeping track of active subscriptions and the current block number.
 */
interface SubscriptionManager {
    /**
     * A map of subscription identifiers to Subscription objects, keeping track of all log-related subscriptions.
     */
    logSubscriptions: Map<string, Subscription>;

    /**
     * An optional collection of subscriptions specifically for new block headers, indexed by a unique identifier.
     */
    newHeadsSubscription?: NewHeadsSubscription;

    /**
     * The most recent block number that has been processed or observed by the manager, serving as a point of reference for new events.
     */
    currentBlockNumber: number;
}

/**
 * Our core provider class for VeChain
 */
declare class VeChainProvider extends EventEmitter implements EIP1193ProviderMessage {
    readonly thorClient: ThorClient;
    readonly wallet?: ProviderInternalWallet | undefined;
    readonly enableDelegation: boolean;
    readonly subscriptionManager: SubscriptionManager;
    /**
     * Poll instance for subscriptions
     *
     * @private
     */
    private pollInstance?;
    /**
     * Constructor for VeChainProvider
     *
     * @param thorClient - ThorClient instance.
     * @param wallet - ProviderInternalWallet instance. It is optional because the majority of the methods do not require a wallet.
     * @param enableDelegation - Enable fee delegation or not.
     *
     */
    constructor(thorClient: ThorClient, wallet?: ProviderInternalWallet | undefined, enableDelegation?: boolean);
    /**
     * Destroys the provider by closing the thorClient and stopping the provider poll instance if present.
     * This is because thorClient and the provider might be initialized with a polling interval.
     */
    destroy(): void;
    /**
     * This method is used to send a request to the provider.
     * Basically, it is a wrapper around the RPCMethodsMap.
     *
     * @param args - Method and parameters to be used for the request.
     */
    request(args: EIP1193RequestArguments): Promise<unknown>;
    /**
     * Initializes and starts the polling mechanism for subscription events.
     * This method sets up an event poll that periodically checks for new events related to active
     * subscriptions, such as 'newHeads' or log subscriptions. When new data is available, it emits
     * these events to listeners.
     *
     * This method leverages the `Poll.createEventPoll` utility to create the polling mechanism,
     * which is then started by invoking `startListen` on the poll instance.
     */
    startSubscriptionsPolling(): boolean;
    /**
     * Stops the polling mechanism for subscription events.
     * This method stops the polling mechanism for subscription events, if it is active.
     *
     * @returns {boolean} A boolean indicating whether the polling mechanism was stopped.
     */
    stopSubscriptionsPolling(): boolean;
    /**
     * Checks if there are active subscriptions.
     * This method checks if there are any active log subscriptions or a new heads subscription.
     *
     * @returns {boolean} A boolean indicating whether there are active subscriptions.
     */
    isThereActiveSubscriptions(): boolean;
    /**
     * Returns the poll instance for subscriptions.
     */
    getPollInstance(): EventPoll<SubscriptionEvent[]> | undefined;
    /**
     * Fetches logs for all active log subscriptions managed by `subscriptionManager`.
     * This method iterates over each log subscription, constructs filter options based on the
     * subscription details, and then queries for logs using these filter options.
     *
     * Each log query is performed asynchronously, and the method waits for all queries to complete
     * before returning. The result for each subscription is encapsulated in a `SubscriptionEvent`
     * object, which includes the subscription ID and the fetched logs.
     *
     * This function is intended to be called when there's a need to update or fetch the latest
     * logs for all active subscriptions, typically in response to a new block being mined or
     * at regular intervals to keep subscription data up to date.
     *
     * @returns {Promise<SubscriptionEvent[]>} A promise that resolves to an array of `SubscriptionEvent`
     * objects, each containing the subscription ID and the corresponding logs fetched for that
     * subscription. The promise resolves to an empty array if there are no active log subscriptions.
     */
    private getLogsRPC;
    /**
     * Fetches the current block details from the VeChain node.
     *
     * @private
     */
    private getCurrentBlock;
    /**
     * Get a signer into the internal wallet provider
     * for the given address.
     *
     * @param addressOrIndex - Address of index of the account.
     * @returns The signer for the given address.
     */
    getSigner(addressOrIndex?: string | number): Promise<VeChainSigner | null>;
    /**
     * Use vet.domains to resolve name to address
     * @param vnsName - The name to resolve
     * @returns the address for a name or null
     */
    resolveName(vnsName: string): Promise<null | string>;
    /**
     * Use vet.domains to look up a verified primary name for an address
     * @param address - The address to lookup
     * @returns the primary name for an address or null
     */
    lookupAddress(address: string): Promise<null | string>;
}

/**
 * Type for a JSON-RPC request.
 * It is a wrapped JsonRpcRequest of hardhat.
 * you can find the original into "hardhat/types".
 *
 * @note we wrap here the original type to avoid
 * the usage of hardhat dependency for provider package.
 */
interface JsonRpcRequest {
    jsonrpc: string;
    method: string;
    params: unknown[];
    id: number;
}

/**
 * Type for a JSON-RPC response.
 * It is a wrapped JsonRpcResponse of hardhat.
 * you can find the original into "hardhat/types".
 *
 * @note we wrap here the original type to avoid
 * the usage of hardhat dependency for provider package.
 */
interface JsonRpcResponse {
    jsonrpc: string;
    id: number;
    result?: unknown;
    error?: {
        code: number;
        message: string;
        data?: unknown;
    };
}

/**
 * Type for hardhat error function callback
 *
 * @note we use this callback to delegate the hardhat import
 * to the final code who will use provider
 */
type BuildHardhatErrorFunction = (message: string, parent?: Error) => Error;

/**
 * This class is a wrapper for the VeChainProvider that Hardhat uses.
 *
 * It exposes the interface that Hardhat expects, and uses the VeChainProvider as wrapped provider.
 */
declare class HardhatVeChainProvider extends VeChainProvider {
    /**
     * Debug mode.
     */
    debug: boolean;
    /**
     * The function to use to build Hardhat errors.
     */
    buildHardhatErrorFunctionCallback: BuildHardhatErrorFunction;
    /**
     * Constructor with the network configuration.
     *
     * @param walletToUse - The wallet to use.
     * @param nodeUrl - The node url to use
     * @param buildHardhatErrorFunctionCallback - The function to use to build Hardhat errors.
     * @param debug - Debug mode.
     * @param enableDelegation - Enable fee delegation or not.
     */
    constructor(walletToUse: ProviderInternalWallet, nodeUrl: string, buildHardhatErrorFunctionCallback: BuildHardhatErrorFunction, debug?: boolean, enableDelegation?: boolean);
    /**
     * Overload off the send method
     *
     * @param method - The method to call.
     * @param params - The parameters to pass to the method.
     */
    send(method: string, params?: unknown[] | undefined): Promise<unknown>;
    /**
     * Overload off the sendAsync method.
     * It is the same of the send method, but with a callback.
     * Instead of returning the result, it calls the callback with the result.
     *
     * @param payload - The request payload (it contains method and params as 'send' method).
     * @param callback - The callback to call with the result.
     */
    sendAsync(payload: JsonRpcRequest, callback: (error: unknown, response: JsonRpcResponse) => void): Promise<void>;
    /**
     * It sends the request through the VeChainProvider.
     *
     * @param args - The request arguments.
     */
    request(args: EIP1193RequestArguments): Promise<unknown>;
}

/**
 * Override the JsonRpcPayload, JsonRpcResult and JsonRpcError types from ethers.
 */
type JsonRpcPayload = vechain_sdk_core_ethers.JsonRpcPayload;
type JsonRpcResult = vechain_sdk_core_ethers.JsonRpcResult;
type JsonRpcError = vechain_sdk_core_ethers.JsonRpcError;

/**
 * JSON RPC provider for ethers.
 * Needed to customize ethers functionality into hardhat plugin.
 */
declare class JSONRPCEthersProvider extends vechain_sdk_core_ethers.JsonRpcApiProvider {
    /**
     * Instance of Hardhat VeChain provider to wrap
     */
    hardhatProvider: HardhatVeChainProvider;
    /**
     * Constructor with parameters.
     *
     * @param chainId - The chain id of the network
     * @param networkName - The name of the network
     * @param hardhatProvider - The hardhat provider to wrap
     */
    constructor(chainId: number, networkName: string, hardhatProvider: HardhatVeChainProvider);
    /**
     * Override the send method to use the hardhat provider and to call _start method.
     *
     * @param method - The method to call
     * @param params - The parameters of the method
     */
    send(method: string, params: unknown[] | Record<string, unknown>): Promise<unknown>;
    /**
     * Internal method to send the payload to the hardhat provider.
     * This method is able to send multiple payloads. (send in batch)
     *
     * @param payload - The payload to send (request and method)'s
     */
    _send(payload: JsonRpcPayload | JsonRpcPayload[]): Promise<Array<JsonRpcResult | JsonRpcError>>;
}

/**
 * List of all valid ethereum RPC methods
 *
 * @note following links for more details:
 * * https://eth.wiki/json-rpc/API
 * * https://ethereum.github.io/execution-apis/api-documentation/
 */
declare enum RPC_METHODS {
    /**
     * STATUS:
     * * Implemented in web3-providers-connex: True
     * * Required for hardhat: True -> @see https://github.com/vechain/vechain-sdk/issues/462
     * * Possible to implement: True (Already implemented in web3-providers-connex)
     */
    eth_blockNumber = "eth_blockNumber",
    eth_chainId = "eth_chainId",
    eth_getBalance = "eth_getBalance",
    eth_getCode = "eth_getCode",
    eth_getStorageAt = "eth_getStorageAt",
    eth_estimateGas = "eth_estimateGas",
    eth_call = "eth_call",
    eth_sendRawTransaction = "eth_sendRawTransaction",
    eth_getLogs = "eth_getLogs",
    eth_getBlockByHash = "eth_getBlockByHash",
    eth_getBlockByNumber = "eth_getBlockByNumber",
    eth_accounts = "eth_accounts",
    eth_requestAccounts = "eth_requestAccounts",
    /**
     * STATUS:
     * * Implemented in web3-providers-connex: True
     * * Required for hardhat: False (BUT WE MUST INVESTIGATE BETTER) -> @see https://github.com/vechain/vechain-sdk/issues/462
     * * Possible to implement: True (Already implemented in web3-providers-connex)
     */
    eth_gasPrice = "eth_gasPrice",
    eth_getTransactionByHash = "eth_getTransactionByHash",
    eth_getTransactionCount = "eth_getTransactionCount",
    eth_getTransactionReceipt = "eth_getTransactionReceipt",
    eth_sendTransaction = "eth_sendTransaction",
    eth_syncing = "eth_syncing",
    net_version = "net_version",
    web3_clientVersion = "web3_clientVersion",
    eth_subscribe = "eth_subscribe",
    eth_unsubscribe = "eth_unsubscribe",
    debug_traceTransaction = "debug_traceTransaction",
    debug_traceCall = "debug_traceCall",
    evm_mine = "evm_mine",
    /**
     * STATUS:
     * * Implemented in web3-providers-connex: False (ONLY LISTED `EthJsonRpcMethods`array in `src/common.ts` file)
     * * Required for hardhat: False -> @see https://github.com/vechain/vechain-sdk/issues/462
     * * Possible to implement: TO UNDERSTAND
     */
    eth_coinbase = "eth_coinbase",
    eth_feeHistory = "eth_feeHistory",
    eth_getBlockTransactionCountByHash = "eth_getBlockTransactionCountByHash",
    eth_getBlockTransactionCountByNumber = "eth_getBlockTransactionCountByNumber",
    eth_getTransactionByBlockHashAndIndex = "eth_getTransactionByBlockHashAndIndex",
    eth_getTransactionByBlockNumberAndIndex = "eth_getTransactionByBlockNumberAndIndex",
    eth_getUncleByBlockHashAndIndex = "eth_getUncleByBlockHashAndIndex",
    eth_getUncleByBlockNumberAndIndex = "eth_getUncleByBlockNumberAndIndex",
    eth_getUncleCountByBlockHash = "eth_getUncleCountByBlockHash",
    eth_getUncleCountByBlockNumber = "eth_getUncleCountByBlockNumber",
    eth_getWork = "eth_getWork",
    eth_mining = "eth_mining",
    eth_hashrate = "eth_hashrate",
    eth_protocolVersion = "eth_protocolVersion",
    eth_sign = "eth_sign",
    eth_submitWork = "eth_submitWork",
    net_listening = "net_listening",
    net_peerCount = "net_peerCount",
    parity_nextNonce = "parity_nextNonce",
    eth_newFilter = "eth_newFilter",
    eth_newBlockFilter = "eth_newBlockFilter",
    eth_newPendingTransactionFilter = "eth_newPendingTransactionFilter",
    eth_getFilterLogs = "eth_getFilterLogs",
    eth_getFilterChanges = "eth_getFilterChanges",
    eth_uninstallFilter = "eth_uninstallFilter",
    /**
     * STATUS:
     * * Implemented in web3-providers-connex: False (AND NOT LISTED in `EthJsonRpcMethods`array in `src/common.ts` file. Probably NEW methods)
     * * Required for hardhat: False (BUT WE MUST INVESTIGATE IT BETTER) -> @see https://github.com/vechain/vechain-sdk/issues/462
     * * Possible to implement: TO UNDERSTAND
     *
     * @note: These methods are taken from https://ethereum.github.io/execution-apis/api-documentation/
     */
    debug_getBadBlocks = "debug_getBadBlocks",
    debug_getRawBlock = "debug_getRawBlock",
    debug_getRawHeader = "debug_getRawHeader",
    debug_getRawReceipts = "debug_getRawReceipts",
    debug_getRawTransaction = "debug_getRawTransaction",
    engine_exchangeCapabilities = "engine_exchangeCapabilities",
    engine_exchangeTransitionConfigurationV1 = "engine_exchangeTransitionConfigurationV1",
    engine_forkchoiceUpdatedV1 = "engine_forkchoiceUpdatedV1",
    engine_forkchoiceUpdatedV2 = "engine_forkchoiceUpdatedV2",
    engine_forkchoiceUpdatedV3 = "engine_forkchoiceUpdatedV3",
    engine_getPayloadBodiesByHashV1 = "engine_getPayloadBodiesByHashV1",
    engine_getPayloadBodiesByRangeV1 = "engine_getPayloadBodiesByRangeV1",
    engine_getPayloadV1 = "engine_getPayloadV1",
    engine_getPayloadV2 = "engine_getPayloadV2",
    engine_getPayloadV3 = "engine_getPayloadV3",
    engine_newPayloadV1 = "engine_newPayloadV1",
    engine_newPayloadV2 = "engine_newPayloadV2",
    engine_newPayloadV3 = "engine_newPayloadV3",
    eth_createAccessList = "eth_createAccessList",
    eth_getBlockReceipts = "eth_getBlockReceipts",
    eth_getProof = "eth_getProof",
    eth_maxPriorityFeePerGas = "eth_maxPriorityFeePerGas",
    eth_signTransaction = "eth_signTransaction"
}

/**
 * Polling interval for the subscription events polling mechanism for the VeChain provider.
 */
declare const POLLING_INTERVAL: number;

/**
 * RPC Method eth_blockNumber implementation
 *
 * @link [eth_blockNumber](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_blocknumber)
 *
 * @param thorClient - The thor client instance to use.
 *
 * @returns the latest block number as a hex string. If the block number cannot be retrieved, it will return '0x0'.
 *
 * @throws {ProviderRpcError} - Will throw an error if the retrieval of the block number fails.
 */
declare const ethBlockNumber: (thorClient: ThorClient) => Promise<string>;

/**
 * RPC Method eth_chainId implementation
 *
 * @link [eth_chainId](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_chainid)
 * @link [Chain IDs](https://chainlist.org/?search=vechain&testnets=true)
 *
 * @param thorClient - ThorClient instance.
 *
 * @returns The chain id
 */
declare const ethChainId: (thorClient: ThorClient) => Promise<string>;

/**
 * RPC Method eth_getBalance implementation
 *
 * @link [eth_getBalance](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_getbalance)
 *
 * @param thorClient - ThorClient instance.
 * @param params - The standard array of rpc call parameters.
 *                * params[0]: The address to get the balance for as a hex string.
 *                * params[1]: The block number to get the balance at as a hex string or "latest".
 *
 * @returns the balance of the account at the given address formatted to the RPC standard.
 *
 * @note Only 'latest' and 'finalized' block numbers are supported.
 *
 * @throws {ProviderRpcError} - Will throw an error if the retrieval of the balance fails.
 */
declare const ethGetBalance: (thorClient: ThorClient, params: unknown[]) => Promise<string>;

/**
 * RPC Method eth_getCode implementation
 *
 * @link [eth_getCode](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_getcode)
 *
 * @param thorClient - ThorClient instance.
 * @param params - The standard array of rpc call parameters.
 *               * params[0]: The address to get the code for as a hex string.
 *               * params[1]: The block number to get the code at as a hex string or "latest".
 *
 * @returns The code of the account at the given address formatted to the RPC standard.
 *
 * @note Only 'latest' and 'finalized' block numbers are supported.
 *
 * @throws {ProviderRpcError} - Will throw an error if the retrieval of the code fails.
 */
declare const ethGetCode: (thorClient: ThorClient, params: unknown[]) => Promise<string>;

/**
 * RPC Method eth_getStorageAt implementation
 *
 * @link [eth_getStorageAt](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_getstorageat)
 *
 * @param thorClient - ThorClient instance.
 * @param params - The standard array of rpc call parameters.
 *               * params[0]: The address to get the storage slot for as a hex string.
 *               * params[1]: The storage position to get as a hex string.
 *               * params[2]: The block number to get the storage slot at as a hex string or "latest".
 *
 * @returns The storage slot of the account at the given address formatted to the RPC standard.
 *
 * @note Only 'latest' and 'finalized' block numbers are supported.
 *
 * @throws {ProviderRpcError} - Will throw an error if the retrieval of the storage slot fails.
 */
declare const ethGetStorageAt: (thorClient: ThorClient, params: unknown[]) => Promise<string>;

/**
 * RPC Method eth_estimateGas implementation
 *
 * @link [eth_estimateGas](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_estimategas)
 *
 * @param thorClient - ThorClient instance.
 * @param params - The standard array of rpc call parameters.
 *                * params[0]: The transaction call object.
 *                 * params[1]: A string representing a block number, or one of the string tags latest, earliest, or pending.
 *
 * @note At the moment only the `to`, `value` and `data` fields are supported.
 *
 * @returns A hexadecimal of the estimate of the gas for the given transaction.
 */
declare const ethEstimateGas: (thorClient: ThorClient, params: unknown[]) => Promise<string>;

/**
 * RPC Method eth_call implementation
 *
 * @link [eth_call](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_call)
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The transaction call object
 *
 * @returns The return value of executed contract.
 */
declare const ethCall: (thorClient: ThorClient, params: unknown[]) => Promise<string>;

/**
 * RPC Method eth_sendRawTransaction implementation
 *
 * @link [eth_sendrawtransaction](https://docs.infura.io/api/networks/ethereum/json-rpc-methods/eth_sendrawtransaction)
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 *                 * params[0]: The signed transaction data as a hex string.
 *
 * @returns void
 *
 * @throws {ProviderRpcError} - Will throw an error if the transaction fails.
 * @throws {InvalidDataTypeError} - Will throw an error if the params are invalid.
 */
declare const ethSendRawTransaction: (thorClient: ThorClient, params: unknown[]) => Promise<string>;

/**
 * The return type of transaction according to the Ethereum RPC standard.
 *
 * @link [Ethereum JSON RPC Transaction Object](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_gettransactionbyhash#returns)
 */
interface TransactionRPC {
    /**
     * Hash of the transaction.
     */
    hash: string;
    /**
     * Hash of the block where this transaction is included.
     */
    blockHash: string;
    /**
     * Number of the block where this transaction is included.
     */
    blockNumber: string;
    /**
     * Address of the sender of this transaction.
     */
    from: string;
    /**
     * The address of the receiver. null when it's a contract creation transaction
     */
    to: string | null;
    /**
     * The value transferred in wei encoded as hexadecimal
     */
    value: string;
    /**
     * The gas provided by the sender, encoded as hexadecimal
     */
    gas: string;
    /**
     * The data sent along with the transaction
     */
    input: string;
    /**
     * The integer of the transaction's index position that the log was created from. null when it's a pending log
     */
    transactionIndex: string;
    /**
     * The chain id of the transaction
     */
    chainId: string;
    /**
     * The nonce of the transaction.
     *
     * @note Differs from Ethereum as it's not the sequential nonce.
     */
    nonce: string;

    // incompatible fields
    r: string;
    s: string;
    v: string;
    type: string;
    gasPrice: string;
    maxFeePerGas: string;
    maxPriorityFeePerGas: string;
    accessList: Array<{ address: string; storageKeys: string[] }>;
    yParity: string;
}

/**
 * The return type of transaction receipt logs according to the Ethereum RPC standard.
 *
 * @link [Ethereum JSON RPC Transaction Receipt Log Object](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_gettransactionreceipt#returns)
 */
interface TransactionReceiptLogsRPC {
    /**
     * The address from which this log was generated
     */
    address: string;

    /**
     * The hash of the block where this log was in
     */
    blockHash: string;

    /**
     * The block number where this log was in
     */
    blockNumber: string;

    /**
     * The 32 byte non-indexed argument of the log
     */
    data: string;

    /**
     * The integer of log index position in the block encoded as hexadecimal. null if the log is pending
     */
    logIndex: string;

    /**
     * It is true if log was removed, due to a chain reorganization and false if it's a valid log
     */
    removed: false;

    /**
     * An array of zero to four 32 Bytes DATA of indexed log arguments.
     * In Solidity, the first topic is the hash of the signature of the event (e.g. Deposit(address, bytes32, uint256)),
     * except you declare the event with the anonymous specifier
     */
    topics: string[];

    /**
     * The hash of the transaction from which this log was created from. null if the log is pending
     */
    transactionHash: string;

    /**
     * The transactions index position from which this log was created from. null if the log is pending
     */
    transactionIndex: string;
}

/**
 * Return type of transaction receipt according to the Ethereum RPC standard.
 *
 * @link [Ethereum JSON RPC Transaction Receipt Object](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_gettransactionreceipt#returns)
 */
interface TransactionReceiptRPC {
    /**
     * 32 bytes. Hash of the block including this transaction.
     */
    blockHash: string;
    /**
     * Block number including this transaction.
     */
    blockNumber: string;

    /**
     * 20 bytes. The address of the contract created, if the transaction was a contract creation, otherwise null.
     */
    contractAddress: string | null;

    /**
     * The total amount of gas used when this transaction was executed in the block.
     */
    cumulativeGasUsed: string;

    /**
     * The actual value per gas deducted from the sender's account. Before EIP-1559, equal to the gas price.
     */
    effectiveGasPrice: string;

    /**
     * 20 bytes. The address of the sender.
     */
    from: string;

    /**
     * The total amount of gas used when this transaction was executed in the block.
     */
    gasUsed: string;

    /**
     * Array of log objects, which this transaction generated.
     */
    logs: TransactionReceiptLogsRPC[];

    /**
     * 256 bytes. Bloom filter for light clients to quickly retrieve related logs.
     */
    logsBloom: string;

    /**
     *  Either 1 (success) or 0 (failure)
     */
    status: '0x0' | '0x1';

    /**
     * 20 bytes. The address of the receiver. null when it's a contract creation transaction
     */
    to: string | null;

    /**
     * 32 bytes. Hash of the transaction.
     */
    transactionHash: string;

    /**
     * Hexadecimal of the transaction's index position in the block.
     */
    transactionIndex: string;

    /**
     * The transaction type.
     * @see https://docs.infura.io/networks/ethereum/concepts/transaction-types
     */
    type: '0x0' | '0x1' | '0x2';
}

/**
 * Output formatter for Transaction Receipt details.
 * It converts the Transaction Receipt details, Transaction details and block into the RPC standard.
 *
 * @param transactionHash - The hash of the transaction to be formatted.
 * @param receipt - The Transaction Receipt to be formatted.
 * @param transaction - The Transaction details to be formatted.
 * @param blockContainsTransaction - The block contains the transaction to be formatted.
 * @param chainId - The chain ID of the network.
 */
declare function formatTransactionReceiptToRPCStandard(transactionHash: string, receipt: TransactionReceipt, transaction: TransactionDetailNoRaw, blockContainsTransaction: ExpandedBlockDetail, chainId: string): TransactionReceiptRPC;

declare const transactionsFormatter: {
    formatToRPCStandard: (tx: TransactionDetailNoRaw, chainId: string, txIndex: number) => TransactionRPC;
    formatExpandedBlockToRPCStandard: (tx: TransactionsExpandedBlockDetail, block: ExpandedBlockDetail, txIndex: number, chainId: string) => TransactionRPC;
    formatTransactionReceiptToRPCStandard: typeof formatTransactionReceiptToRPCStandard;
};

/**
 * Return type of block header for RPC standard.
 */
interface BlockHeaderRPC {
    /**
     * Header number in hex string format
     */
    number: string;

    /**
     * Hash in bytes32 format
     */
    hash: string;

    /**
     * Parent hash in bytes32 format
     */
    parentHash: string;

    /**
     * Transactions root in bytes32 format
     */
    transactionsRoot: string;

    /**
     * State root in bytes32 format
     */
    stateRoot: string;
    /**
     * Receipts root in bytes32 format
     */
    receiptsRoot: string;

    /**
     * Miner address in bytes20 format
     */
    miner: string;

    /**
     * Gas limit in hex string format
     */
    gasLimit: string;

    /**
     * Gas used in hex string format
     */
    gasUsed: string;

    /**
     * Timestamp in hex string format
     */
    timestamp: string;

    /**
     * Unsupported fields
     */
    sha3Uncles: string;
    nonce: string;
    logsBloom: string;
    extraData: string;
}

/**
 * Return type of blocks for RPC standard.
 *
 * Our SDK uses `BlockDetail` type from `@vechain/sdk-network` package.
 *
 * @link [Ethereum JSON RPC Block Object](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_getblockbynumber#returns)
 */
interface BlocksRPC extends BlockHeaderRPC {
    /**
     * Block number in hex string format
     */
    size: string;

    /**
     * List of transactions as bytes32 array or TransactionRPC array
     */
    transactions: string[] | TransactionRPC[];

    /**
     * Unsupported fields
     */
    difficulty: string;
    totalDifficulty: string;
    uncles: string[];
    baseFeePerGas: string;
    mixHash: string;
}

/**
 * Return type of eth_syncing for RPC method.
 */
interface SyncBlockRPC {
    startingBlock: null;
    currentBlock: BlocksRPC | null;
    highestBlock: string | null;
}

declare const blocksFormatter: {
    formatToRPCStandard: (block: CompressedBlockDetail | ExpandedBlockDetail, chainId: string) => BlocksRPC;
};

/**
 * Available tracers for the RPC standard.
 */
type TracerNameRPC = 'call' | 'prestate';

/**
 * Return type for the following RPC endpoints:
 * * debug_traceTransaction
 * * debug_traceCall
 */
type TracerReturnTypeRPC<TracerNameType extends TracerNameRPC> =
    TracerNameType extends 'call' ? CallTracerRPC : PrestateTracerRPC;

/**
 * The return type of the 'call' tracer for the RPC standard.
 */
type CallTracerRPC = TraceReturnType<'call'> & {
    /**
     * Same of the 'call' tracer of VeChain,
     * BUT with the addition of the revertReason field.
     *
     * @note This is not part of the VeChain's 'call' tracer.
     * For this reason, it will have a default value of ''.
     */
    revertReason?: '';
};

/**
 * The return type of the 'prestate' tracer for the RPC standard.
 */
type PrestateTracerRPC = Record<
    string,
    {
        balance: string;
        code?: string;
        storage?: Record<string, string>;

        /**
         * Same of the 'prestate' tracer of VeChain,
         * BUT with the addition of the nonce field.
         * This field substitutes the 'energy' field
         * of the VeChain's 'prestate' tracer.
         *
         * @note This is not part of the VeChain's 'prestate' tracer.
         * For this reason, it will have a default value of 0.
         */
        nonce: 0;
    }
>;

/**
 * Output formatter for RPC debug endpoints:
 * * debug_traceTransaction
 * * debug_traceCall
 * It converts our endpoint calls output to the RPC standard output.
 *
 * @param tracerName - Tracer name used for the debug endpoint.
 * @param debugDetails - Debug details to be formatted.
 */
declare function formatToRPCStandard<TDebugType extends TracerNameRPC>(tracerName: TDebugType, debugDetails: TraceReturnType<TDebugType>): TracerReturnTypeRPC<'call'> | TracerReturnTypeRPC<'prestate'>;

declare const debugFormatter: {
    formatToRPCStandard: typeof formatToRPCStandard;
};

/**
 * Return type of logs according to the Ethereum RPC standard.
 */
interface LogsRPC {
    /**
     * (boolean) true when the log was removed, due to a chain reorganization. false if it's a valid log.
     */
    removed: boolean;

    /**
     * Hexadecimal of the log index position in the block. Null when it is a pending log.
     */
    logIndex: string;

    /**
     * Hexadecimal of the transaction index position from which the log created. Null when it is a pending log.
     */
    transactionIndex: string;

    /**
     * 32 bytes. Hash of the transactions from which this log was created. Null when it is a pending log.
     */
    transactionHash: string;

    /**
     * 32 bytes. Hash of the block where this log was in. Null when it is a pending log.
     */
    blockHash: string;

    /**
     * Block number where this log was in. Null when it is a pending log.
     */
    blockNumber: string;

    /**
     * 20 bytes. Address from which this log originated.
     */
    address: string;

    /**
     * Contains one or more 32-bytes non-indexed arguments of the log.
     */
    data: string;

    /**
     * An array of 0 to 4 indexed log arguments, each 32 bytes. In solidity the first topic is the hash of the signature of the event (e.g. Deposit(address,bytes32,uint256)), except when you declared the event with the anonymous specifier.
     */
    topics: string[];
}

/**
 * Output formatter for Event logs.
 * It converts the Event logs into the RPC standard.
 *
 * @param eventLogs - The Event logs to be formatted.
 */
declare const formatToLogsRPC: (eventLogs: EventLogs[]) => LogsRPC[];
/**
 * Get the criteria set for the input.
 *
 * Basically with VeChain swagger we have:
 *
 * {
 *     address = string | undefined;
 *     topic1: string | undefined;
 *     ...
 *     topic4: string | undefined;
 * }
 *
 * With RPC we can have an array of address:
 *
 * {
 *     **address = string | string[] | undefined;**
 *     topic1: string | undefined;
 * ...
 *     topic4: string | undefined;
 * }.
 *
 * To have a complete research space, we can filter by address and topics, and only by address.
 *
 * @param criteria - The criteria input.
 */
declare const getCriteriaSetForInput: (criteria: {
    address?: string | string[];
    topics?: string[];
}) => EventCriteria[];

/**
 * RPC Method eth_getLogs implementation
 *
 * @param thorClient - The thor client instance to use.
 *
 * @param params - The standard array of rpc call parameters.
 *
 * @returns An array of log objects, or an empty array if nothing has changed since last poll
 */
declare const ethGetLogs: (thorClient: ThorClient, params: unknown[]) => Promise<LogsRPC[]>;

/**
 * RPC Method eth_getBlockByHash implementation
 *
 * @link [eth_getBlockByHash](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_getblockbyhash)
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 *                 * params[0]: The block hash of block to get.
 *                 * params[1]: The transaction detail flag. If true, the block will contain the transaction details, otherwise it will only contain the transaction hashes.
 *
 * @returns the block at the given block hash formatted to the RPC standard or null if the block does not exist.
 *
 * @throws {ProviderRpcError} - Will throw an error if the retrieval of the block fails.
 */
declare const ethGetBlockByHash: (thorClient: ThorClient, params: unknown[]) => Promise<BlocksRPC | null>;

/**
 * RPC Method eth_getBlockByNumber implementation
 *
 * @link [eth_getBlockByNumber](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_getblockbynumber)
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 *                 * params[0]: The block number to get as a hex string or "latest" or "finalized".
 *                 * params[1]: The transaction detail flag. If true, the block will contain the transaction details, otherwise it will only contain the transaction hashes.
 *
 * @returns the block at the given block number formatted to the RPC standard or null if the block does not exist.
 *
 * @note
 *  * Standard RPC method `eth_getBlockByNumber` support following block numbers: hex number of block, 'earliest', 'latest', 'safe', 'finalized', 'pending'. (@see https://ethereum.org/en/developers/docs/apis/json-rpc#default-block)
 *  * Currently, VeChainonly supports hex number of block, 'latest' and 'finalized'.
 *
 * @throws {ProviderRpcError} - Will throw an error if the retrieval of the block fails.
 */
declare const ethGetBlockByNumber: (thorClient: ThorClient, params: unknown[]) => Promise<BlocksRPC | null>;

/**
 * RPC Method eth_accounts implementation
 *
 * @param provider - Provider with ProviderInternalWallet instance to use.
 */
declare const ethAccounts: (provider?: VeChainProvider) => Promise<string[]>;

/**
 * RPC Method eth_gasPrice implementation
 * @link [ethGasPrice](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_gasprice)
 * @returns The current gas price in Wei unit considering that 1 VTHO equals 1e18 Wei.
 */
declare const ethGasPrice: (thorClient: ThorClient) => Promise<string>;

/**
 * RPC Method eth_getTransactionByHash implementation
 *
 * @link [eth_getTransactionByHash](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_gettransactionbyhash)
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 *                 * params[0]: The transaction hash to get as a hex string.
 *
 * @returns the transaction at the given hash formatted to the RPC standard or null if the transaction does not exist.
 *
 * @throws {ProviderRpcError} - Will throw an error if the retrieval of the transaction fails.
 */
declare const ethGetTransactionByHash: (thorClient: ThorClient, params: unknown[]) => Promise<TransactionRPC | null>;

/**
 * RPC Method eth_getTransactionCount implementation
 *
 * @link [eth_getTransactionCount](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_gettransactioncount)
 *
 * @param params - The standard array of rpc call parameters.
 *                * params[0]: address: string, is the address to get the number of transactions from.
 *                * params[1]: A string representing a block number, or one of the string tags latest, earliest, or pending.
 *
 * @note: To respect differences between VeChain and Ethereum, in this function we will give a random number as output.
 * Basically Ethereum to get nonce to use the number of transactions sent from an address,
 * while VeChain uses a random number.
 *
 * @throws {InvalidDataTypeError} - When address parameter is invalid.
 */
declare const ethGetTransactionCount: (params: unknown[]) => Promise<string>;

/**
 * RPC Method eth_getTransactionReceipt implementation
 *
 * @param thorClient - The thor client instance to use.
 *
 * @param params - The standard array of rpc call parameters.
 *                 * params[0]: The transaction hash to get as a hex string.
 *
 * @throws {ProviderRpcError} - Will throw an error if the retrieval of the transaction fails.
 */
declare const ethGetTransactionReceipt: (thorClient: ThorClient, params: unknown[]) => Promise<TransactionReceiptRPC | null>;

/**
 * RPC Method eth_sendTransaction implementation
 *
 * @link [eth_sendTransaction](https://docs.metamask.io/wallet/reference/eth_sendtransaction/)
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 *               * params[0]: transaction - object - This describes the transaction info with following properties:
 *                   * to: 20 bytes - Address the transaction is directed to.
 *                   * from: 20 bytes [Required] - Address the transaction is sent from.
 *                   * gas: Hexadecimal value of the gas provided for the transaction execution as hex string.
 *                   * gasPrice: Hexadecimal value of the gasPrice used for each paid gas.
 *                   * value: Hexadecimal of the value sent with this transaction.
 *                   * data: Hash of the method signature and encoded parameters.
 *                   * maxPriorityFeePerGas: Maximum fee per gas the sender is willing to pay to miners in wei. Used in 1559 transactions.
 *                   * maxFeePerGas: The maximum total fee per gas the sender is willing to pay (includes the network / base fee and miner / priority fee) in wei. Used in 1559 transactions.
 * @param provider - The provider instance to use.
 *
 * @NOTE: If 'to' address is not provided.
 * It will be assumed that the transaction is a contract creation transaction.
 * The 'data' field of the transaction will be used as the contract initialization code.
 *
 * @NOTE: 'gasPrice' cannot be used together with 'maxPriorityFeePerGas' and 'maxFeePerGas'.
 * 'maxPriorityFeePerGas' and 'maxFeePerGas' are not supported in the current version.
 *
 * @throws {ProviderRpcError} - Will throw an error if the transaction fails.
 * @throws {InvalidDataTypeError} - Will throw an error if the params are invalid.ù
 */
declare const ethSendTransaction: (thorClient: ThorClient, params: unknown[], provider?: VeChainProvider) => Promise<string>;

/**
 * Transaction object input type
 */
interface BaseTransactionObjectInput {
    gas?: string;
    gasPrice?: string;
    value?: string;
    data?: string;
}

/**
 * Transaction object input type
 */
interface TransactionObjectInput extends BaseTransactionObjectInput {
    from: string;
    to?: string;
}

/**
 * RPC Method eth_syncing implementation
 *
 * @link [eth_syncing](https://docs.infura.io/networks/ethereum/json-rpc-methods/eth_syncing)
 *
 * @param thorClient - The thor client instance to use.
 *
 * @note The startingBlock parameter is not supported.
 *
 * @returns Returns an object with the sync status of the node if the node is out-of-sync and is syncing. Returns false when the node is already in sync.
 */
declare const ethSyncing: (thorClient: ThorClient) => Promise<boolean | SyncBlockRPC>;

/**
 * RPC Method web3_clientVersion implementation
 *
 * @link [web3_clientVersion](https://docs.infura.io/networks/ethereum/json-rpc-methods/web3_clientversion)
 *
 * @returns A string representing the current client version.
 */
declare const web3ClientVersion: () => Promise<string>;

/**
 * Enumerates the types of subscriptions supported by the`eth_subscribe` RPC method.
 */
declare enum SUBSCRIPTION_TYPE {
    /**
     * Subscription type for receiving notifications about new blocks added to the blockchain.
     */
    NEW_HEADS = "newHeads",
    /**
     * Subscription type for receiving log entries that match specific filter criteria,
     * allowing clients to listen for specific events emitted by smart contracts.
     */
    LOGS = "logs"
}
/**
 * Defines the parameter types accepted by the `eth_subscribe` RPC method.
 */
type ethSubscribeParams = [SUBSCRIPTION_TYPE, string | string[]] | unknown[];
/**
 * Initiates a subscription to the blockchain events based on the specified parameters.
 * This function supports subscriptions to new block headers ('newHeads') and log entries ('logs')
 * that match given filter criteria. It ensures that the provided parameters are valid and that
 * the provider is available before setting up the subscription and generating a unique subscription ID.
 *
 * @param thorClient - An instance of `ThorClient` used to interact with the blockchain, such as
 *                     retrieving the current best block when setting up a new subscription.
 * @param params - Parameters for the subscription, conforming to `ethSubscribeParams`. The first
 *                 element of the array specifies the type of subscription, and the second element
 *                 (if present) provides additional options, such as filter criteria for log subscriptions.
 * @param provider - An optional `VeChainProvider` instance that contains the subscription manager.
 *                   The subscription manager is used to store and manage active subscriptions.
 *                   If the provider is not provided or is undefined, the function throws an error.
 *
 * @returns A `Promise` that resolves to a string representing the unique ID of the created subscription.
 *
 * @throws An error if the provider is undefined, indicating that the provider is not available,
 *         or if the first parameter in `params` is not a valid subscription type.
 */
declare const ethSubscribe: (thorClient: ThorClient, params: ethSubscribeParams, provider?: VeChainProvider) => Promise<string>;

/**
 * Asynchronously unsubscribes from a VeChain event subscription.
 * This function attempts to unsubscribe from either 'newHeads' or log subscriptions
 * based on the provided `subscriptionId`. If the provider is not available or the
 * `subscriptionId` does not match any active subscriptions, it may throw an error
 * or return `false`, respectively.
 *
 * @param params - An array containing the subscription ID as its first element.
 * The subscription ID is used to identify and unsubscribe from the corresponding
 * Ethereum event subscription.
 * @param provider - An optional `VeChainProvider` instance that contains the
 * subscription manager. This manager holds the active subscriptions and is used
 * to unsubscribe from them. If the provider is not provided or is undefined,
 * the function throws an error indicating that the provider is not available.
 *
 * @returns A `Promise` that resolves to `true` if the unsubscription was successful,
 * or `false` if the specified subscription ID does not match any active subscriptions.
 *
 * @throws An error with a JSON-RPC internal error code (-32603) if the provider is
 * not available. The error includes a message indicating that the provider is
 * not defined.
 */
declare const ethUnsubscribe: (params: unknown[], provider?: VeChainProvider) => Promise<boolean>;

/**
 * RPC Method debug_traceTransaction implementation
 *
 * @link [debug_traceTransaction](https://www.quicknode.com/docs/ethereum/debug_traceTransaction)
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 *                 * params[0]: transactionHash - hex string - This describes the transaction hash of the transaction that needs to be traced.
 *                 * params[1]: options - object - This describes the options for the trace. It has the following parameters:
 *                    * tracer - string to specify the type of tracer. Currently, it supports callTracer and prestateTracer.
 *                    * timeout - string - A duration string of decimal numbers that overrides the default timeout of 5 seconds for JavaScript-based tracing calls.
 *                      Max timeout is "10s". Valid time units are "ns", "us", "ms", "s" each with an optional fraction, such as "300ms" or "2s45ms"
 *                    * tracerConfig - Object to specify configurations for the tracer. It has the following parameter:
 *                       * onlyTopCall - boolean Setting this to true will only trace the main (top-level) call and none of the sub-calls.
 *                         This avoids extra processing for each call frame if only the top-level call info are required (useful for getting revertReason).
 *
 * @throws {ProviderRpcError} - Will throw an error if the debug fails.
 * @throws {InvalidDataTypeError} - Will throw an error if the params are invalid.
 */
declare const debugTraceTransaction: (thorClient: ThorClient, params: unknown[]) => Promise<TracerReturnTypeRPC<"call"> | TracerReturnTypeRPC<"prestate">>;

/**
 * Type for trace options
 */
interface TraceOptionsRPC {
    tracer: 'callTracer' | 'prestateTracer';
    tracerConfig?: { onlyTopCall?: boolean };
    // Not supported yet
    timeout?: string;
}

/**
 * RPC Method debug_traceCall implementation
 *
 * @link [debug_traceCall](https://www.quicknode.com/docs/ethereum/debug_traceCall)
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 *                * params[0]: transaction - object - This describes the transaction info with following properties:
 *                   * from - 20 bytes - Address the transaction is sent from.
 *                   * to - 20 bytes [Required] - Address the transaction is directed to.
 *                   * gas - Hexadecimal value of the gas provided for the transaction execution as hex string.
 *                   * gasPrice - Hexadecimal value of the gasPrice used for each paid gas.
 *                   * value - Hexadecimal of the value sent with this transaction.
 *                   * data - Hash of the method signature and encoded parameters.
 *                * params[1]: blockNumber - string - The block number parameter. A hexadecimal number or (latest, earliest or pending). (NOT SUPPORTED YET)
 *                * params[2]: options - object - This describes the options for the trace. It has the following parameters:
 *                   * tracer - string to specify the type of tracer. Currently, it supports callTracer and prestateTracer.
 *                   * tracerConfig - Object to specify configurations for the tracer. It has the following parameters:
 *                      * onlyTopCall - boolean Setting this to true will only trace the main (top-level) call and none of the sub-calls. This avoids extra processing for each call frame if only the top-level call info are required (useful for getting revertReason).
 *
 * @throws {ProviderRpcError} - Will throw an error if the debug fails.
 * @throws {InvalidDataTypeError} - Will throw an error if the params are invalid.
 */
declare const debugTraceCall: (thorClient: ThorClient, params: unknown[]) => Promise<TracerReturnTypeRPC<"call"> | TracerReturnTypeRPC<"prestate">>;

/**
 * RPC Method evm_mine implementation
 *
 * @link [evm_mine](https://hardhat.org/hardhat-network/docs/explanation/mining-modes)
 *
 * @param thorClient - The thor client instance to use.
 *
 * @returns The new block or null if the block is not available.
 */
declare const evmMine: (thorClient: ThorClient) => Promise<BlocksRPC | null>;

/**
 * RPC Method eth_coinbase implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethCoinbase: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_feeHistory implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethFeeHistory: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_getBlockTransactionCountByHash implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethGetBlockTransactionCountByHash: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_getBlockTransactionCountByNumber implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethGetBlockTransactionCountByNumber: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_getTransactionByBlockHashAndIndex implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethGetTransactionByBlockHashAndIndex: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_getTransactionByBlockNumberAndIndex implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethGetTransactionByBlockNumberAndIndex: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_getUncleByBlockHashAndIndex implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethGetUncleByBlockHashAndIndex: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_getUncleByBlockNumberAndIndex implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethGetUncleByBlockNumberAndIndex: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_getUncleCountByBlockHash implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethGetUncleCountByBlockHash: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_getUncleCountByBlockNumber implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethGetUncleCountByBlockNumber: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_getWork implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethGetWork: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_mining implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethMining: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_hashrate implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethHashrate: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_protocolVersion implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethProtocolVersion: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_sign implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethSign: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_submitWork implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethSubmitWork: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method net_listening implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const netListening: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method net_peerCount implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const netPeerCount: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method net_version implementation
 *
 * @link [net_version](https://docs.infura.io/networks/ethereum/json-rpc-methods/net_version)
 *
 * @param thorClient - ThorClient instance.
 *
 * @returns The net version (equivalent to chain id in our case).
 */
declare const netVersion: (thorClient: ThorClient) => Promise<string>;

/**
 * RPC Method parity_nextNonce implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const parityNextNonce: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_newFilter implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethNewFilter: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_newBlockFilter implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethNewBlockFilter: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_newPendingTransactionFilter implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethNewPendingTransactionFilter: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_getFilterLogs implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethGetFilterLogs: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_getFilterChanges implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethGetFilterChanges: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_uninstallFilter implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethUninstallFilter: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method debug_getBadBlocks implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const debugGetBadBlocks: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method debug_getRawBlock implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const debugGetRawBlock: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method debug_getRawHeader implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const debugGetRawHeader: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method debug_getRawReceipts implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const debugGetRawReceipts: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method debug_getRawTransaction implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const debugGetRawTransaction: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method engine_exchangeCapabilities implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const engineExchangeCapabilities: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method engine_exchangeTransitionConfigurationV1 implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const engineExchangeTransitionConfigurationV1: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method engine_forkchoiceUpdatedV1 implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const engineForkchoiceUpdatedV1: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method engine_forkchoiceUpdatedV2 implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const engineForkchoiceUpdatedV2: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method engine_forkchoiceUpdatedV3 implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const engineForkchoiceUpdatedV3: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method engine_getPayloadBodiesByHashV1 implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const engineGetPayloadBodiesByHashV1: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method engine_getPayloadBodiesByRangeV1 implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const engineGetPayloadBodiesByRangeV1: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method engine_getPayloadV1 implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const engineGetPayloadV1: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method engine_getPayloadV2 implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const engineGetPayloadV2: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method engine_getPayloadV3 implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const engineGetPayloadV3: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method engine_newPayloadV1 implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const engineNewPayloadV1: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method engine_newPayloadV2 implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const engineNewPayloadV2: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method engine_newPayloadV3 implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const engineNewPayloadV3: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_createAccessList implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethCreateAccessList: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_getBlockReceipts implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethGetBlockReceipts: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_getProof implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethGetProof: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_maxPriorityFeePerGas implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethMaxPriorityFeePerGas: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * RPC Method eth_signTransaction implementation
 *
 * @param thorClient - The thor client instance to use.
 * @param params - The standard array of rpc call parameters.
 * @note:
 * * params[0]: ...
 * * params[1]: ...
 * * params[n]: ...
 */
declare const ethSignTransaction: (thorClient: ThorClient, params: unknown[]) => Promise<void>;

/**
 * Type for the method handler.
 * It is basically a function that takes an array of parameters and returns a promise.
 */
type MethodHandlerType<TParams, TReturnType> = (
    params: TParams[]
) => Promise<TReturnType>;

/**
 * Block type for RPC methods.
 *
 * It can be a block hash or a block number or a string ('0x...', 'latest', 'earliest', 'pending').
 */
type BlockQuantityInputRPC =
    | string
    | { blockHash: string; blockNumber: never }
    | { blockHash: never; blockNumber: number };

/**
 * Map of RPC methods to their implementations with the SDK.
 * We can consider this as an "RPC Mapper" for the SDK.
 *
 * List of all RPC methods:
 * * https://eth.wiki/json-rpc/API
 * * https://ethereum.github.io/execution-apis/api-documentation/
 *
 * @param thorClient - ThorClient instance.
 * @param provider - Provider instance. It is optional because the majority of the methods do not require a provider.
 */
declare const RPCMethodsMap: (thorClient: ThorClient, provider?: VeChainProvider) => Record<string, MethodHandlerType<unknown, unknown>>;

/**
 * Get the correct block number for the given block number.
 *
 * @param block - The block tag to get.
 * 'latest' or 'earliest' or 'pending' or 'safe' or 'finalized'
 * or an object: { blockNumber: number } or { blockHash: string }
 *
 * @note
 *  * Currently VeChainThor supports 'earliest', 'latest' and 'finalized' as block tags.
 *  So 'pending' and 'safe' are converted to 'best' which is the alias for 'latest' and 'finalized' in VeChainThor.
 */
declare const getCorrectBlockNumberRPCToVeChain: (block: BlockQuantityInputRPC) => string;

/**
 * Chain ID's
 *
 * @link [Chain IDs](https://chainlist.org/?search=vechain&testnets=true)
 */
declare const CHAIN_ID: {
    MAINNET: string;
    TESTNET: string;
};

/**
 * Get the index of the transaction in the specified block.
 *
 * @param block - The block to search in.
 * @param hash - The hash of the transaction to search for.
 *
 * @returns the index of the transaction in the block or null if the transaction is not in the block.
 *
 * @throws Will throw an error if the transaction is not in the block.
 */
declare const getTransactionIndexIntoBlock: (block: BlocksRPC, hash: string) => number;
/**
 * Get the number of logs ahead of a transaction into a block.
 *
 * @param blockExpanded - The block to search in.
 * @param transactionId - The hash of the transaction to search for.
 * @param chainId - The chain ID of the network.
 */
declare const getNumberOfLogsAheadOfTransactionIntoBlockExpanded: (blockExpanded: ExpandedBlockDetail, transactionId: string, chainId: string) => number;

type network_AccountDetail = AccountDetail;
type network_AccountInputOptions = AccountInputOptions;
type network_AccountsModule = AccountsModule;
declare const network_AccountsModule: typeof AccountsModule;
type network_AvailableVeChainProviders = AvailableVeChainProviders;
type network_BigramNameConfig = BigramNameConfig;
type network_BigramNameReturnType = BigramNameReturnType;
type network_BlockDetail = BlockDetail;
type network_BlockHeaderRPC = BlockHeaderRPC;
type network_BlockQuantityInputRPC = BlockQuantityInputRPC;
type network_BlockSubscriptionOptions = BlockSubscriptionOptions;
type network_BlocksModule = BlocksModule;
declare const network_BlocksModule: typeof BlocksModule;
type network_BlocksModuleOptions = BlocksModuleOptions;
type network_BlocksRPC = BlocksRPC;
type network_BuildHardhatErrorFunction = BuildHardhatErrorFunction;
declare const network_CHAIN_ID: typeof CHAIN_ID;
type network_CallNameConfig = CallNameConfig;
type network_CallNameReturnType = CallNameReturnType;
type network_CallTracerRPC = CallTracerRPC;
type network_CompressedBlockDetail = CompressedBlockDetail;
type network_ConnectedPeer = ConnectedPeer;
type network_Contract<TAbi extends Abi> = Contract<TAbi>;
declare const network_Contract: typeof Contract;
type network_ContractCallOptions = ContractCallOptions;
type network_ContractCallResult = ContractCallResult;
type network_ContractCallTraceContractTargetInput = ContractCallTraceContractTargetInput;
type network_ContractCallTraceTransactionOptionsInput = ContractCallTraceTransactionOptionsInput;
type network_ContractClause = ContractClause;
type network_ContractFactory<TAbi extends Abi> = ContractFactory<TAbi>;
declare const network_ContractFactory: typeof ContractFactory;
type network_ContractFunctionAsync<T = unknown, TABIFunction> = ContractFunctionAsync<T, TABIFunction>;
type network_ContractTransactionOptions = ContractTransactionOptions;
type network_ContractsModule = ContractsModule;
declare const network_ContractsModule: typeof ContractsModule;
declare const network_DEFAULT_HTTP_TIMEOUT: typeof DEFAULT_HTTP_TIMEOUT;
type network_DebugModule = DebugModule;
declare const network_DebugModule: typeof DebugModule;
type network_DefaultNameConfig = DefaultNameConfig;
type network_DefaultNameReturnType = DefaultNameReturnType;
declare const network_DelegationHandler: typeof DelegationHandler;
type network_EIP1193ProviderMessage = EIP1193ProviderMessage;
type network_EIP1193RequestArguments = EIP1193RequestArguments;
declare const network_ERROR_SELECTOR: typeof ERROR_SELECTOR;
type network_EVMDisNameConfig = EVMDisNameConfig;
type network_EVMDisNameReturnType = EVMDisNameReturnType;
type network_EventCriteria = EventCriteria;
type network_EventDisplayOrder = EventDisplayOrder;
type network_EventFragment = EventFragment;
type network_EventLike = EventLike;
type network_EventLogs = EventLogs;
type network_EventOptions = EventOptions;
type network_EventPoll<TReturnType> = EventPoll<TReturnType>;
declare const network_EventPoll: typeof EventPoll;
type network_EventSubscriptionOptions = EventSubscriptionOptions;
type network_ExpandedBlockDetail = ExpandedBlockDetail;
type network_FilterCriteria = FilterCriteria;
type network_FilterEventLogsOptions = FilterEventLogsOptions;
type network_FilterOptions = FilterOptions;
type network_FilterRawEventLogsOptions = FilterRawEventLogsOptions;
type network_FilterTransferLogsOptions = FilterTransferLogsOptions;
type network_FourByteNameConfig = FourByteNameConfig;
type network_FourByteNameReturnType = FourByteNameReturnType;
type network_GasModule = GasModule;
declare const network_GasModule: typeof GasModule;
type network_GetDelegationSignatureResult = GetDelegationSignatureResult;
type network_GetTransactionInputOptions = GetTransactionInputOptions;
type network_GetTransactionReceiptInputOptions = GetTransactionReceiptInputOptions;
declare const network_HTTPS_REGEX: typeof HTTPS_REGEX;
declare const network_HTTP_REGEX: typeof HTTP_REGEX;
type network_HardhatVeChainProvider = HardhatVeChainProvider;
declare const network_HardhatVeChainProvider: typeof HardhatVeChainProvider;
type network_HttpClient = HttpClient;
declare const network_HttpClient: typeof HttpClient;
type network_HttpClientOptions = HttpClientOptions;
type network_HttpParams = HttpParams;
type network_JSONRPCEthersProvider = JSONRPCEthersProvider;
declare const network_JSONRPCEthersProvider: typeof JSONRPCEthersProvider;
type network_JsonRpcError = JsonRpcError;
type network_JsonRpcPayload = JsonRpcPayload;
type network_JsonRpcRequest = JsonRpcRequest;
type network_JsonRpcResponse = JsonRpcResponse;
type network_JsonRpcResult = JsonRpcResult;
type network_LogsModule = LogsModule;
declare const network_LogsModule: typeof LogsModule;
type network_LogsRPC = LogsRPC;
type network_MethodHandlerType<TParams, TReturnType> = MethodHandlerType<TParams, TReturnType>;
declare const network_NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS: typeof NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS;
type network_NodesModule = NodesModule;
declare const network_NodesModule: typeof NodesModule;
type network_NoopNameConfig = NoopNameConfig;
type network_NoopNameReturnType = NoopNameReturnType;
type network_OPCountNameConfig = OPCountNameConfig;
type network_OPCountNameReturnType = OPCountNameReturnType;
type network_Output = Output;
declare const network_PANIC_SELECTOR: typeof PANIC_SELECTOR;
declare const network_POLLING_INTERVAL: typeof POLLING_INTERVAL;
type network_PaginationOptions = PaginationOptions;
declare const network_Poll: typeof Poll;
type network_PreStateNameConfig = PreStateNameConfig;
type network_PreStateNameReturnType = PreStateNameReturnType;
type network_PrestateTracerRPC = PrestateTracerRPC;
type network_ProviderInternalBaseWallet = ProviderInternalBaseWallet;
declare const network_ProviderInternalBaseWallet: typeof ProviderInternalBaseWallet;
type network_ProviderInternalHDWallet = ProviderInternalHDWallet;
declare const network_ProviderInternalHDWallet: typeof ProviderInternalHDWallet;
type network_ProviderInternalWallet = ProviderInternalWallet;
type network_ProviderInternalWalletAccount = ProviderInternalWalletAccount;
declare const network_RPCMethodsMap: typeof RPCMethodsMap;
type network_RPC_METHODS = RPC_METHODS;
declare const network_RPC_METHODS: typeof RPC_METHODS;
type network_Range = Range;
type network_ResponseBytecode = ResponseBytecode;
type network_ResponseStorage = ResponseStorage;
type network_RetrieveStorageRangeInputOptions = RetrieveStorageRangeInputOptions;
type network_RetrieveStorageRangeReturnType = RetrieveStorageRangeReturnType;
type network_SendTransactionResult = SendTransactionResult;
type network_SignTransactionOptions = SignTransactionOptions;
type network_SimulateTransactionClause = SimulateTransactionClause;
type network_SimulateTransactionOptions = SimulateTransactionOptions;
type network_SubscriptionEvent = SubscriptionEvent;
type network_SubscriptionManager = SubscriptionManager;
type network_SyncBlockRPC = SyncBlockRPC;
type network_SyncPollInputOptions = SyncPollInputOptions;
type network_ThorClient = ThorClient;
declare const network_ThorClient: typeof ThorClient;
type network_TraceOptionsRPC = TraceOptionsRPC;
type network_TraceReturnType<TraceNameType extends TracerName | undefined> = TraceReturnType<TraceNameType>;
type network_TracerConfig<TraceNameType extends TracerName | undefined> = TracerConfig<TraceNameType>;
type network_TracerName = TracerName;
type network_TracerNameRPC = TracerNameRPC;
type network_TracerReturnTypeRPC<TracerNameType extends TracerNameRPC> = TracerReturnTypeRPC<TracerNameType>;
type network_TransactionBodyOptions = TransactionBodyOptions;
type network_TransactionDetailNoRaw = TransactionDetailNoRaw;
type network_TransactionDetailRaw = TransactionDetailRaw;
type network_TransactionObjectInput = TransactionObjectInput;
type network_TransactionRPC = TransactionRPC;
type network_TransactionReceipt = TransactionReceipt;
type network_TransactionReceiptLogsRPC = TransactionReceiptLogsRPC;
type network_TransactionReceiptRPC = TransactionReceiptRPC;
type network_TransactionRequestInput = TransactionRequestInput;
type network_TransactionSimulationResult = TransactionSimulationResult;
type network_TransactionTraceTarget = TransactionTraceTarget;
type network_TransactionsExpandedBlockDetail = TransactionsExpandedBlockDetail;
type network_TransactionsModule = TransactionsModule;
declare const network_TransactionsModule: typeof TransactionsModule;
type network_Transfer = Transfer;
type network_TransferLogs = TransferLogs;
type network_TrigramNameConfig = TrigramNameConfig;
type network_TrigramNameReturnType = TrigramNameReturnType;
type network_UnigramNameConfig = UnigramNameConfig;
type network_UnigramNameReturnType = UnigramNameReturnType;
type network_VETtransfersSubscriptionOptions = VETtransfersSubscriptionOptions;
type network_VeChainAbstractSigner = VeChainAbstractSigner;
declare const network_VeChainAbstractSigner: typeof VeChainAbstractSigner;
type network_VeChainPrivateKeySigner = VeChainPrivateKeySigner;
declare const network_VeChainPrivateKeySigner: typeof VeChainPrivateKeySigner;
type network_VeChainProvider = VeChainProvider;
declare const network_VeChainProvider: typeof VeChainProvider;
type network_VeChainSigner = VeChainSigner;
type network_VetTransferOptions = VetTransferOptions;
type network_WaitForBlockOptions = WaitForBlockOptions;
type network_WaitForTransactionOptions = WaitForTransactionOptions;
declare const network_assertTransactionCanBeSigned: typeof assertTransactionCanBeSigned;
declare const network_blocksFormatter: typeof blocksFormatter;
declare const network_buildQuery: typeof buildQuery;
declare const network_convertError: typeof convertError;
declare const network_debugFormatter: typeof debugFormatter;
declare const network_debugGetBadBlocks: typeof debugGetBadBlocks;
declare const network_debugGetRawBlock: typeof debugGetRawBlock;
declare const network_debugGetRawHeader: typeof debugGetRawHeader;
declare const network_debugGetRawReceipts: typeof debugGetRawReceipts;
declare const network_debugGetRawTransaction: typeof debugGetRawTransaction;
declare const network_debugTraceCall: typeof debugTraceCall;
declare const network_debugTraceTransaction: typeof debugTraceTransaction;
declare const network_engineExchangeCapabilities: typeof engineExchangeCapabilities;
declare const network_engineExchangeTransitionConfigurationV1: typeof engineExchangeTransitionConfigurationV1;
declare const network_engineForkchoiceUpdatedV1: typeof engineForkchoiceUpdatedV1;
declare const network_engineForkchoiceUpdatedV2: typeof engineForkchoiceUpdatedV2;
declare const network_engineForkchoiceUpdatedV3: typeof engineForkchoiceUpdatedV3;
declare const network_engineGetPayloadBodiesByHashV1: typeof engineGetPayloadBodiesByHashV1;
declare const network_engineGetPayloadBodiesByRangeV1: typeof engineGetPayloadBodiesByRangeV1;
declare const network_engineGetPayloadV1: typeof engineGetPayloadV1;
declare const network_engineGetPayloadV2: typeof engineGetPayloadV2;
declare const network_engineGetPayloadV3: typeof engineGetPayloadV3;
declare const network_engineNewPayloadV1: typeof engineNewPayloadV1;
declare const network_engineNewPayloadV2: typeof engineNewPayloadV2;
declare const network_engineNewPayloadV3: typeof engineNewPayloadV3;
declare const network_ethAccounts: typeof ethAccounts;
declare const network_ethBlockNumber: typeof ethBlockNumber;
declare const network_ethCall: typeof ethCall;
declare const network_ethChainId: typeof ethChainId;
declare const network_ethCoinbase: typeof ethCoinbase;
declare const network_ethCreateAccessList: typeof ethCreateAccessList;
declare const network_ethEstimateGas: typeof ethEstimateGas;
declare const network_ethFeeHistory: typeof ethFeeHistory;
declare const network_ethGasPrice: typeof ethGasPrice;
declare const network_ethGetBalance: typeof ethGetBalance;
declare const network_ethGetBlockByHash: typeof ethGetBlockByHash;
declare const network_ethGetBlockByNumber: typeof ethGetBlockByNumber;
declare const network_ethGetBlockReceipts: typeof ethGetBlockReceipts;
declare const network_ethGetBlockTransactionCountByHash: typeof ethGetBlockTransactionCountByHash;
declare const network_ethGetBlockTransactionCountByNumber: typeof ethGetBlockTransactionCountByNumber;
declare const network_ethGetCode: typeof ethGetCode;
declare const network_ethGetFilterChanges: typeof ethGetFilterChanges;
declare const network_ethGetFilterLogs: typeof ethGetFilterLogs;
declare const network_ethGetLogs: typeof ethGetLogs;
declare const network_ethGetProof: typeof ethGetProof;
declare const network_ethGetStorageAt: typeof ethGetStorageAt;
declare const network_ethGetTransactionByBlockHashAndIndex: typeof ethGetTransactionByBlockHashAndIndex;
declare const network_ethGetTransactionByBlockNumberAndIndex: typeof ethGetTransactionByBlockNumberAndIndex;
declare const network_ethGetTransactionByHash: typeof ethGetTransactionByHash;
declare const network_ethGetTransactionCount: typeof ethGetTransactionCount;
declare const network_ethGetTransactionReceipt: typeof ethGetTransactionReceipt;
declare const network_ethGetUncleByBlockHashAndIndex: typeof ethGetUncleByBlockHashAndIndex;
declare const network_ethGetUncleByBlockNumberAndIndex: typeof ethGetUncleByBlockNumberAndIndex;
declare const network_ethGetUncleCountByBlockHash: typeof ethGetUncleCountByBlockHash;
declare const network_ethGetUncleCountByBlockNumber: typeof ethGetUncleCountByBlockNumber;
declare const network_ethGetWork: typeof ethGetWork;
declare const network_ethHashrate: typeof ethHashrate;
declare const network_ethMaxPriorityFeePerGas: typeof ethMaxPriorityFeePerGas;
declare const network_ethMining: typeof ethMining;
declare const network_ethNewBlockFilter: typeof ethNewBlockFilter;
declare const network_ethNewFilter: typeof ethNewFilter;
declare const network_ethNewPendingTransactionFilter: typeof ethNewPendingTransactionFilter;
declare const network_ethProtocolVersion: typeof ethProtocolVersion;
declare const network_ethSendRawTransaction: typeof ethSendRawTransaction;
declare const network_ethSendTransaction: typeof ethSendTransaction;
declare const network_ethSign: typeof ethSign;
declare const network_ethSignTransaction: typeof ethSignTransaction;
declare const network_ethSubmitWork: typeof ethSubmitWork;
declare const network_ethSubscribe: typeof ethSubscribe;
declare const network_ethSyncing: typeof ethSyncing;
declare const network_ethUninstallFilter: typeof ethUninstallFilter;
declare const network_ethUnsubscribe: typeof ethUnsubscribe;
declare const network_evmMine: typeof evmMine;
declare const network_formatToLogsRPC: typeof formatToLogsRPC;
declare const network_formatToRPCStandard: typeof formatToRPCStandard;
declare const network_getCorrectBlockNumberRPCToVeChain: typeof getCorrectBlockNumberRPCToVeChain;
declare const network_getCriteriaSetForInput: typeof getCriteriaSetForInput;
declare const network_getNumberOfLogsAheadOfTransactionIntoBlockExpanded: typeof getNumberOfLogsAheadOfTransactionIntoBlockExpanded;
declare const network_getTransactionIndexIntoBlock: typeof getTransactionIndexIntoBlock;
declare const network_netListening: typeof netListening;
declare const network_netPeerCount: typeof netPeerCount;
declare const network_netVersion: typeof netVersion;
declare const network_parityNextNonce: typeof parityNextNonce;
declare const network_sanitizeWebsocketBaseURL: typeof sanitizeWebsocketBaseURL;
declare const network_signerUtils: typeof signerUtils;
declare const network_subscriptions: typeof subscriptions;
declare const network_thorest: typeof thorest;
declare const network_toQueryString: typeof toQueryString;
declare const network_transactionsFormatter: typeof transactionsFormatter;
declare const network_vnsUtils: typeof vnsUtils;
declare const network_web3ClientVersion: typeof web3ClientVersion;
declare namespace network {
  export { type network_AccountDetail as AccountDetail, type network_AccountInputOptions as AccountInputOptions, network_AccountsModule as AccountsModule, type network_AvailableVeChainProviders as AvailableVeChainProviders, type network_BigramNameConfig as BigramNameConfig, type network_BigramNameReturnType as BigramNameReturnType, type network_BlockDetail as BlockDetail, type network_BlockHeaderRPC as BlockHeaderRPC, type network_BlockQuantityInputRPC as BlockQuantityInputRPC, type network_BlockSubscriptionOptions as BlockSubscriptionOptions, network_BlocksModule as BlocksModule, type network_BlocksModuleOptions as BlocksModuleOptions, type network_BlocksRPC as BlocksRPC, type network_BuildHardhatErrorFunction as BuildHardhatErrorFunction, network_CHAIN_ID as CHAIN_ID, type network_CallNameConfig as CallNameConfig, type network_CallNameReturnType as CallNameReturnType, type network_CallTracerRPC as CallTracerRPC, type network_CompressedBlockDetail as CompressedBlockDetail, type network_ConnectedPeer as ConnectedPeer, network_Contract as Contract, type network_ContractCallOptions as ContractCallOptions, type network_ContractCallResult as ContractCallResult, type network_ContractCallTraceContractTargetInput as ContractCallTraceContractTargetInput, type network_ContractCallTraceTransactionOptionsInput as ContractCallTraceTransactionOptionsInput, type network_ContractClause as ContractClause, network_ContractFactory as ContractFactory, type network_ContractFunctionAsync as ContractFunctionAsync, type network_ContractTransactionOptions as ContractTransactionOptions, network_ContractsModule as ContractsModule, network_DEFAULT_HTTP_TIMEOUT as DEFAULT_HTTP_TIMEOUT, network_DebugModule as DebugModule, type network_DefaultNameConfig as DefaultNameConfig, type network_DefaultNameReturnType as DefaultNameReturnType, network_DelegationHandler as DelegationHandler, type network_EIP1193ProviderMessage as EIP1193ProviderMessage, type network_EIP1193RequestArguments as EIP1193RequestArguments, network_ERROR_SELECTOR as ERROR_SELECTOR, type network_EVMDisNameConfig as EVMDisNameConfig, type network_EVMDisNameReturnType as EVMDisNameReturnType, type Event$1 as Event, type network_EventCriteria as EventCriteria, type network_EventDisplayOrder as EventDisplayOrder, type network_EventFragment as EventFragment, type network_EventLike as EventLike, type network_EventLogs as EventLogs, type network_EventOptions as EventOptions, network_EventPoll as EventPoll, type network_EventSubscriptionOptions as EventSubscriptionOptions, type network_ExpandedBlockDetail as ExpandedBlockDetail, type network_FilterCriteria as FilterCriteria, type network_FilterEventLogsOptions as FilterEventLogsOptions, type network_FilterOptions as FilterOptions, type network_FilterRawEventLogsOptions as FilterRawEventLogsOptions, type network_FilterTransferLogsOptions as FilterTransferLogsOptions, type network_FourByteNameConfig as FourByteNameConfig, type network_FourByteNameReturnType as FourByteNameReturnType, network_GasModule as GasModule, type network_GetDelegationSignatureResult as GetDelegationSignatureResult, type network_GetTransactionInputOptions as GetTransactionInputOptions, type network_GetTransactionReceiptInputOptions as GetTransactionReceiptInputOptions, network_HTTPS_REGEX as HTTPS_REGEX, network_HTTP_REGEX as HTTP_REGEX, network_HardhatVeChainProvider as HardhatVeChainProvider, network_HttpClient as HttpClient, type network_HttpClientOptions as HttpClientOptions, type network_HttpParams as HttpParams, network_JSONRPCEthersProvider as JSONRPCEthersProvider, type network_JsonRpcError as JsonRpcError, type network_JsonRpcPayload as JsonRpcPayload, type network_JsonRpcRequest as JsonRpcRequest, type network_JsonRpcResponse as JsonRpcResponse, type network_JsonRpcResult as JsonRpcResult, network_LogsModule as LogsModule, type network_LogsRPC as LogsRPC, type network_MethodHandlerType as MethodHandlerType, network_NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS as NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS, network_NodesModule as NodesModule, type network_NoopNameConfig as NoopNameConfig, type network_NoopNameReturnType as NoopNameReturnType, type network_OPCountNameConfig as OPCountNameConfig, type network_OPCountNameReturnType as OPCountNameReturnType, type network_Output as Output, network_PANIC_SELECTOR as PANIC_SELECTOR, network_POLLING_INTERVAL as POLLING_INTERVAL, type network_PaginationOptions as PaginationOptions, network_Poll as Poll, type network_PreStateNameConfig as PreStateNameConfig, type network_PreStateNameReturnType as PreStateNameReturnType, type network_PrestateTracerRPC as PrestateTracerRPC, network_ProviderInternalBaseWallet as ProviderInternalBaseWallet, network_ProviderInternalHDWallet as ProviderInternalHDWallet, type network_ProviderInternalWallet as ProviderInternalWallet, type network_ProviderInternalWalletAccount as ProviderInternalWalletAccount, network_RPCMethodsMap as RPCMethodsMap, network_RPC_METHODS as RPC_METHODS, type network_Range as Range, type network_ResponseBytecode as ResponseBytecode, type network_ResponseStorage as ResponseStorage, type network_RetrieveStorageRangeInputOptions as RetrieveStorageRangeInputOptions, type network_RetrieveStorageRangeReturnType as RetrieveStorageRangeReturnType, type network_SendTransactionResult as SendTransactionResult, type network_SignTransactionOptions as SignTransactionOptions, type network_SimulateTransactionClause as SimulateTransactionClause, type network_SimulateTransactionOptions as SimulateTransactionOptions, type network_SubscriptionEvent as SubscriptionEvent, type network_SubscriptionManager as SubscriptionManager, type network_SyncBlockRPC as SyncBlockRPC, type network_SyncPollInputOptions as SyncPollInputOptions, network_ThorClient as ThorClient, type network_TraceOptionsRPC as TraceOptionsRPC, type network_TraceReturnType as TraceReturnType, type network_TracerConfig as TracerConfig, type network_TracerName as TracerName, type network_TracerNameRPC as TracerNameRPC, type network_TracerReturnTypeRPC as TracerReturnTypeRPC, type network_TransactionBodyOptions as TransactionBodyOptions, type network_TransactionDetailNoRaw as TransactionDetailNoRaw, type network_TransactionDetailRaw as TransactionDetailRaw, type network_TransactionObjectInput as TransactionObjectInput, type network_TransactionRPC as TransactionRPC, type network_TransactionReceipt as TransactionReceipt, type network_TransactionReceiptLogsRPC as TransactionReceiptLogsRPC, type network_TransactionReceiptRPC as TransactionReceiptRPC, type network_TransactionRequestInput as TransactionRequestInput, type network_TransactionSimulationResult as TransactionSimulationResult, type network_TransactionTraceTarget as TransactionTraceTarget, type network_TransactionsExpandedBlockDetail as TransactionsExpandedBlockDetail, network_TransactionsModule as TransactionsModule, type network_Transfer as Transfer, type network_TransferLogs as TransferLogs, type network_TrigramNameConfig as TrigramNameConfig, type network_TrigramNameReturnType as TrigramNameReturnType, type network_UnigramNameConfig as UnigramNameConfig, type network_UnigramNameReturnType as UnigramNameReturnType, type network_VETtransfersSubscriptionOptions as VETtransfersSubscriptionOptions, network_VeChainAbstractSigner as VeChainAbstractSigner, network_VeChainPrivateKeySigner as VeChainPrivateKeySigner, network_VeChainProvider as VeChainProvider, type network_VeChainSigner as VeChainSigner, type network_VetTransferOptions as VetTransferOptions, type network_WaitForBlockOptions as WaitForBlockOptions, type network_WaitForTransactionOptions as WaitForTransactionOptions, network_assertTransactionCanBeSigned as assertTransactionCanBeSigned, network_blocksFormatter as blocksFormatter, network_buildQuery as buildQuery, network_convertError as convertError, network_debugFormatter as debugFormatter, network_debugGetBadBlocks as debugGetBadBlocks, network_debugGetRawBlock as debugGetRawBlock, network_debugGetRawHeader as debugGetRawHeader, network_debugGetRawReceipts as debugGetRawReceipts, network_debugGetRawTransaction as debugGetRawTransaction, network_debugTraceCall as debugTraceCall, network_debugTraceTransaction as debugTraceTransaction, network_engineExchangeCapabilities as engineExchangeCapabilities, network_engineExchangeTransitionConfigurationV1 as engineExchangeTransitionConfigurationV1, network_engineForkchoiceUpdatedV1 as engineForkchoiceUpdatedV1, network_engineForkchoiceUpdatedV2 as engineForkchoiceUpdatedV2, network_engineForkchoiceUpdatedV3 as engineForkchoiceUpdatedV3, network_engineGetPayloadBodiesByHashV1 as engineGetPayloadBodiesByHashV1, network_engineGetPayloadBodiesByRangeV1 as engineGetPayloadBodiesByRangeV1, network_engineGetPayloadV1 as engineGetPayloadV1, network_engineGetPayloadV2 as engineGetPayloadV2, network_engineGetPayloadV3 as engineGetPayloadV3, network_engineNewPayloadV1 as engineNewPayloadV1, network_engineNewPayloadV2 as engineNewPayloadV2, network_engineNewPayloadV3 as engineNewPayloadV3, network_ethAccounts as ethAccounts, network_ethBlockNumber as ethBlockNumber, network_ethCall as ethCall, network_ethChainId as ethChainId, network_ethCoinbase as ethCoinbase, network_ethCreateAccessList as ethCreateAccessList, network_ethEstimateGas as ethEstimateGas, network_ethFeeHistory as ethFeeHistory, network_ethGasPrice as ethGasPrice, network_ethGetBalance as ethGetBalance, network_ethGetBlockByHash as ethGetBlockByHash, network_ethGetBlockByNumber as ethGetBlockByNumber, network_ethGetBlockReceipts as ethGetBlockReceipts, network_ethGetBlockTransactionCountByHash as ethGetBlockTransactionCountByHash, network_ethGetBlockTransactionCountByNumber as ethGetBlockTransactionCountByNumber, network_ethGetCode as ethGetCode, network_ethGetFilterChanges as ethGetFilterChanges, network_ethGetFilterLogs as ethGetFilterLogs, network_ethGetLogs as ethGetLogs, network_ethGetProof as ethGetProof, network_ethGetStorageAt as ethGetStorageAt, network_ethGetTransactionByBlockHashAndIndex as ethGetTransactionByBlockHashAndIndex, network_ethGetTransactionByBlockNumberAndIndex as ethGetTransactionByBlockNumberAndIndex, network_ethGetTransactionByHash as ethGetTransactionByHash, network_ethGetTransactionCount as ethGetTransactionCount, network_ethGetTransactionReceipt as ethGetTransactionReceipt, network_ethGetUncleByBlockHashAndIndex as ethGetUncleByBlockHashAndIndex, network_ethGetUncleByBlockNumberAndIndex as ethGetUncleByBlockNumberAndIndex, network_ethGetUncleCountByBlockHash as ethGetUncleCountByBlockHash, network_ethGetUncleCountByBlockNumber as ethGetUncleCountByBlockNumber, network_ethGetWork as ethGetWork, network_ethHashrate as ethHashrate, network_ethMaxPriorityFeePerGas as ethMaxPriorityFeePerGas, network_ethMining as ethMining, network_ethNewBlockFilter as ethNewBlockFilter, network_ethNewFilter as ethNewFilter, network_ethNewPendingTransactionFilter as ethNewPendingTransactionFilter, network_ethProtocolVersion as ethProtocolVersion, network_ethSendRawTransaction as ethSendRawTransaction, network_ethSendTransaction as ethSendTransaction, network_ethSign as ethSign, network_ethSignTransaction as ethSignTransaction, network_ethSubmitWork as ethSubmitWork, network_ethSubscribe as ethSubscribe, network_ethSyncing as ethSyncing, network_ethUninstallFilter as ethUninstallFilter, network_ethUnsubscribe as ethUnsubscribe, network_evmMine as evmMine, network_formatToLogsRPC as formatToLogsRPC, network_formatToRPCStandard as formatToRPCStandard, network_getCorrectBlockNumberRPCToVeChain as getCorrectBlockNumberRPCToVeChain, network_getCriteriaSetForInput as getCriteriaSetForInput, network_getNumberOfLogsAheadOfTransactionIntoBlockExpanded as getNumberOfLogsAheadOfTransactionIntoBlockExpanded, network_getTransactionIndexIntoBlock as getTransactionIndexIntoBlock, network_netListening as netListening, network_netPeerCount as netPeerCount, network_netVersion as netVersion, network_parityNextNonce as parityNextNonce, network_sanitizeWebsocketBaseURL as sanitizeWebsocketBaseURL, network_signerUtils as signerUtils, network_subscriptions as subscriptions, network_thorest as thorest, network_toQueryString as toQueryString, network_transactionsFormatter as transactionsFormatter, network_vnsUtils as vnsUtils, network_web3ClientVersion as web3ClientVersion };
}

export { type AccountDetail, type AccountInputOptions, AccountsModule, type AvailableVeChainProviders, type BigramNameConfig, type BigramNameReturnType, type BlockDetail, type BlockHeaderRPC, type BlockQuantityInputRPC, type BlockSubscriptionOptions, BlocksModule, type BlocksModuleOptions, type BlocksRPC, type BuildHardhatErrorFunction, CHAIN_ID, type CallNameConfig, type CallNameReturnType, type CallTracerRPC, type CompressedBlockDetail, type ConnectedPeer, Contract, type ContractCallOptions, type ContractCallResult, type ContractCallTraceContractTargetInput, type ContractCallTraceTransactionOptionsInput, type ContractClause, ContractFactory, type ContractFunctionAsync, type ContractTransactionOptions, ContractsModule, DEFAULT_HTTP_TIMEOUT, DebugModule, type DefaultNameConfig, type DefaultNameReturnType, DelegationHandler, type EIP1193ProviderMessage, type EIP1193RequestArguments, ERROR_SELECTOR, type EVMDisNameConfig, type EVMDisNameReturnType, type Event$1 as Event, type EventCriteria, type EventDisplayOrder, type EventFragment, type EventLike, type EventLogs, type EventOptions, EventPoll, type EventSubscriptionOptions, type ExpandedBlockDetail, type FilterCriteria, type FilterEventLogsOptions, type FilterOptions, type FilterRawEventLogsOptions, type FilterTransferLogsOptions, type FourByteNameConfig, type FourByteNameReturnType, GasModule, type GetDelegationSignatureResult, type GetTransactionInputOptions, type GetTransactionReceiptInputOptions, HTTPS_REGEX, HTTP_REGEX, HardhatVeChainProvider, HttpClient, type HttpClientOptions, type HttpParams, JSONRPCEthersProvider, type JsonRpcError, type JsonRpcPayload, type JsonRpcRequest, type JsonRpcResponse, type JsonRpcResult, LogsModule, type LogsRPC, type MethodHandlerType, NODE_HEALTHCHECK_TOLERANCE_IN_SECONDS, NodesModule, type NoopNameConfig, type NoopNameReturnType, type OPCountNameConfig, type OPCountNameReturnType, type Output, PANIC_SELECTOR, POLLING_INTERVAL, type PaginationOptions, Poll, type PreStateNameConfig, type PreStateNameReturnType, type PrestateTracerRPC, ProviderInternalBaseWallet, ProviderInternalHDWallet, type ProviderInternalWallet, type ProviderInternalWalletAccount, RPCMethodsMap, RPC_METHODS, type Range, type ResponseBytecode, type ResponseStorage, type RetrieveStorageRangeInputOptions, type RetrieveStorageRangeReturnType, type SendTransactionResult, type SignTransactionOptions, type SimulateTransactionClause, type SimulateTransactionOptions, type SubscriptionEvent, type SubscriptionManager, type SyncBlockRPC, type SyncPollInputOptions, ThorClient, type TraceOptionsRPC, type TraceReturnType, type TracerConfig, type TracerName, type TracerNameRPC, type TracerReturnTypeRPC, type TransactionBodyOptions, type TransactionDetailNoRaw, type TransactionDetailRaw, type TransactionObjectInput, type TransactionRPC, type TransactionReceipt, type TransactionReceiptLogsRPC, type TransactionReceiptRPC, type TransactionRequestInput, type TransactionSimulationResult, type TransactionTraceTarget, type TransactionsExpandedBlockDetail, TransactionsModule, type Transfer, type TransferLogs, type TrigramNameConfig, type TrigramNameReturnType, type UnigramNameConfig, type UnigramNameReturnType, type VETtransfersSubscriptionOptions, VeChainAbstractSigner, VeChainPrivateKeySigner, VeChainProvider, type VeChainSigner, type VetTransferOptions, type WaitForBlockOptions, type WaitForTransactionOptions, assertTransactionCanBeSigned, blocksFormatter, buildQuery, convertError, debugFormatter, debugGetBadBlocks, debugGetRawBlock, debugGetRawHeader, debugGetRawReceipts, debugGetRawTransaction, debugTraceCall, debugTraceTransaction, engineExchangeCapabilities, engineExchangeTransitionConfigurationV1, engineForkchoiceUpdatedV1, engineForkchoiceUpdatedV2, engineForkchoiceUpdatedV3, engineGetPayloadBodiesByHashV1, engineGetPayloadBodiesByRangeV1, engineGetPayloadV1, engineGetPayloadV2, engineGetPayloadV3, engineNewPayloadV1, engineNewPayloadV2, engineNewPayloadV3, ethAccounts, ethBlockNumber, ethCall, ethChainId, ethCoinbase, ethCreateAccessList, ethEstimateGas, ethFeeHistory, ethGasPrice, ethGetBalance, ethGetBlockByHash, ethGetBlockByNumber, ethGetBlockReceipts, ethGetBlockTransactionCountByHash, ethGetBlockTransactionCountByNumber, ethGetCode, ethGetFilterChanges, ethGetFilterLogs, ethGetLogs, ethGetProof, ethGetStorageAt, ethGetTransactionByBlockHashAndIndex, ethGetTransactionByBlockNumberAndIndex, ethGetTransactionByHash, ethGetTransactionCount, ethGetTransactionReceipt, ethGetUncleByBlockHashAndIndex, ethGetUncleByBlockNumberAndIndex, ethGetUncleCountByBlockHash, ethGetUncleCountByBlockNumber, ethGetWork, ethHashrate, ethMaxPriorityFeePerGas, ethMining, ethNewBlockFilter, ethNewFilter, ethNewPendingTransactionFilter, ethProtocolVersion, ethSendRawTransaction, ethSendTransaction, ethSign, ethSignTransaction, ethSubmitWork, ethSubscribe, ethSyncing, ethUninstallFilter, ethUnsubscribe, evmMine, formatToLogsRPC, formatToRPCStandard, getCorrectBlockNumberRPCToVeChain, getCriteriaSetForInput, getNumberOfLogsAheadOfTransactionIntoBlockExpanded, getTransactionIndexIntoBlock, netListening, netPeerCount, netVersion, network, parityNextNonce, sanitizeWebsocketBaseURL, signerUtils, subscriptions, thorest, toQueryString, transactionsFormatter, vnsUtils, web3ClientVersion };
