// src/helpers/provider-helper.ts
import {
  ProviderInternalBaseWallet,
  DelegationHandler,
  ProviderInternalHDWallet
} from "@vechain/sdk-network";
import { buildError, JSONRPC } from "@vechain/sdk-errors";
import { addressUtils, secp256k1 } from "@vechain/sdk-core";
var createWalletFromHardhatNetworkConfig = (networkConfig) => {
  const accountFromConfig = networkConfig.accounts;
  if (accountFromConfig === void 0)
    return new ProviderInternalBaseWallet([], {});
  else {
    if (accountFromConfig === "remote")
      throw buildError(
        "createWalletFromHardhatNetworkConfig",
        JSONRPC.INTERNAL_ERROR,
        "Remote accounts are not supported in hardhat network configuration."
      );
    if (Array.isArray(accountFromConfig)) {
      return new ProviderInternalBaseWallet(
        accountFromConfig.map((privateKey) => {
          const privateKeyBuffer = Buffer.from(
            privateKey.startsWith("0x") ? privateKey.slice(2) : privateKey,
            "hex"
          );
          return {
            privateKey: privateKeyBuffer,
            publicKey: Buffer.from(
              secp256k1.derivePublicKey(privateKeyBuffer)
            ),
            address: addressUtils.fromPrivateKey(privateKeyBuffer)
          };
        }),
        {
          delegator: DelegationHandler(
            networkConfig.delegator
          ).delegatorOrUndefined()
        }
      );
    } else {
      return new ProviderInternalHDWallet(
        accountFromConfig.mnemonic.split(" "),
        accountFromConfig.count,
        accountFromConfig.initialIndex,
        accountFromConfig.path,
        {
          delegator: DelegationHandler(
            networkConfig.delegator
          ).delegatorOrUndefined()
        }
      );
    }
  }
};

// src/index.ts
import { extendEnvironment } from "hardhat/config";
import { HardhatPluginError, lazyObject } from "hardhat/plugins";
import {
  deployContract,
  getContractAt,
  getContractAtFromArtifact,
  getContractFactory,
  getContractFactoryFromArtifact,
  getSigner,
  getSigners
} from "@nomicfoundation/hardhat-ethers/internal/helpers";
import { HardhatVeChainProvider } from "@vechain/sdk-network";
import { VeChainSDKLogger } from "@vechain/sdk-logging";
import { vechain_sdk_core_ethers as ethers } from "@vechain/sdk-core";

// src/type-extensions.ts
import "hardhat/types/config";
import "hardhat/types/runtime";

// src/index.ts
import { HardhatEthersProvider } from "@nomicfoundation/hardhat-ethers/internal/hardhat-ethers-provider";
import { contractAdapter, factoryAdapter } from "@vechain/sdk-ethers-adapter";
extendEnvironment((hre) => {
  const networkName = hre.network.name;
  const networkConfig = hre.config.networks[networkName];
  const debug = networkConfig.debug !== void 0 && networkConfig.debug;
  const enableDelegation = networkConfig.enableDelegation !== void 0 && networkConfig.enableDelegation;
  if (!networkName.includes("vechain")) {
    VeChainSDKLogger("warning").log({
      title: "You are operating on a non-vechain network",
      messages: [
        "Ensure your hardhat config file has a network that:",
        "	1. Is a VeChain valid network (set url and optionally delegator parameter)",
        '	2. Has the name of the network containing "vechain" (e.g. "vechain_mainnet", "vechain_testnet", "vechain_solo", ...)',
        "",
        "This is required to use the VeChain provider and its functions.",
        "Note that this is only a warning and you can use hardhat without a VeChain network.",
        "BUT it's possible that some functionalities will not be available."
      ]
    });
    return;
  }
  const hardhatVeChainProvider = new HardhatVeChainProvider(
    createWalletFromHardhatNetworkConfig(networkConfig),
    networkConfig.url,
    (message, parent) => new HardhatPluginError(
      "@vechain/sdk-hardhat-plugin",
      message,
      parent
    ),
    debug,
    enableDelegation
  );
  hre.VeChainProvider = lazyObject(() => hardhatVeChainProvider);
  hre.network.provider = hardhatVeChainProvider;
  hre.ethers = lazyObject(() => {
    const vechainNewHardhatProvider = new HardhatEthersProvider(
      hardhatVeChainProvider,
      hre.network.name
    );
    return {
      ...ethers,
      deployContract: async (...args) => {
        const deployContractBound = deployContract.bind(null, hre);
        return await deployContractBound(...args).then(
          (contract) => contractAdapter(contract, hardhatVeChainProvider)
        );
      },
      getContractFactory: async (...args) => {
        const contractFactoryBound = getContractFactory.bind(null, hre);
        return await contractFactoryBound(...args).then(
          (factory) => factoryAdapter(factory, hardhatVeChainProvider)
        );
      },
      getContractFactoryFromArtifact: async (artifact, signerOrOptions) => {
        const getContractFactoryFromArtifactInstance = getContractFactoryFromArtifact;
        const contractFactoryFromArtifactBound = getContractFactoryFromArtifactInstance.bind(null, hre);
        return await contractFactoryFromArtifactBound(
          artifact,
          signerOrOptions
        ).then(
          (factory) => factoryAdapter(factory, hardhatVeChainProvider)
        );
      },
      getImpersonatedSigner: (_address) => {
        throw new Error("Not implemented yet");
      },
      getContractAtFromArtifact: getContractAtFromArtifact.bind(
        null,
        hre
      ),
      getContractAt: getContractAt.bind(null, hre),
      // Signer
      getSigner: async (address) => await getSigner(hre, address),
      getSigners: async () => await getSigners(hre),
      provider: vechainNewHardhatProvider
    };
  });
});
